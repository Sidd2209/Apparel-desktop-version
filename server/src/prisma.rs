// File generated by Prisma Client Rust. DO NOT EDIT
#![allow(warnings, unused, clippy::all)]

pub static DATAMODEL_STR : & 'static str = include_str ! ("/Users/siddharthshukla/Desktop/Reach/Apparel-desktop-version/server/prisma/schema.prisma") ; static DATABASE_STR : & 'static str = "sqlite" ; use :: prisma_client_rust :: migrations :: include_dir ; pub static MIGRATIONS_DIR : & :: prisma_client_rust :: migrations :: include_dir :: Dir = & :: prisma_client_rust :: migrations :: include_dir :: include_dir ! ("/Users/siddharthshukla/Desktop/Reach/Apparel-desktop-version/server/prisma/migrations") ; pub use _prisma :: * ; use prisma_client_rust :: scalar_types :: * ; pub mod _prisma { use super :: * ; pub struct PrismaClientBuilder { url : Option < String > , action_notifier : :: prisma_client_rust :: ActionNotifier , } impl PrismaClientBuilder { fn new () -> Self { Self { url : None , action_notifier : :: prisma_client_rust :: ActionNotifier :: new () } } pub fn with_url (mut self , url : String) -> Self { self . url = Some (url) ; self } pub async fn build (self) -> Result < PrismaClient , :: prisma_client_rust :: NewClientError > { let internals = :: prisma_client_rust :: PrismaClientInternals :: new (self . url , self . action_notifier , super :: DATAMODEL_STR) . await ? ; Ok (PrismaClient (internals)) } } pub struct PrismaClient (:: prisma_client_rust :: PrismaClientInternals) ; impl :: std :: fmt :: Debug for PrismaClient { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . debug_struct ("PrismaClient") . finish () } } impl PrismaClient { pub fn _builder () -> PrismaClientBuilder { PrismaClientBuilder :: new () } pub fn _query_raw < T : :: prisma_client_rust :: Data > (& self , query : :: prisma_client_rust :: Raw) -> :: prisma_client_rust :: QueryRaw < T > { :: prisma_client_rust :: QueryRaw :: new (& self . 0 , query , super :: DATABASE_STR ,) } pub fn _execute_raw (& self , query : :: prisma_client_rust :: Raw) -> :: prisma_client_rust :: ExecuteRaw { :: prisma_client_rust :: ExecuteRaw :: new (& self . 0 , query , super :: DATABASE_STR ,) } pub async fn _batch < 'batch , T : :: prisma_client_rust :: BatchContainer < 'batch , Marker > , Marker > (& self , queries : T) -> :: prisma_client_rust :: Result << T as :: prisma_client_rust :: BatchContainer < 'batch , Marker >> :: ReturnType > { :: prisma_client_rust :: batch (queries , & self . 0) . await } pub fn _transaction (& self) -> :: prisma_client_rust :: TransactionBuilder < Self > { :: prisma_client_rust :: TransactionBuilder :: _new (self , & self . 0) } pub async fn _migrate_deploy (& self) -> Result < () , :: prisma_client_rust :: migrations :: MigrateDeployError > { let res = :: prisma_client_rust :: migrations :: migrate_deploy (super :: DATAMODEL_STR , super :: MIGRATIONS_DIR , & self . 0 . url ()) . await ; :: prisma_client_rust :: tokio :: time :: sleep (core :: time :: Duration :: from_millis (1)) . await ; res } pub async fn _migrate_resolve (& self , migration : & str) -> Result < () , :: prisma_client_rust :: migrations :: MigrateResolveError > { :: prisma_client_rust :: migrations :: migrate_resolve (migration , super :: DATAMODEL_STR , super :: MIGRATIONS_DIR , & self . 0 . url () ,) . await } pub fn _db_push (& self) -> :: prisma_client_rust :: migrations :: DbPush { :: prisma_client_rust :: migrations :: db_push (super :: DATAMODEL_STR , & self . 0 . url ()) } pub fn user (& self) -> super :: user :: Actions { super :: user :: Actions { client : & self . 0 , } } pub fn product (& self) -> super :: product :: Actions { super :: product :: Actions { client : & self . 0 , } } pub fn order (& self) -> super :: order :: Actions { super :: order :: Actions { client : & self . 0 , } } pub fn sample (& self) -> super :: sample :: Actions { super :: sample :: Actions { client : & self . 0 , } } pub fn design_file (& self) -> super :: design_file :: Actions { super :: design_file :: Actions { client : & self . 0 , } } pub fn costing_sheet (& self) -> super :: costing_sheet :: Actions { super :: costing_sheet :: Actions { client : & self . 0 , } } pub fn production_plan (& self) -> super :: production_plan :: Actions { super :: production_plan :: Actions { client : & self . 0 , } } pub fn resource (& self) -> super :: resource :: Actions { super :: resource :: Actions { client : & self . 0 , } } pub fn inventory_item (& self) -> super :: inventory_item :: Actions { super :: inventory_item :: Actions { client : & self . 0 , } } pub fn inventory_history (& self) -> super :: inventory_history :: Actions { super :: inventory_history :: Actions { client : & self . 0 , } } pub fn inventory_reorder (& self) -> super :: inventory_reorder :: Actions { super :: inventory_reorder :: Actions { client : & self . 0 , } } } impl :: prisma_client_rust :: PrismaClient for PrismaClient { fn internals (& self) -> & :: prisma_client_rust :: PrismaClientInternals { & self . 0 } fn internals_mut (& mut self) -> & mut :: prisma_client_rust :: PrismaClientInternals { & mut self . 0 } fn with_tx_id (& self , tx_id : Option < :: prisma_client_rust :: query_core :: TxId >) -> Self { Self (self . 0 . with_tx_id (tx_id)) } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum TransactionIsolationLevel { # [serde (rename = "Serializable")] Serializable } impl ToString for TransactionIsolationLevel { fn to_string (& self) -> String { match self { Self :: Serializable => "Serializable" . to_string () } } } impl :: prisma_client_rust :: TransactionIsolationLevel for TransactionIsolationLevel { } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum UserScalarFieldEnum { # [serde (rename = "id")] Id , # [serde (rename = "email")] Email , # [serde (rename = "name")] Name , # [serde (rename = "department")] Department , # [serde (rename = "preferredHomepage")] PreferredHomepage , # [serde (rename = "createdAt")] CreatedAt , # [serde (rename = "updatedAt")] UpdatedAt } impl ToString for UserScalarFieldEnum { fn to_string (& self) -> String { match self { Self :: Id => "id" . to_string () , Self :: Email => "email" . to_string () , Self :: Name => "name" . to_string () , Self :: Department => "department" . to_string () , Self :: PreferredHomepage => "preferredHomepage" . to_string () , Self :: CreatedAt => "createdAt" . to_string () , Self :: UpdatedAt => "updatedAt" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum ProductScalarFieldEnum { # [serde (rename = "id")] Id , # [serde (rename = "name")] Name , # [serde (rename = "sku")] Sku , # [serde (rename = "category")] Category , # [serde (rename = "season")] Season , # [serde (rename = "designer")] Designer , # [serde (rename = "status")] Status , # [serde (rename = "developmentStage")] DevelopmentStage , # [serde (rename = "actualHours")] ActualHours , # [serde (rename = "priority")] Priority , # [serde (rename = "createdAt")] CreatedAt , # [serde (rename = "updatedAt")] UpdatedAt } impl ToString for ProductScalarFieldEnum { fn to_string (& self) -> String { match self { Self :: Id => "id" . to_string () , Self :: Name => "name" . to_string () , Self :: Sku => "sku" . to_string () , Self :: Category => "category" . to_string () , Self :: Season => "season" . to_string () , Self :: Designer => "designer" . to_string () , Self :: Status => "status" . to_string () , Self :: DevelopmentStage => "developmentStage" . to_string () , Self :: ActualHours => "actualHours" . to_string () , Self :: Priority => "priority" . to_string () , Self :: CreatedAt => "createdAt" . to_string () , Self :: UpdatedAt => "updatedAt" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum OrderScalarFieldEnum { # [serde (rename = "id")] Id , # [serde (rename = "orderNumber")] OrderNumber , # [serde (rename = "productId")] ProductId , # [serde (rename = "quantity")] Quantity , # [serde (rename = "status")] Status , # [serde (rename = "totalValue")] TotalValue , # [serde (rename = "customerName")] CustomerName , # [serde (rename = "productType")] ProductType , # [serde (rename = "assignedTo")] AssignedTo , # [serde (rename = "validDate")] ValidDate , # [serde (rename = "createdAt")] CreatedAt , # [serde (rename = "updatedAt")] UpdatedAt } impl ToString for OrderScalarFieldEnum { fn to_string (& self) -> String { match self { Self :: Id => "id" . to_string () , Self :: OrderNumber => "orderNumber" . to_string () , Self :: ProductId => "productId" . to_string () , Self :: Quantity => "quantity" . to_string () , Self :: Status => "status" . to_string () , Self :: TotalValue => "totalValue" . to_string () , Self :: CustomerName => "customerName" . to_string () , Self :: ProductType => "productType" . to_string () , Self :: AssignedTo => "assignedTo" . to_string () , Self :: ValidDate => "validDate" . to_string () , Self :: CreatedAt => "createdAt" . to_string () , Self :: UpdatedAt => "updatedAt" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum SampleScalarFieldEnum { # [serde (rename = "id")] Id , # [serde (rename = "productId")] ProductId , # [serde (rename = "type")] Type , # [serde (rename = "status")] Status , # [serde (rename = "notes")] Notes , # [serde (rename = "version")] Version , # [serde (rename = "feedback")] Feedback , # [serde (rename = "approvedBy")] ApprovedBy , # [serde (rename = "createdAt")] CreatedAt } impl ToString for SampleScalarFieldEnum { fn to_string (& self) -> String { match self { Self :: Id => "id" . to_string () , Self :: ProductId => "productId" . to_string () , Self :: Type => "type" . to_string () , Self :: Status => "status" . to_string () , Self :: Notes => "notes" . to_string () , Self :: Version => "version" . to_string () , Self :: Feedback => "feedback" . to_string () , Self :: ApprovedBy => "approvedBy" . to_string () , Self :: CreatedAt => "createdAt" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum DesignFileScalarFieldEnum { # [serde (rename = "id")] Id , # [serde (rename = "productId")] ProductId , # [serde (rename = "fileName")] FileName , # [serde (rename = "fileType")] FileType , # [serde (rename = "url")] Url , # [serde (rename = "version")] Version , # [serde (rename = "isLatest")] IsLatest , # [serde (rename = "uploadedBy")] UploadedBy , # [serde (rename = "uploadedAt")] UploadedAt } impl ToString for DesignFileScalarFieldEnum { fn to_string (& self) -> String { match self { Self :: Id => "id" . to_string () , Self :: ProductId => "productId" . to_string () , Self :: FileName => "fileName" . to_string () , Self :: FileType => "fileType" . to_string () , Self :: Url => "url" . to_string () , Self :: Version => "version" . to_string () , Self :: IsLatest => "isLatest" . to_string () , Self :: UploadedBy => "uploadedBy" . to_string () , Self :: UploadedAt => "uploadedAt" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum CostingSheetScalarFieldEnum { # [serde (rename = "id")] Id , # [serde (rename = "name")] Name , # [serde (rename = "profitMargin")] ProfitMargin , # [serde (rename = "selectedCurrency")] SelectedCurrency , # [serde (rename = "costBreakdown")] CostBreakdown , # [serde (rename = "taxConfig")] TaxConfig , # [serde (rename = "createdAt")] CreatedAt , # [serde (rename = "updatedAt")] UpdatedAt } impl ToString for CostingSheetScalarFieldEnum { fn to_string (& self) -> String { match self { Self :: Id => "id" . to_string () , Self :: Name => "name" . to_string () , Self :: ProfitMargin => "profitMargin" . to_string () , Self :: SelectedCurrency => "selectedCurrency" . to_string () , Self :: CostBreakdown => "costBreakdown" . to_string () , Self :: TaxConfig => "taxConfig" . to_string () , Self :: CreatedAt => "createdAt" . to_string () , Self :: UpdatedAt => "updatedAt" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum ProductionPlanScalarFieldEnum { # [serde (rename = "id")] Id , # [serde (rename = "productName")] ProductName , # [serde (rename = "quantity")] Quantity , # [serde (rename = "startDate")] StartDate , # [serde (rename = "endDate")] EndDate , # [serde (rename = "status")] Status , # [serde (rename = "progress")] Progress , # [serde (rename = "assignedWorkers")] AssignedWorkers , # [serde (rename = "estimatedHours")] EstimatedHours , # [serde (rename = "actualHours")] ActualHours , # [serde (rename = "priority")] Priority , # [serde (rename = "createdAt")] CreatedAt , # [serde (rename = "updatedAt")] UpdatedAt } impl ToString for ProductionPlanScalarFieldEnum { fn to_string (& self) -> String { match self { Self :: Id => "id" . to_string () , Self :: ProductName => "productName" . to_string () , Self :: Quantity => "quantity" . to_string () , Self :: StartDate => "startDate" . to_string () , Self :: EndDate => "endDate" . to_string () , Self :: Status => "status" . to_string () , Self :: Progress => "progress" . to_string () , Self :: AssignedWorkers => "assignedWorkers" . to_string () , Self :: EstimatedHours => "estimatedHours" . to_string () , Self :: ActualHours => "actualHours" . to_string () , Self :: Priority => "priority" . to_string () , Self :: CreatedAt => "createdAt" . to_string () , Self :: UpdatedAt => "updatedAt" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum ResourceScalarFieldEnum { # [serde (rename = "id")] Id , # [serde (rename = "name")] Name , # [serde (rename = "type")] Type , # [serde (rename = "capacity")] Capacity , # [serde (rename = "allocated")] Allocated , # [serde (rename = "available")] Available , # [serde (rename = "efficiency")] Efficiency , # [serde (rename = "createdAt")] CreatedAt , # [serde (rename = "updatedAt")] UpdatedAt } impl ToString for ResourceScalarFieldEnum { fn to_string (& self) -> String { match self { Self :: Id => "id" . to_string () , Self :: Name => "name" . to_string () , Self :: Type => "type" . to_string () , Self :: Capacity => "capacity" . to_string () , Self :: Allocated => "allocated" . to_string () , Self :: Available => "available" . to_string () , Self :: Efficiency => "efficiency" . to_string () , Self :: CreatedAt => "createdAt" . to_string () , Self :: UpdatedAt => "updatedAt" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum InventoryItemScalarFieldEnum { # [serde (rename = "id")] Id , # [serde (rename = "name")] Name , # [serde (rename = "category")] Category , # [serde (rename = "currentStock")] CurrentStock , # [serde (rename = "minStock")] MinStock , # [serde (rename = "maxStock")] MaxStock , # [serde (rename = "unit")] Unit , # [serde (rename = "unitCost")] UnitCost , # [serde (rename = "totalValue")] TotalValue , # [serde (rename = "location")] Location , # [serde (rename = "lastUpdated")] LastUpdated , # [serde (rename = "supplier")] Supplier , # [serde (rename = "createdAt")] CreatedAt , # [serde (rename = "updatedAt")] UpdatedAt } impl ToString for InventoryItemScalarFieldEnum { fn to_string (& self) -> String { match self { Self :: Id => "id" . to_string () , Self :: Name => "name" . to_string () , Self :: Category => "category" . to_string () , Self :: CurrentStock => "currentStock" . to_string () , Self :: MinStock => "minStock" . to_string () , Self :: MaxStock => "maxStock" . to_string () , Self :: Unit => "unit" . to_string () , Self :: UnitCost => "unitCost" . to_string () , Self :: TotalValue => "totalValue" . to_string () , Self :: Location => "location" . to_string () , Self :: LastUpdated => "lastUpdated" . to_string () , Self :: Supplier => "supplier" . to_string () , Self :: CreatedAt => "createdAt" . to_string () , Self :: UpdatedAt => "updatedAt" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum InventoryHistoryScalarFieldEnum { # [serde (rename = "id")] Id , # [serde (rename = "itemId")] ItemId , # [serde (rename = "action")] Action , # [serde (rename = "quantityChange")] QuantityChange , # [serde (rename = "previousStock")] PreviousStock , # [serde (rename = "newStock")] NewStock , # [serde (rename = "note")] Note , # [serde (rename = "user")] User , # [serde (rename = "createdAt")] CreatedAt } impl ToString for InventoryHistoryScalarFieldEnum { fn to_string (& self) -> String { match self { Self :: Id => "id" . to_string () , Self :: ItemId => "itemId" . to_string () , Self :: Action => "action" . to_string () , Self :: QuantityChange => "quantityChange" . to_string () , Self :: PreviousStock => "previousStock" . to_string () , Self :: NewStock => "newStock" . to_string () , Self :: Note => "note" . to_string () , Self :: User => "user" . to_string () , Self :: CreatedAt => "createdAt" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum InventoryReorderScalarFieldEnum { # [serde (rename = "id")] Id , # [serde (rename = "itemId")] ItemId , # [serde (rename = "quantity")] Quantity , # [serde (rename = "supplier")] Supplier , # [serde (rename = "status")] Status , # [serde (rename = "note")] Note , # [serde (rename = "user")] User , # [serde (rename = "createdAt")] CreatedAt } impl ToString for InventoryReorderScalarFieldEnum { fn to_string (& self) -> String { match self { Self :: Id => "id" . to_string () , Self :: ItemId => "itemId" . to_string () , Self :: Quantity => "quantity" . to_string () , Self :: Supplier => "supplier" . to_string () , Self :: Status => "status" . to_string () , Self :: Note => "note" . to_string () , Self :: User => "user" . to_string () , Self :: CreatedAt => "createdAt" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum SortOrder { # [serde (rename = "asc")] Asc , # [serde (rename = "desc")] Desc } impl ToString for SortOrder { fn to_string (& self) -> String { match self { Self :: Asc => "asc" . to_string () , Self :: Desc => "desc" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum NullsOrder { # [serde (rename = "first")] First , # [serde (rename = "last")] Last } impl ToString for NullsOrder { fn to_string (& self) -> String { match self { Self :: First => "first" . to_string () , Self :: Last => "last" . to_string () } } } impl Into < :: prisma_client_rust :: PrismaValue > for SortOrder { fn into (self) -> :: prisma_client_rust :: PrismaValue { match self { SortOrder :: Asc => :: prisma_client_rust :: PrismaValue :: String ("asc" . to_string ()) , SortOrder :: Desc => :: prisma_client_rust :: PrismaValue :: String ("desc" . to_string ()) , } } } pub mod read_filters { use super :: * ; # [derive (Debug , Clone)] pub enum DateTimeFilter { Equals (DateTime) , InVec (Vec < DateTime >) , NotInVec (Vec < DateTime >) , Lt (DateTime) , Lte (DateTime) , Gt (DateTime) , Gte (DateTime) , Not (DateTime) } impl Into < :: prisma_client_rust :: SerializedWhereValue > for DateTimeFilter { fn into (self) -> :: prisma_client_rust :: SerializedWhereValue { match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: DateTime (value)) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: DateTime (value)) . collect ()))]) , Self :: Lt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) , Self :: Lte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) , Self :: Gt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) , Self :: Gte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) } } } # [derive (Debug , Clone)] pub enum FloatFilter { Equals (Float) , InVec (Vec < Float >) , NotInVec (Vec < Float >) , Lt (Float) , Lte (Float) , Gt (Float) , Gte (Float) , Not (Float) } impl Into < :: prisma_client_rust :: SerializedWhereValue > for FloatFilter { fn into (self) -> :: prisma_client_rust :: SerializedWhereValue { match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (value))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: Float (value)) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: Float (value)) . collect ()))]) , Self :: Lt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (value))]) , Self :: Lte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (value))]) , Self :: Gt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (value))]) , Self :: Gte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (value))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (value))]) } } } # [derive (Debug , Clone)] pub enum FloatNullableFilter { Equals (Option < Float >) , InVec (Vec < Float >) , NotInVec (Vec < Float >) , Lt (Float) , Lte (Float) , Gt (Float) , Gte (Float) , Not (Option < Float >) } impl Into < :: prisma_client_rust :: SerializedWhereValue > for FloatNullableFilter { fn into (self) -> :: prisma_client_rust :: SerializedWhereValue { match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: Float (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: Float (value)) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: Float (value)) . collect ()))]) , Self :: Lt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (value))]) , Self :: Lte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (value))]) , Self :: Gt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (value))]) , Self :: Gte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (value))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: Float (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null))]) } } } # [derive (Debug , Clone)] pub enum StringFilter { Equals (String) , InVec (Vec < String >) , NotInVec (Vec < String >) , Lt (String) , Lte (String) , Gt (String) , Gte (String) , Contains (String) , StartsWith (String) , EndsWith (String) , Not (String) } impl Into < :: prisma_client_rust :: SerializedWhereValue > for StringFilter { fn into (self) -> :: prisma_client_rust :: SerializedWhereValue { match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . collect ()))]) , Self :: Lt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Lte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Gt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Gte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Contains (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("contains" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: StartsWith (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("startsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: EndsWith (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("endsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) } } } # [derive (Debug , Clone)] pub enum StringNullableFilter { Equals (Option < String >) , InVec (Vec < String >) , NotInVec (Vec < String >) , Lt (String) , Lte (String) , Gt (String) , Gte (String) , Contains (String) , StartsWith (String) , EndsWith (String) , Not (Option < String >) } impl Into < :: prisma_client_rust :: SerializedWhereValue > for StringNullableFilter { fn into (self) -> :: prisma_client_rust :: SerializedWhereValue { match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . collect ()))]) , Self :: Lt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Lte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Gt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Gte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Contains (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("contains" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: StartsWith (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("startsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: EndsWith (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("endsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null))]) } } } # [derive (Debug , Clone)] pub enum IntFilter { Equals (Int) , InVec (Vec < Int >) , NotInVec (Vec < Int >) , Lt (Int) , Lte (Int) , Gt (Int) , Gte (Int) , Not (Int) } impl Into < :: prisma_client_rust :: SerializedWhereValue > for IntFilter { fn into (self) -> :: prisma_client_rust :: SerializedWhereValue { match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: Int (value)) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: Int (value)) . collect ()))]) , Self :: Lt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value))]) , Self :: Lte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value))]) , Self :: Gt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value))]) , Self :: Gte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value))]) } } } # [derive (Debug , Clone)] pub enum IntNullableFilter { Equals (Option < Int >) , InVec (Vec < Int >) , NotInVec (Vec < Int >) , Lt (Int) , Lte (Int) , Gt (Int) , Gte (Int) , Not (Option < Int >) } impl Into < :: prisma_client_rust :: SerializedWhereValue > for IntNullableFilter { fn into (self) -> :: prisma_client_rust :: SerializedWhereValue { match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: Int (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: Int (value)) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: Int (value)) . collect ()))]) , Self :: Lt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value))]) , Self :: Lte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value))]) , Self :: Gt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value))]) , Self :: Gte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: Int (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null))]) } } } # [derive (Debug , Clone)] pub enum BooleanNullableFilter { Equals (Option < Boolean >) , Not (Option < Boolean >) } impl Into < :: prisma_client_rust :: SerializedWhereValue > for BooleanNullableFilter { fn into (self) -> :: prisma_client_rust :: SerializedWhereValue { match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: Boolean (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: Boolean (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null))]) } } } } pub mod write_params { use super :: * ; # [derive (Debug , Clone)] pub enum BooleanNullableParam { Set (Option < Boolean >) } impl Into < :: prisma_client_rust :: PrismaValue > for BooleanNullableParam { fn into (self) -> :: prisma_client_rust :: PrismaValue { match self { Self :: Set (value) => value . map (| value | :: prisma_client_rust :: PrismaValue :: Boolean (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null) } } } # [derive (Debug , Clone)] pub enum DateTimeParam { Set (DateTime) } impl Into < :: prisma_client_rust :: PrismaValue > for DateTimeParam { fn into (self) -> :: prisma_client_rust :: PrismaValue { match self { Self :: Set (value) => :: prisma_client_rust :: PrismaValue :: DateTime (value) } } } # [derive (Debug , Clone)] pub enum FloatParam { Set (Float) , Increment (Float) , Decrement (Float) , Multiply (Float) , Divide (Float) } impl Into < :: prisma_client_rust :: PrismaValue > for FloatParam { fn into (self) -> :: prisma_client_rust :: PrismaValue { match self { Self :: Set (value) => :: prisma_client_rust :: PrismaValue :: Float (value) , Self :: Increment (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("increment" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (value))]) , Self :: Decrement (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("decrement" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (value))]) , Self :: Multiply (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("multiply" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (value))]) , Self :: Divide (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("divide" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (value))]) } } } # [derive (Debug , Clone)] pub enum FloatNullableParam { Set (Option < Float >) , Increment (Float) , Decrement (Float) , Multiply (Float) , Divide (Float) } impl Into < :: prisma_client_rust :: PrismaValue > for FloatNullableParam { fn into (self) -> :: prisma_client_rust :: PrismaValue { match self { Self :: Set (value) => value . map (| value | :: prisma_client_rust :: PrismaValue :: Float (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null) , Self :: Increment (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("increment" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (value))]) , Self :: Decrement (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("decrement" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (value))]) , Self :: Multiply (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("multiply" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (value))]) , Self :: Divide (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("divide" . to_string () , :: prisma_client_rust :: PrismaValue :: Float (value))]) } } } # [derive (Debug , Clone)] pub enum IntParam { Set (Int) , Increment (Int) , Decrement (Int) , Multiply (Int) , Divide (Int) } impl Into < :: prisma_client_rust :: PrismaValue > for IntParam { fn into (self) -> :: prisma_client_rust :: PrismaValue { match self { Self :: Set (value) => :: prisma_client_rust :: PrismaValue :: Int (value) , Self :: Increment (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("increment" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value))]) , Self :: Decrement (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("decrement" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value))]) , Self :: Multiply (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("multiply" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value))]) , Self :: Divide (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("divide" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value))]) } } } # [derive (Debug , Clone)] pub enum IntNullableParam { Set (Option < Int >) , Increment (Int) , Decrement (Int) , Multiply (Int) , Divide (Int) } impl Into < :: prisma_client_rust :: PrismaValue > for IntNullableParam { fn into (self) -> :: prisma_client_rust :: PrismaValue { match self { Self :: Set (value) => value . map (| value | :: prisma_client_rust :: PrismaValue :: Int (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null) , Self :: Increment (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("increment" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value))]) , Self :: Decrement (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("decrement" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value))]) , Self :: Multiply (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("multiply" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value))]) , Self :: Divide (value) => :: prisma_client_rust :: PrismaValue :: Object (vec ! [("divide" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value))]) } } } # [derive (Debug , Clone)] pub enum StringParam { Set (String) } impl Into < :: prisma_client_rust :: PrismaValue > for StringParam { fn into (self) -> :: prisma_client_rust :: PrismaValue { match self { Self :: Set (value) => :: prisma_client_rust :: PrismaValue :: String (value) } } } # [derive (Debug , Clone)] pub enum StringNullableParam { Set (Option < String >) } impl Into < :: prisma_client_rust :: PrismaValue > for StringNullableParam { fn into (self) -> :: prisma_client_rust :: PrismaValue { match self { Self :: Set (value) => value . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null) } } } } } pub mod user { use super :: { _prisma :: * , * } ; pub const NAME : & str = "User" ; # [derive (Debug , Clone)] pub enum WhereParam { Not (Vec < WhereParam >) , Or (Vec < WhereParam >) , And (Vec < WhereParam >) , Id (super :: _prisma :: read_filters :: StringFilter) , Email (super :: _prisma :: read_filters :: StringFilter) , Name (super :: _prisma :: read_filters :: StringFilter) , Department (super :: _prisma :: read_filters :: StringNullableFilter) , PreferredHomepage (super :: _prisma :: read_filters :: StringNullableFilter) , CreatedAt (super :: _prisma :: read_filters :: DateTimeFilter) , UpdatedAt (super :: _prisma :: read_filters :: DateTimeFilter) } impl :: prisma_client_rust :: WhereInput for WhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (| p | :: prisma_client_rust :: PrismaValue :: Object (vec ! [p . into ()])) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Id (value) => (id :: NAME , value . into ()) , Self :: Email (value) => (email :: NAME , value . into ()) , Self :: Name (value) => (name :: NAME , value . into ()) , Self :: Department (value) => (department :: NAME , value . into ()) , Self :: PreferredHomepage (value) => (preferred_homepage :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) , Self :: UpdatedAt (value) => (updated_at :: NAME , value . into ()) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } # [derive (Debug , Clone)] pub enum UniqueWhereParam { EmailEquals (String) , IdEquals (String) } impl :: prisma_client_rust :: WhereInput for UniqueWhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { UniqueWhereParam :: EmailEquals (value) => ("email" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: String (value))) , UniqueWhereParam :: IdEquals (value) => ("id" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: String (value))) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } impl From < :: prisma_client_rust :: Operator < Self >> for WhereParam { fn from (op : :: prisma_client_rust :: Operator < Self >) -> Self { match op { :: prisma_client_rust :: Operator :: Not (value) => Self :: Not (value) , :: prisma_client_rust :: Operator :: And (value) => Self :: And (value) , :: prisma_client_rust :: Operator :: Or (value) => Self :: Or (value) , } } } # [derive (Debug , Clone)] pub enum OrderByWithRelationParam { Id (super :: SortOrder) , Email (super :: SortOrder) , Name (super :: SortOrder) , Department (super :: SortOrder) , PreferredHomepage (super :: SortOrder) , CreatedAt (super :: SortOrder) , UpdatedAt (super :: SortOrder) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByWithRelationParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (param) => ("id" , param . into ()) , Self :: Email (param) => ("email" , param . into ()) , Self :: Name (param) => ("name" , param . into ()) , Self :: Department (param) => ("department" , param . into ()) , Self :: PreferredHomepage (param) => ("preferredHomepage" , param . into ()) , Self :: CreatedAt (param) => ("createdAt" , param . into ()) , Self :: UpdatedAt (param) => ("updatedAt" , param . into ()) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum WithParam { } impl Into < :: prisma_client_rust :: Selection > for WithParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { } } } # [derive (Debug , Clone)] pub enum SetParam { Id (super :: _prisma :: write_params :: StringParam) , Email (super :: _prisma :: write_params :: StringParam) , Name (super :: _prisma :: write_params :: StringParam) , Department (super :: _prisma :: write_params :: StringNullableParam) , PreferredHomepage (super :: _prisma :: write_params :: StringNullableParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) , UpdatedAt (super :: _prisma :: write_params :: DateTimeParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for SetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => (id :: NAME , value . into ()) , Self :: Email (value) => (email :: NAME , value . into ()) , Self :: Name (value) => (name :: NAME , value . into ()) , Self :: Department (value) => (department :: NAME , value . into ()) , Self :: PreferredHomepage (value) => (preferred_homepage :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) , Self :: UpdatedAt (value) => (updated_at :: NAME , value . into ()) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum UncheckedSetParam { Id (super :: _prisma :: write_params :: StringParam) , Email (super :: _prisma :: write_params :: StringParam) , Name (super :: _prisma :: write_params :: StringParam) , Department (super :: _prisma :: write_params :: StringNullableParam) , PreferredHomepage (super :: _prisma :: write_params :: StringNullableParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) , UpdatedAt (super :: _prisma :: write_params :: DateTimeParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for UncheckedSetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => ("id" , value . into ()) , Self :: Email (value) => ("email" , value . into ()) , Self :: Name (value) => ("name" , value . into ()) , Self :: Department (value) => ("department" , value . into ()) , Self :: PreferredHomepage (value) => ("preferredHomepage" , value . into ()) , Self :: CreatedAt (value) => ("createdAt" , value . into ()) , Self :: UpdatedAt (value) => ("updatedAt" , value . into ()) } ; (k . to_string () , v) } } :: prisma_client_rust :: macros :: select_factory ! (_select_user , select , prisma :: user , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "email")] email : email :: Type , # [serde (rename = "name")] name : name :: Type , # [serde (rename = "department")] department : department :: Type , # [serde (rename = "preferredHomepage")] preferred_homepage : preferred_homepage :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type , # [serde (rename = "updatedAt")] updated_at : updated_at :: Type } , [(id , Scalar) , (email , Scalar) , (name , Scalar) , (department , Scalar) , (preferred_homepage , Scalar) , (created_at , Scalar) , (updated_at , Scalar)]) ; pub enum SelectParam { Id (id :: Select) , Email (email :: Select) , Name (name :: Select) , Department (department :: Select) , PreferredHomepage (preferred_homepage :: Select) , CreatedAt (created_at :: Select) , UpdatedAt (updated_at :: Select) } impl Into < :: prisma_client_rust :: Selection > for SelectParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: Email (data) => data . into () , Self :: Name (data) => data . into () , Self :: Department (data) => data . into () , Self :: PreferredHomepage (data) => data . into () , Self :: CreatedAt (data) => data . into () , Self :: UpdatedAt (data) => data . into () } } } :: prisma_client_rust :: macros :: include_factory ! (_include_user , include , prisma :: user , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "email")] email : email :: Type , # [serde (rename = "name")] name : name :: Type , # [serde (rename = "department")] department : department :: Type , # [serde (rename = "preferredHomepage")] preferred_homepage : preferred_homepage :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type , # [serde (rename = "updatedAt")] updated_at : updated_at :: Type } , []) ; pub enum IncludeParam { Id (id :: Include) , Email (email :: Include) , Name (name :: Include) , Department (department :: Include) , PreferredHomepage (preferred_homepage :: Include) , CreatedAt (created_at :: Include) , UpdatedAt (updated_at :: Include) } impl Into < :: prisma_client_rust :: Selection > for IncludeParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: Email (data) => data . into () , Self :: Name (data) => data . into () , Self :: Department (data) => data . into () , Self :: PreferredHomepage (data) => data . into () , Self :: CreatedAt (data) => data . into () , Self :: UpdatedAt (data) => data . into () } } } # [derive (Debug , Clone)] pub struct Create { pub email : String , pub name : String , pub _params : Vec < SetParam > } impl Create { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateQuery < 'a > { client . user () . create (self . email , self . name , self . _params) } pub fn to_params (mut self) -> Vec < SetParam > { self . _params . extend ([email :: set (self . email) , name :: set (self . name)]) ; self . _params } } pub fn create (email : String , name : String , _params : Vec < SetParam >) -> Create { Create { email , name , _params } } # [derive (Debug , Clone)] pub struct CreateUnchecked { pub email : String , pub name : String , pub _params : Vec < UncheckedSetParam > } impl CreateUnchecked { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateUncheckedQuery < 'a > { client . user () . create_unchecked (self . email , self . name , self . _params) } pub fn to_params (mut self) -> Vec < UncheckedSetParam > { self . _params . extend ([email :: set (self . email) , name :: set (self . name)]) ; self . _params } } pub fn create_unchecked (email : String , name : String , _params : Vec < UncheckedSetParam >) -> CreateUnchecked { CreateUnchecked { email , name , _params } } # [derive (Debug , Clone)] pub struct Types ; impl :: prisma_client_rust :: ModelTypes for Types { type Data = Data ; type Where = WhereParam ; type WhereUnique = UniqueWhereParam ; type UncheckedSet = UncheckedSetParam ; type Set = SetParam ; type With = WithParam ; type OrderBy = OrderByWithRelationParam ; type Cursor = UniqueWhereParam ; const MODEL : & 'static str = NAME ; fn scalar_selections () -> Vec < :: prisma_client_rust :: Selection > { vec ! [:: prisma_client_rust :: sel (id :: NAME) , :: prisma_client_rust :: sel (email :: NAME) , :: prisma_client_rust :: sel (name :: NAME) , :: prisma_client_rust :: sel (department :: NAME) , :: prisma_client_rust :: sel (preferred_homepage :: NAME) , :: prisma_client_rust :: sel (created_at :: NAME) , :: prisma_client_rust :: sel (updated_at :: NAME)] } } # [derive (Debug , Clone , :: serde :: Serialize , :: serde :: Deserialize)] pub struct Data { # [serde (rename = "id")] pub id : id :: Type , # [serde (rename = "email")] pub email : email :: Type , # [serde (rename = "name")] pub name : name :: Type , # [serde (rename = "department")] pub department : department :: Type , # [serde (rename = "preferredHomepage")] pub preferred_homepage : preferred_homepage :: Type , # [serde (rename = "createdAt")] pub created_at : created_at :: Type , # [serde (rename = "updatedAt")] pub updated_at : updated_at :: Type } impl Data { } :: prisma_client_rust :: macros :: partial_unchecked_factory ! (_partial_unchecked_user , prisma :: user , struct Data { # [serde (rename = "id")] pub id : prisma :: user :: id :: Type , # [serde (rename = "email")] pub email : prisma :: user :: email :: Type , # [serde (rename = "name")] pub name : prisma :: user :: name :: Type , # [serde (rename = "department")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub department : prisma :: user :: department :: Type , # [serde (rename = "preferredHomepage")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub preferred_homepage : prisma :: user :: preferred_homepage :: Type , # [serde (rename = "createdAt")] pub created_at : prisma :: user :: created_at :: Type , # [serde (rename = "updatedAt")] pub updated_at : prisma :: user :: updated_at :: Type }) ; :: prisma_client_rust :: macros :: filter_factory ! (_user_filter , prisma :: user , [(id , Scalar) , (email , Scalar) , (name , Scalar) , (department , Scalar) , (preferred_homepage , Scalar) , (created_at , Scalar) , (updated_at , Scalar)]) ; pub type UniqueArgs = :: prisma_client_rust :: UniqueArgs < Types > ; pub type ManyArgs = :: prisma_client_rust :: ManyArgs < Types > ; pub type CountQuery < 'a > = :: prisma_client_rust :: Count < 'a , Types > ; pub type CreateQuery < 'a > = :: prisma_client_rust :: Create < 'a , Types > ; pub type CreateUncheckedQuery < 'a > = :: prisma_client_rust :: CreateUnchecked < 'a , Types > ; pub type CreateManyQuery < 'a > = :: prisma_client_rust :: CreateMany < 'a , Types > ; pub type FindUniqueQuery < 'a > = :: prisma_client_rust :: FindUnique < 'a , Types > ; pub type FindManyQuery < 'a > = :: prisma_client_rust :: FindMany < 'a , Types > ; pub type FindFirstQuery < 'a > = :: prisma_client_rust :: FindFirst < 'a , Types > ; pub type UpdateQuery < 'a > = :: prisma_client_rust :: Update < 'a , Types > ; pub type UpdateUncheckedQuery < 'a > = :: prisma_client_rust :: UpdateUnchecked < 'a , Types > ; pub type UpdateManyQuery < 'a > = :: prisma_client_rust :: UpdateMany < 'a , Types > ; pub type UpsertQuery < 'a > = :: prisma_client_rust :: Upsert < 'a , Types > ; pub type DeleteQuery < 'a > = :: prisma_client_rust :: Delete < 'a , Types > ; pub type DeleteManyQuery < 'a > = :: prisma_client_rust :: DeleteMany < 'a , Types > ; # [derive (Clone)] pub struct Actions < 'a > { pub client : & 'a :: prisma_client_rust :: PrismaClientInternals , } impl < 'a > Actions < 'a > { pub fn find_unique (self , _where : UniqueWhereParam) -> FindUniqueQuery < 'a > { FindUniqueQuery :: new (self . client , _where) } pub fn find_first (self , _where : Vec < WhereParam >) -> FindFirstQuery < 'a > { FindFirstQuery :: new (self . client , _where) } pub fn find_many (self , _where : Vec < WhereParam >) -> FindManyQuery < 'a > { FindManyQuery :: new (self . client , _where) } pub fn create (self , email : impl Into < String > , name : impl Into < String > , mut _params : Vec < SetParam >) -> CreateQuery < 'a > { let email = email . into () ; let name = name . into () ; _params . extend ([email :: set (email) , name :: set (name)]) ; CreateQuery :: new (self . client , _params) } pub fn create_unchecked (self , email : impl Into < String > , name : impl Into < String > , mut _params : Vec < UncheckedSetParam >) -> CreateUncheckedQuery < 'a > { let email = email . into () ; let name = name . into () ; _params . extend ([email :: set (email) , name :: set (name)]) ; CreateUncheckedQuery :: new (self . client , _params . into_iter () . map (Into :: into) . collect ()) } pub fn create_many (self , data : Vec < CreateUnchecked >) -> CreateManyQuery < 'a > { let data = data . into_iter () . map (CreateUnchecked :: to_params) . collect () ; CreateManyQuery :: new (self . client , data) } pub fn update (self , _where : UniqueWhereParam , _params : Vec < SetParam >) -> UpdateQuery < 'a > { UpdateQuery :: new (self . client , _where , _params , vec ! []) } pub fn update_unchecked (self , _where : UniqueWhereParam , _params : Vec < UncheckedSetParam >) -> UpdateUncheckedQuery < 'a > { UpdateUncheckedQuery :: new (self . client , _where , _params . into_iter () . map (Into :: into) . collect () , vec ! []) } pub fn update_many (self , _where : Vec < WhereParam > , _params : Vec < SetParam >) -> UpdateManyQuery < 'a > { UpdateManyQuery :: new (self . client , _where , _params ,) } pub fn upsert (self , _where : UniqueWhereParam , _create : Create , _update : Vec < SetParam >) -> UpsertQuery < 'a > { UpsertQuery :: new (self . client , _where , _create . to_params () , _update) } pub fn delete (self , _where : UniqueWhereParam) -> DeleteQuery < 'a > { DeleteQuery :: new (self . client , _where , vec ! []) } pub fn delete_many (self , _where : Vec < WhereParam >) -> DeleteManyQuery < 'a > { DeleteManyQuery :: new (self . client , _where) } pub fn count (self , _where : Vec < WhereParam >) -> CountQuery < 'a > { CountQuery :: new (self . client , _where) } } pub mod created_at { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "createdAt" ; pub type Type = DateTime ; pub type RecursiveSafeType = Type ; pub struct Equals (pub DateTime) ; pub fn equals < T : From < Equals >> (value : impl Into < DateTime >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: CreatedAt (_prisma :: read_filters :: DateTimeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , CreatedAt , { fn in_vec (_ : Vec < DateTime >) -> InVec ; fn not_in_vec (_ : Vec < DateTime >) -> NotInVec ; fn lt (_ : DateTime) -> Lt ; fn lte (_ : DateTime) -> Lte ; fn gt (_ : DateTime) -> Gt ; fn gte (_ : DateTime) -> Gte ; fn not (_ : DateTime) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: CreatedAt (v) } } pub struct Set (pub DateTime) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < DateTime >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: DateTimeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod department { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "department" ; pub type Type = Option < String > ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Option < String >) ; pub fn equals < T : From < Equals >> (value : impl Into < Option < String > >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Department (_prisma :: read_filters :: StringNullableFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringNullableFilter , Department , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : Option < String >) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Department (v) } } pub struct Set (pub Option < String >) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Department (_prisma :: write_params :: StringNullableParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Option < String > >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringNullableParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Department (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Department (_prisma :: write_params :: StringNullableParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Department (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Department (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Department (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod email { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "email" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: EmailEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Email (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Email , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Email (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Email (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Email (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Email (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Email (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Email (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Email (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "id" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: IdEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Id (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Id , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Id (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod name { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "name" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Name (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Name , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Name (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Name (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Name (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Name (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Name (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Name (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Name (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod preferred_homepage { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "preferredHomepage" ; pub type Type = Option < String > ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Option < String >) ; pub fn equals < T : From < Equals >> (value : impl Into < Option < String > >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: PreferredHomepage (_prisma :: read_filters :: StringNullableFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringNullableFilter , PreferredHomepage , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : Option < String >) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: PreferredHomepage (v) } } pub struct Set (pub Option < String >) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: PreferredHomepage (_prisma :: write_params :: StringNullableParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Option < String > >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringNullableParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: PreferredHomepage (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: PreferredHomepage (_prisma :: write_params :: StringNullableParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: PreferredHomepage (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: PreferredHomepage (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: PreferredHomepage (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod updated_at { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "updatedAt" ; pub type Type = DateTime ; pub type RecursiveSafeType = Type ; pub struct Equals (pub DateTime) ; pub fn equals < T : From < Equals >> (value : impl Into < DateTime >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: UpdatedAt (_prisma :: read_filters :: DateTimeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , UpdatedAt , { fn in_vec (_ : Vec < DateTime >) -> InVec ; fn not_in_vec (_ : Vec < DateTime >) -> NotInVec ; fn lt (_ : DateTime) -> Lt ; fn lte (_ : DateTime) -> Lte ; fn gt (_ : DateTime) -> Gt ; fn gte (_ : DateTime) -> Gte ; fn not (_ : DateTime) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: UpdatedAt (v) } } pub struct Set (pub DateTime) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: UpdatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < DateTime >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: DateTimeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: UpdatedAt (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: UpdatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: UpdatedAt (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: UpdatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: UpdatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } } pub mod product { use super :: { _prisma :: * , * } ; pub const NAME : & str = "Product" ; # [derive (Debug , Clone)] pub enum WhereParam { Not (Vec < WhereParam >) , Or (Vec < WhereParam >) , And (Vec < WhereParam >) , Id (super :: _prisma :: read_filters :: StringFilter) , Name (super :: _prisma :: read_filters :: StringFilter) , Sku (super :: _prisma :: read_filters :: StringNullableFilter) , Category (super :: _prisma :: read_filters :: StringNullableFilter) , Season (super :: _prisma :: read_filters :: StringNullableFilter) , Designer (super :: _prisma :: read_filters :: StringNullableFilter) , Status (super :: _prisma :: read_filters :: StringFilter) , DevelopmentStage (super :: _prisma :: read_filters :: StringFilter) , ActualHours (super :: _prisma :: read_filters :: FloatNullableFilter) , Priority (super :: _prisma :: read_filters :: StringFilter) , CreatedAt (super :: _prisma :: read_filters :: DateTimeFilter) , UpdatedAt (super :: _prisma :: read_filters :: DateTimeFilter) , SamplesSome (Vec < super :: sample :: WhereParam >) , SamplesEvery (Vec < super :: sample :: WhereParam >) , SamplesNone (Vec < super :: sample :: WhereParam >) , DesignFilesSome (Vec < super :: design_file :: WhereParam >) , DesignFilesEvery (Vec < super :: design_file :: WhereParam >) , DesignFilesNone (Vec < super :: design_file :: WhereParam >) } impl :: prisma_client_rust :: WhereInput for WhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (| p | :: prisma_client_rust :: PrismaValue :: Object (vec ! [p . into ()])) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Id (value) => (id :: NAME , value . into ()) , Self :: Name (value) => (name :: NAME , value . into ()) , Self :: Sku (value) => (sku :: NAME , value . into ()) , Self :: Category (value) => (category :: NAME , value . into ()) , Self :: Season (value) => (season :: NAME , value . into ()) , Self :: Designer (value) => (designer :: NAME , value . into ()) , Self :: Status (value) => (status :: NAME , value . into ()) , Self :: DevelopmentStage (value) => (development_stage :: NAME , value . into ()) , Self :: ActualHours (value) => (actual_hours :: NAME , value . into ()) , Self :: Priority (value) => (priority :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) , Self :: UpdatedAt (value) => (updated_at :: NAME , value . into ()) , Self :: SamplesSome (where_params) => (samples :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("some" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: SamplesEvery (where_params) => (samples :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("every" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: SamplesNone (where_params) => (samples :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("none" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: DesignFilesSome (where_params) => (design_files :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("some" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: DesignFilesEvery (where_params) => (design_files :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("every" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: DesignFilesNone (where_params) => (design_files :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("none" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } # [derive (Debug , Clone)] pub enum UniqueWhereParam { SkuEquals (String) , IdEquals (String) } impl :: prisma_client_rust :: WhereInput for UniqueWhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { UniqueWhereParam :: SkuEquals (value) => ("sku" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: String (value))) , UniqueWhereParam :: IdEquals (value) => ("id" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: String (value))) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } impl :: prisma_client_rust :: FromOptionalUniqueArg < sku :: Equals > for WhereParam { type Arg = Option < String > ; fn from_arg (arg : Self :: Arg) -> Self where Self : Sized { Self :: Sku (super :: _prisma :: read_filters :: StringNullableFilter :: Equals (arg)) } } impl :: prisma_client_rust :: FromOptionalUniqueArg < sku :: Equals > for UniqueWhereParam { type Arg = String ; fn from_arg (arg : Self :: Arg) -> Self where Self : Sized { Self :: SkuEquals (arg) } } impl From < :: prisma_client_rust :: Operator < Self >> for WhereParam { fn from (op : :: prisma_client_rust :: Operator < Self >) -> Self { match op { :: prisma_client_rust :: Operator :: Not (value) => Self :: Not (value) , :: prisma_client_rust :: Operator :: And (value) => Self :: And (value) , :: prisma_client_rust :: Operator :: Or (value) => Self :: Or (value) , } } } # [derive (Debug , Clone)] pub enum OrderByWithRelationParam { Id (super :: SortOrder) , Name (super :: SortOrder) , Sku (super :: SortOrder) , Category (super :: SortOrder) , Season (super :: SortOrder) , Designer (super :: SortOrder) , Status (super :: SortOrder) , DevelopmentStage (super :: SortOrder) , ActualHours (super :: SortOrder) , Priority (super :: SortOrder) , CreatedAt (super :: SortOrder) , UpdatedAt (super :: SortOrder) , Samples (Vec < super :: sample :: OrderByRelationAggregateParam >) , DesignFiles (Vec < super :: design_file :: OrderByRelationAggregateParam >) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByWithRelationParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (param) => ("id" , param . into ()) , Self :: Name (param) => ("name" , param . into ()) , Self :: Sku (param) => ("sku" , param . into ()) , Self :: Category (param) => ("category" , param . into ()) , Self :: Season (param) => ("season" , param . into ()) , Self :: Designer (param) => ("designer" , param . into ()) , Self :: Status (param) => ("status" , param . into ()) , Self :: DevelopmentStage (param) => ("developmentStage" , param . into ()) , Self :: ActualHours (param) => ("actualHours" , param . into ()) , Self :: Priority (param) => ("priority" , param . into ()) , Self :: CreatedAt (param) => ("createdAt" , param . into ()) , Self :: UpdatedAt (param) => ("updatedAt" , param . into ()) , Self :: Samples (param) => ("samples" , :: prisma_client_rust :: PrismaValue :: Object (param . into_iter () . map (Into :: into) . collect ())) , Self :: DesignFiles (param) => ("designFiles" , :: prisma_client_rust :: PrismaValue :: Object (param . into_iter () . map (Into :: into) . collect ())) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum WithParam { Samples (super :: sample :: ManyArgs) , DesignFiles (super :: design_file :: ManyArgs) } impl Into < :: prisma_client_rust :: Selection > for WithParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Samples (args) => { let (arguments , mut nested_selections) = args . to_graphql () ; nested_selections . extend (< super :: sample :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ; :: prisma_client_rust :: Selection :: new (samples :: NAME , None , arguments , nested_selections) } , Self :: DesignFiles (args) => { let (arguments , mut nested_selections) = args . to_graphql () ; nested_selections . extend (< super :: design_file :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ; :: prisma_client_rust :: Selection :: new (design_files :: NAME , None , arguments , nested_selections) } } } } # [derive (Debug , Clone)] pub enum SetParam { Id (super :: _prisma :: write_params :: StringParam) , Name (super :: _prisma :: write_params :: StringParam) , Sku (super :: _prisma :: write_params :: StringNullableParam) , Category (super :: _prisma :: write_params :: StringNullableParam) , Season (super :: _prisma :: write_params :: StringNullableParam) , Designer (super :: _prisma :: write_params :: StringNullableParam) , Status (super :: _prisma :: write_params :: StringParam) , DevelopmentStage (super :: _prisma :: write_params :: StringParam) , ActualHours (super :: _prisma :: write_params :: FloatNullableParam) , Priority (super :: _prisma :: write_params :: StringParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) , UpdatedAt (super :: _prisma :: write_params :: DateTimeParam) , ConnectSamples (Vec < super :: sample :: UniqueWhereParam >) , DisconnectSamples (Vec < super :: sample :: UniqueWhereParam >) , SetSamples (Vec < super :: sample :: UniqueWhereParam >) , ConnectDesignFiles (Vec < super :: design_file :: UniqueWhereParam >) , DisconnectDesignFiles (Vec < super :: design_file :: UniqueWhereParam >) , SetDesignFiles (Vec < super :: design_file :: UniqueWhereParam >) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for SetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => (id :: NAME , value . into ()) , Self :: Name (value) => (name :: NAME , value . into ()) , Self :: Sku (value) => (sku :: NAME , value . into ()) , Self :: Category (value) => (category :: NAME , value . into ()) , Self :: Season (value) => (season :: NAME , value . into ()) , Self :: Designer (value) => (designer :: NAME , value . into ()) , Self :: Status (value) => (status :: NAME , value . into ()) , Self :: DevelopmentStage (value) => (development_stage :: NAME , value . into ()) , Self :: ActualHours (value) => (actual_hours :: NAME , value . into ()) , Self :: Priority (value) => (priority :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) , Self :: UpdatedAt (value) => (updated_at :: NAME , value . into ()) , Self :: ConnectSamples (where_params) => (samples :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , Self :: DisconnectSamples (where_params) => (samples :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , Self :: SetSamples (where_params) => (samples :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("set" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , Self :: ConnectDesignFiles (where_params) => (design_files :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , Self :: DisconnectDesignFiles (where_params) => (design_files :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) , Self :: SetDesignFiles (where_params) => (design_files :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("set" . to_string () , :: prisma_client_rust :: PrismaValue :: List (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . map (| v | :: prisma_client_rust :: PrismaValue :: Object (vec ! [v])) . collect ()))])) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum UncheckedSetParam { Id (super :: _prisma :: write_params :: StringParam) , Name (super :: _prisma :: write_params :: StringParam) , Sku (super :: _prisma :: write_params :: StringNullableParam) , Category (super :: _prisma :: write_params :: StringNullableParam) , Season (super :: _prisma :: write_params :: StringNullableParam) , Designer (super :: _prisma :: write_params :: StringNullableParam) , Status (super :: _prisma :: write_params :: StringParam) , DevelopmentStage (super :: _prisma :: write_params :: StringParam) , ActualHours (super :: _prisma :: write_params :: FloatNullableParam) , Priority (super :: _prisma :: write_params :: StringParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) , UpdatedAt (super :: _prisma :: write_params :: DateTimeParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for UncheckedSetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => ("id" , value . into ()) , Self :: Name (value) => ("name" , value . into ()) , Self :: Sku (value) => ("sku" , value . into ()) , Self :: Category (value) => ("category" , value . into ()) , Self :: Season (value) => ("season" , value . into ()) , Self :: Designer (value) => ("designer" , value . into ()) , Self :: Status (value) => ("status" , value . into ()) , Self :: DevelopmentStage (value) => ("developmentStage" , value . into ()) , Self :: ActualHours (value) => ("actualHours" , value . into ()) , Self :: Priority (value) => ("priority" , value . into ()) , Self :: CreatedAt (value) => ("createdAt" , value . into ()) , Self :: UpdatedAt (value) => ("updatedAt" , value . into ()) } ; (k . to_string () , v) } } :: prisma_client_rust :: macros :: select_factory ! (_select_product , select , prisma :: product , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "name")] name : name :: Type , # [serde (rename = "sku")] sku : sku :: Type , # [serde (rename = "category")] category : category :: Type , # [serde (rename = "season")] season : season :: Type , # [serde (rename = "designer")] designer : designer :: Type , # [serde (rename = "status")] status : status :: Type , # [serde (rename = "developmentStage")] development_stage : development_stage :: Type , # [serde (rename = "actualHours")] actual_hours : actual_hours :: Type , # [serde (rename = "priority")] priority : priority :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type , # [serde (rename = "updatedAt")] updated_at : updated_at :: Type , # [serde (rename = "samples")] samples : samples :: Type , # [serde (rename = "designFiles")] design_files : design_files :: Type } , [(id , Scalar) , (name , Scalar) , (sku , Scalar) , (category , Scalar) , (season , Scalar) , (designer , Scalar) , (status , Scalar) , (development_stage , Scalar) , (actual_hours , Scalar) , (priority , Scalar) , (created_at , Scalar) , (updated_at , Scalar) , (samples , Relation (prisma :: sample , Many)) , (design_files , Relation (prisma :: design_file , Many))]) ; pub enum SelectParam { Id (id :: Select) , Name (name :: Select) , Sku (sku :: Select) , Category (category :: Select) , Season (season :: Select) , Designer (designer :: Select) , Status (status :: Select) , DevelopmentStage (development_stage :: Select) , ActualHours (actual_hours :: Select) , Priority (priority :: Select) , CreatedAt (created_at :: Select) , UpdatedAt (updated_at :: Select) , Samples (samples :: Select) , DesignFiles (design_files :: Select) } impl Into < :: prisma_client_rust :: Selection > for SelectParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: Name (data) => data . into () , Self :: Sku (data) => data . into () , Self :: Category (data) => data . into () , Self :: Season (data) => data . into () , Self :: Designer (data) => data . into () , Self :: Status (data) => data . into () , Self :: DevelopmentStage (data) => data . into () , Self :: ActualHours (data) => data . into () , Self :: Priority (data) => data . into () , Self :: CreatedAt (data) => data . into () , Self :: UpdatedAt (data) => data . into () , Self :: Samples (data) => data . into () , Self :: DesignFiles (data) => data . into () } } } :: prisma_client_rust :: macros :: include_factory ! (_include_product , include , prisma :: product , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "name")] name : name :: Type , # [serde (rename = "sku")] sku : sku :: Type , # [serde (rename = "category")] category : category :: Type , # [serde (rename = "season")] season : season :: Type , # [serde (rename = "designer")] designer : designer :: Type , # [serde (rename = "status")] status : status :: Type , # [serde (rename = "developmentStage")] development_stage : development_stage :: Type , # [serde (rename = "actualHours")] actual_hours : actual_hours :: Type , # [serde (rename = "priority")] priority : priority :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type , # [serde (rename = "updatedAt")] updated_at : updated_at :: Type , # [serde (rename = "samples")] samples : samples :: Type , # [serde (rename = "designFiles")] design_files : design_files :: Type } , [(samples , Relation (prisma :: sample , Many)) , (design_files , Relation (prisma :: design_file , Many))]) ; pub enum IncludeParam { Id (id :: Include) , Name (name :: Include) , Sku (sku :: Include) , Category (category :: Include) , Season (season :: Include) , Designer (designer :: Include) , Status (status :: Include) , DevelopmentStage (development_stage :: Include) , ActualHours (actual_hours :: Include) , Priority (priority :: Include) , CreatedAt (created_at :: Include) , UpdatedAt (updated_at :: Include) , Samples (samples :: Include) , DesignFiles (design_files :: Include) } impl Into < :: prisma_client_rust :: Selection > for IncludeParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: Name (data) => data . into () , Self :: Sku (data) => data . into () , Self :: Category (data) => data . into () , Self :: Season (data) => data . into () , Self :: Designer (data) => data . into () , Self :: Status (data) => data . into () , Self :: DevelopmentStage (data) => data . into () , Self :: ActualHours (data) => data . into () , Self :: Priority (data) => data . into () , Self :: CreatedAt (data) => data . into () , Self :: UpdatedAt (data) => data . into () , Self :: Samples (data) => data . into () , Self :: DesignFiles (data) => data . into () } } } # [derive (Debug , Clone)] pub struct Create { pub name : String , pub status : String , pub development_stage : String , pub priority : String , pub _params : Vec < SetParam > } impl Create { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateQuery < 'a > { client . product () . create (self . name , self . status , self . development_stage , self . priority , self . _params) } pub fn to_params (mut self) -> Vec < SetParam > { self . _params . extend ([name :: set (self . name) , status :: set (self . status) , development_stage :: set (self . development_stage) , priority :: set (self . priority)]) ; self . _params } } pub fn create (name : String , status : String , development_stage : String , priority : String , _params : Vec < SetParam >) -> Create { Create { name , status , development_stage , priority , _params } } # [derive (Debug , Clone)] pub struct CreateUnchecked { pub name : String , pub status : String , pub development_stage : String , pub priority : String , pub _params : Vec < UncheckedSetParam > } impl CreateUnchecked { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateUncheckedQuery < 'a > { client . product () . create_unchecked (self . name , self . status , self . development_stage , self . priority , self . _params) } pub fn to_params (mut self) -> Vec < UncheckedSetParam > { self . _params . extend ([name :: set (self . name) , status :: set (self . status) , development_stage :: set (self . development_stage) , priority :: set (self . priority)]) ; self . _params } } pub fn create_unchecked (name : String , status : String , development_stage : String , priority : String , _params : Vec < UncheckedSetParam >) -> CreateUnchecked { CreateUnchecked { name , status , development_stage , priority , _params } } # [derive (Debug , Clone)] pub struct Types ; impl :: prisma_client_rust :: ModelTypes for Types { type Data = Data ; type Where = WhereParam ; type WhereUnique = UniqueWhereParam ; type UncheckedSet = UncheckedSetParam ; type Set = SetParam ; type With = WithParam ; type OrderBy = OrderByWithRelationParam ; type Cursor = UniqueWhereParam ; const MODEL : & 'static str = NAME ; fn scalar_selections () -> Vec < :: prisma_client_rust :: Selection > { vec ! [:: prisma_client_rust :: sel (id :: NAME) , :: prisma_client_rust :: sel (name :: NAME) , :: prisma_client_rust :: sel (sku :: NAME) , :: prisma_client_rust :: sel (category :: NAME) , :: prisma_client_rust :: sel (season :: NAME) , :: prisma_client_rust :: sel (designer :: NAME) , :: prisma_client_rust :: sel (status :: NAME) , :: prisma_client_rust :: sel (development_stage :: NAME) , :: prisma_client_rust :: sel (actual_hours :: NAME) , :: prisma_client_rust :: sel (priority :: NAME) , :: prisma_client_rust :: sel (created_at :: NAME) , :: prisma_client_rust :: sel (updated_at :: NAME)] } } # [derive (Debug , Clone , :: serde :: Serialize , :: serde :: Deserialize)] pub struct Data { # [serde (rename = "id")] pub id : id :: Type , # [serde (rename = "name")] pub name : name :: Type , # [serde (rename = "sku")] pub sku : sku :: Type , # [serde (rename = "category")] pub category : category :: Type , # [serde (rename = "season")] pub season : season :: Type , # [serde (rename = "designer")] pub designer : designer :: Type , # [serde (rename = "status")] pub status : status :: Type , # [serde (rename = "developmentStage")] pub development_stage : development_stage :: Type , # [serde (rename = "actualHours")] pub actual_hours : actual_hours :: Type , # [serde (rename = "priority")] pub priority : priority :: Type , # [serde (rename = "createdAt")] pub created_at : created_at :: Type , # [serde (rename = "updatedAt")] pub updated_at : updated_at :: Type , # [serde (rename = "samples")] pub samples : Option < samples :: RecursiveSafeType > , # [serde (rename = "designFiles")] pub design_files : Option < design_files :: RecursiveSafeType > } impl Data { pub fn samples (& self) -> Result < & samples :: Type , :: prisma_client_rust :: RelationNotFetchedError > { self . samples . as_ref () . ok_or (:: prisma_client_rust :: RelationNotFetchedError :: new (stringify ! (samples))) } pub fn design_files (& self) -> Result < & design_files :: Type , :: prisma_client_rust :: RelationNotFetchedError > { self . design_files . as_ref () . ok_or (:: prisma_client_rust :: RelationNotFetchedError :: new (stringify ! (design_files))) } } :: prisma_client_rust :: macros :: partial_unchecked_factory ! (_partial_unchecked_product , prisma :: product , struct Data { # [serde (rename = "id")] pub id : prisma :: product :: id :: Type , # [serde (rename = "name")] pub name : prisma :: product :: name :: Type , # [serde (rename = "sku")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub sku : prisma :: product :: sku :: Type , # [serde (rename = "category")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub category : prisma :: product :: category :: Type , # [serde (rename = "season")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub season : prisma :: product :: season :: Type , # [serde (rename = "designer")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub designer : prisma :: product :: designer :: Type , # [serde (rename = "status")] pub status : prisma :: product :: status :: Type , # [serde (rename = "developmentStage")] pub development_stage : prisma :: product :: development_stage :: Type , # [serde (rename = "actualHours")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub actual_hours : prisma :: product :: actual_hours :: Type , # [serde (rename = "priority")] pub priority : prisma :: product :: priority :: Type , # [serde (rename = "createdAt")] pub created_at : prisma :: product :: created_at :: Type , # [serde (rename = "updatedAt")] pub updated_at : prisma :: product :: updated_at :: Type }) ; :: prisma_client_rust :: macros :: filter_factory ! (_product_filter , prisma :: product , [(id , Scalar) , (name , Scalar) , (sku , Scalar) , (category , Scalar) , (season , Scalar) , (designer , Scalar) , (status , Scalar) , (development_stage , Scalar) , (actual_hours , Scalar) , (priority , Scalar) , (created_at , Scalar) , (updated_at , Scalar) , (samples , Relation (prisma :: sample , Many)) , (design_files , Relation (prisma :: design_file , Many))]) ; pub type UniqueArgs = :: prisma_client_rust :: UniqueArgs < Types > ; pub type ManyArgs = :: prisma_client_rust :: ManyArgs < Types > ; pub type CountQuery < 'a > = :: prisma_client_rust :: Count < 'a , Types > ; pub type CreateQuery < 'a > = :: prisma_client_rust :: Create < 'a , Types > ; pub type CreateUncheckedQuery < 'a > = :: prisma_client_rust :: CreateUnchecked < 'a , Types > ; pub type CreateManyQuery < 'a > = :: prisma_client_rust :: CreateMany < 'a , Types > ; pub type FindUniqueQuery < 'a > = :: prisma_client_rust :: FindUnique < 'a , Types > ; pub type FindManyQuery < 'a > = :: prisma_client_rust :: FindMany < 'a , Types > ; pub type FindFirstQuery < 'a > = :: prisma_client_rust :: FindFirst < 'a , Types > ; pub type UpdateQuery < 'a > = :: prisma_client_rust :: Update < 'a , Types > ; pub type UpdateUncheckedQuery < 'a > = :: prisma_client_rust :: UpdateUnchecked < 'a , Types > ; pub type UpdateManyQuery < 'a > = :: prisma_client_rust :: UpdateMany < 'a , Types > ; pub type UpsertQuery < 'a > = :: prisma_client_rust :: Upsert < 'a , Types > ; pub type DeleteQuery < 'a > = :: prisma_client_rust :: Delete < 'a , Types > ; pub type DeleteManyQuery < 'a > = :: prisma_client_rust :: DeleteMany < 'a , Types > ; # [derive (Clone)] pub struct Actions < 'a > { pub client : & 'a :: prisma_client_rust :: PrismaClientInternals , } impl < 'a > Actions < 'a > { pub fn find_unique (self , _where : UniqueWhereParam) -> FindUniqueQuery < 'a > { FindUniqueQuery :: new (self . client , _where) } pub fn find_first (self , _where : Vec < WhereParam >) -> FindFirstQuery < 'a > { FindFirstQuery :: new (self . client , _where) } pub fn find_many (self , _where : Vec < WhereParam >) -> FindManyQuery < 'a > { FindManyQuery :: new (self . client , _where) } pub fn create (self , name : impl Into < String > , status : impl Into < String > , development_stage : impl Into < String > , priority : impl Into < String > , mut _params : Vec < SetParam >) -> CreateQuery < 'a > { let name = name . into () ; let status = status . into () ; let development_stage = development_stage . into () ; let priority = priority . into () ; _params . extend ([name :: set (name) , status :: set (status) , development_stage :: set (development_stage) , priority :: set (priority)]) ; CreateQuery :: new (self . client , _params) } pub fn create_unchecked (self , name : impl Into < String > , status : impl Into < String > , development_stage : impl Into < String > , priority : impl Into < String > , mut _params : Vec < UncheckedSetParam >) -> CreateUncheckedQuery < 'a > { let name = name . into () ; let status = status . into () ; let development_stage = development_stage . into () ; let priority = priority . into () ; _params . extend ([name :: set (name) , status :: set (status) , development_stage :: set (development_stage) , priority :: set (priority)]) ; CreateUncheckedQuery :: new (self . client , _params . into_iter () . map (Into :: into) . collect ()) } pub fn create_many (self , data : Vec < CreateUnchecked >) -> CreateManyQuery < 'a > { let data = data . into_iter () . map (CreateUnchecked :: to_params) . collect () ; CreateManyQuery :: new (self . client , data) } pub fn update (self , _where : UniqueWhereParam , _params : Vec < SetParam >) -> UpdateQuery < 'a > { UpdateQuery :: new (self . client , _where , _params , vec ! []) } pub fn update_unchecked (self , _where : UniqueWhereParam , _params : Vec < UncheckedSetParam >) -> UpdateUncheckedQuery < 'a > { UpdateUncheckedQuery :: new (self . client , _where , _params . into_iter () . map (Into :: into) . collect () , vec ! []) } pub fn update_many (self , _where : Vec < WhereParam > , _params : Vec < SetParam >) -> UpdateManyQuery < 'a > { UpdateManyQuery :: new (self . client , _where , _params ,) } pub fn upsert (self , _where : UniqueWhereParam , _create : Create , _update : Vec < SetParam >) -> UpsertQuery < 'a > { UpsertQuery :: new (self . client , _where , _create . to_params () , _update) } pub fn delete (self , _where : UniqueWhereParam) -> DeleteQuery < 'a > { DeleteQuery :: new (self . client , _where , vec ! []) } pub fn delete_many (self , _where : Vec < WhereParam >) -> DeleteManyQuery < 'a > { DeleteManyQuery :: new (self . client , _where) } pub fn count (self , _where : Vec < WhereParam >) -> CountQuery < 'a > { CountQuery :: new (self . client , _where) } } pub mod actual_hours { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "actualHours" ; pub type Type = Option < Float > ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Option < Float >) ; pub fn equals < T : From < Equals >> (value : impl Into < Option < Float > >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: ActualHours (_prisma :: read_filters :: FloatNullableFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: FloatNullableFilter , ActualHours , { fn in_vec (_ : Vec < Float >) -> InVec ; fn not_in_vec (_ : Vec < Float >) -> NotInVec ; fn lt (_ : Float) -> Lt ; fn lte (_ : Float) -> Lte ; fn gt (_ : Float) -> Gt ; fn gte (_ : Float) -> Gte ; fn not (_ : Option < Float >) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: ActualHours (v) } } pub struct Set (pub Option < Float >) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: ActualHours (_prisma :: write_params :: FloatNullableParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Option < Float > >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: FloatNullableParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ActualHours (v) } } pub fn increment < T : From < UpdateOperation >> (value : Float) -> T { UpdateOperation (_prisma :: write_params :: FloatNullableParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : Float) -> T { UpdateOperation (_prisma :: write_params :: FloatNullableParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : Float) -> T { UpdateOperation (_prisma :: write_params :: FloatNullableParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : Float) -> T { UpdateOperation (_prisma :: write_params :: FloatNullableParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: ActualHours (_prisma :: write_params :: FloatNullableParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ActualHours (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: ActualHours (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: ActualHours (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod category { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "category" ; pub type Type = Option < String > ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Option < String >) ; pub fn equals < T : From < Equals >> (value : impl Into < Option < String > >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Category (_prisma :: read_filters :: StringNullableFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringNullableFilter , Category , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : Option < String >) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Category (v) } } pub struct Set (pub Option < String >) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Category (_prisma :: write_params :: StringNullableParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Option < String > >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringNullableParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Category (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Category (_prisma :: write_params :: StringNullableParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Category (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Category (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Category (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod created_at { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "createdAt" ; pub type Type = DateTime ; pub type RecursiveSafeType = Type ; pub struct Equals (pub DateTime) ; pub fn equals < T : From < Equals >> (value : impl Into < DateTime >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: CreatedAt (_prisma :: read_filters :: DateTimeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , CreatedAt , { fn in_vec (_ : Vec < DateTime >) -> InVec ; fn not_in_vec (_ : Vec < DateTime >) -> NotInVec ; fn lt (_ : DateTime) -> Lt ; fn lte (_ : DateTime) -> Lte ; fn gt (_ : DateTime) -> Gt ; fn gte (_ : DateTime) -> Gte ; fn not (_ : DateTime) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: CreatedAt (v) } } pub struct Set (pub DateTime) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < DateTime >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: DateTimeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod design_files { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "designFiles" ; pub type Type = Vec < design_file :: Data > ; pub type RecursiveSafeType = Type ; pub fn some (value : Vec < design_file :: WhereParam >) -> WhereParam { WhereParam :: DesignFilesSome (value) } pub fn every (value : Vec < design_file :: WhereParam >) -> WhereParam { WhereParam :: DesignFilesEvery (value) } pub fn none (value : Vec < design_file :: WhereParam >) -> WhereParam { WhereParam :: DesignFilesNone (value) } pub struct Order (Vec < design_file :: OrderByRelationAggregateParam >) ; pub fn order < T : From < Order >> (v : Vec < design_file :: OrderByRelationAggregateParam >) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: DesignFiles (v) } } pub struct Fetch (pub design_file :: ManyArgs) ; impl Fetch { pub fn with (mut self , params : impl Into < design_file :: WithParam >) -> Self { self . 0 = self . 0 . with (params . into ()) ; self } pub fn order_by (mut self , param : design_file :: OrderByWithRelationParam) -> Self { self . 0 = self . 0 . order_by (param) ; self } pub fn skip (mut self , value : i64) -> Self { self . 0 = self . 0 . skip (value) ; self } pub fn take (mut self , value : i64) -> Self { self . 0 = self . 0 . take (value) ; self } pub fn cursor (mut self , value : design_file :: UniqueWhereParam) -> Self { self . 0 = self . 0 . cursor (value . into ()) ; self } } impl From < Fetch > for WithParam { fn from (Fetch (v) : Fetch) -> Self { WithParam :: DesignFiles (v) } } pub fn fetch (params : Vec < design_file :: WhereParam >) -> Fetch { Fetch (design_file :: ManyArgs :: new (params)) } pub struct Connect (pub Vec < design_file :: UniqueWhereParam >) ; impl From < Connect > for SetParam { fn from (Connect (v) : Connect) -> Self { Self :: ConnectDesignFiles (v) } } pub fn connect < T : From < Connect >> (params : Vec < design_file :: UniqueWhereParam >) -> T { Connect (params) . into () } pub fn disconnect (params : Vec < design_file :: UniqueWhereParam >) -> SetParam { SetParam :: DisconnectDesignFiles (params) } pub fn set (params : Vec < design_file :: UniqueWhereParam >) -> SetParam { SetParam :: SetDesignFiles (params) } pub enum Select { Select (design_file :: ManyArgs , Vec < design_file :: SelectParam >) , Include (design_file :: ManyArgs , Vec < design_file :: IncludeParam >) , Fetch (design_file :: ManyArgs) } impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: DesignFiles (self) } } impl Select { pub fn select (args : design_file :: ManyArgs , nested_selections : Vec < design_file :: SelectParam >) -> Self { Self :: Select (args , nested_selections) } pub fn include (args : design_file :: ManyArgs , nested_selections : Vec < design_file :: IncludeParam >) -> Self { Self :: Include (args , nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (Into :: into) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < design_file :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ; :: prisma_client_rust :: Selection :: new (NAME , None , args , selections) } } pub enum Include { Select (design_file :: ManyArgs , Vec < design_file :: SelectParam >) , Include (design_file :: ManyArgs , Vec < design_file :: IncludeParam >) , Fetch (design_file :: ManyArgs) } impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: DesignFiles (self) } } impl Include { pub fn select (args : design_file :: ManyArgs , nested_selections : Vec < design_file :: SelectParam >) -> Self { Self :: Select (args , nested_selections) } pub fn include (args : design_file :: ManyArgs , nested_selections : Vec < design_file :: IncludeParam >) -> Self { Self :: Include (args , nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (Into :: into) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < design_file :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < design_file :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ; :: prisma_client_rust :: Selection :: new (NAME , None , args , selections) } } } pub mod designer { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "designer" ; pub type Type = Option < String > ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Option < String >) ; pub fn equals < T : From < Equals >> (value : impl Into < Option < String > >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Designer (_prisma :: read_filters :: StringNullableFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringNullableFilter , Designer , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : Option < String >) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Designer (v) } } pub struct Set (pub Option < String >) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Designer (_prisma :: write_params :: StringNullableParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Option < String > >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringNullableParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Designer (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Designer (_prisma :: write_params :: StringNullableParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Designer (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Designer (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Designer (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod development_stage { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "developmentStage" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: DevelopmentStage (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , DevelopmentStage , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: DevelopmentStage (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: DevelopmentStage (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: DevelopmentStage (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: DevelopmentStage (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: DevelopmentStage (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: DevelopmentStage (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: DevelopmentStage (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "id" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: IdEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Id (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Id , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Id (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod name { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "name" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Name (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Name , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Name (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Name (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Name (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Name (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Name (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Name (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Name (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod priority { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "priority" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Priority (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Priority , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Priority (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Priority (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Priority (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Priority (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Priority (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Priority (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Priority (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod samples { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "samples" ; pub type Type = Vec < sample :: Data > ; pub type RecursiveSafeType = Type ; pub fn some (value : Vec < sample :: WhereParam >) -> WhereParam { WhereParam :: SamplesSome (value) } pub fn every (value : Vec < sample :: WhereParam >) -> WhereParam { WhereParam :: SamplesEvery (value) } pub fn none (value : Vec < sample :: WhereParam >) -> WhereParam { WhereParam :: SamplesNone (value) } pub struct Order (Vec < sample :: OrderByRelationAggregateParam >) ; pub fn order < T : From < Order >> (v : Vec < sample :: OrderByRelationAggregateParam >) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Samples (v) } } pub struct Fetch (pub sample :: ManyArgs) ; impl Fetch { pub fn with (mut self , params : impl Into < sample :: WithParam >) -> Self { self . 0 = self . 0 . with (params . into ()) ; self } pub fn order_by (mut self , param : sample :: OrderByWithRelationParam) -> Self { self . 0 = self . 0 . order_by (param) ; self } pub fn skip (mut self , value : i64) -> Self { self . 0 = self . 0 . skip (value) ; self } pub fn take (mut self , value : i64) -> Self { self . 0 = self . 0 . take (value) ; self } pub fn cursor (mut self , value : sample :: UniqueWhereParam) -> Self { self . 0 = self . 0 . cursor (value . into ()) ; self } } impl From < Fetch > for WithParam { fn from (Fetch (v) : Fetch) -> Self { WithParam :: Samples (v) } } pub fn fetch (params : Vec < sample :: WhereParam >) -> Fetch { Fetch (sample :: ManyArgs :: new (params)) } pub struct Connect (pub Vec < sample :: UniqueWhereParam >) ; impl From < Connect > for SetParam { fn from (Connect (v) : Connect) -> Self { Self :: ConnectSamples (v) } } pub fn connect < T : From < Connect >> (params : Vec < sample :: UniqueWhereParam >) -> T { Connect (params) . into () } pub fn disconnect (params : Vec < sample :: UniqueWhereParam >) -> SetParam { SetParam :: DisconnectSamples (params) } pub fn set (params : Vec < sample :: UniqueWhereParam >) -> SetParam { SetParam :: SetSamples (params) } pub enum Select { Select (sample :: ManyArgs , Vec < sample :: SelectParam >) , Include (sample :: ManyArgs , Vec < sample :: IncludeParam >) , Fetch (sample :: ManyArgs) } impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Samples (self) } } impl Select { pub fn select (args : sample :: ManyArgs , nested_selections : Vec < sample :: SelectParam >) -> Self { Self :: Select (args , nested_selections) } pub fn include (args : sample :: ManyArgs , nested_selections : Vec < sample :: IncludeParam >) -> Self { Self :: Include (args , nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (Into :: into) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < sample :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ; :: prisma_client_rust :: Selection :: new (NAME , None , args , selections) } } pub enum Include { Select (sample :: ManyArgs , Vec < sample :: SelectParam >) , Include (sample :: ManyArgs , Vec < sample :: IncludeParam >) , Fetch (sample :: ManyArgs) } impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Samples (self) } } impl Include { pub fn select (args : sample :: ManyArgs , nested_selections : Vec < sample :: SelectParam >) -> Self { Self :: Select (args , nested_selections) } pub fn include (args : sample :: ManyArgs , nested_selections : Vec < sample :: IncludeParam >) -> Self { Self :: Include (args , nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (Into :: into) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < sample :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < sample :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ; :: prisma_client_rust :: Selection :: new (NAME , None , args , selections) } } } pub mod season { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "season" ; pub type Type = Option < String > ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Option < String >) ; pub fn equals < T : From < Equals >> (value : impl Into < Option < String > >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Season (_prisma :: read_filters :: StringNullableFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringNullableFilter , Season , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : Option < String >) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Season (v) } } pub struct Set (pub Option < String >) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Season (_prisma :: write_params :: StringNullableParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Option < String > >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringNullableParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Season (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Season (_prisma :: write_params :: StringNullableParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Season (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Season (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Season (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod sku { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "sku" ; pub type Type = Option < String > ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Option < String >) ; pub fn equals < T : :: prisma_client_rust :: FromOptionalUniqueArg < Equals >> (value : T :: Arg) -> T { T :: from_arg (value) } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Sku (_prisma :: read_filters :: StringNullableFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringNullableFilter , Sku , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : Option < String >) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Sku (v) } } pub struct Set (pub Option < String >) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Sku (_prisma :: write_params :: StringNullableParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Option < String > >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringNullableParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Sku (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Sku (_prisma :: write_params :: StringNullableParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Sku (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Sku (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Sku (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod status { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "status" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Status (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Status , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Status (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Status (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Status (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Status (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Status (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Status (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Status (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod updated_at { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "updatedAt" ; pub type Type = DateTime ; pub type RecursiveSafeType = Type ; pub struct Equals (pub DateTime) ; pub fn equals < T : From < Equals >> (value : impl Into < DateTime >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: UpdatedAt (_prisma :: read_filters :: DateTimeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , UpdatedAt , { fn in_vec (_ : Vec < DateTime >) -> InVec ; fn not_in_vec (_ : Vec < DateTime >) -> NotInVec ; fn lt (_ : DateTime) -> Lt ; fn lte (_ : DateTime) -> Lte ; fn gt (_ : DateTime) -> Gt ; fn gte (_ : DateTime) -> Gte ; fn not (_ : DateTime) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: UpdatedAt (v) } } pub struct Set (pub DateTime) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: UpdatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < DateTime >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: DateTimeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: UpdatedAt (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: UpdatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: UpdatedAt (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: UpdatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: UpdatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } } pub mod order { use super :: { _prisma :: * , * } ; pub const NAME : & str = "Order" ; # [derive (Debug , Clone)] pub enum WhereParam { Not (Vec < WhereParam >) , Or (Vec < WhereParam >) , And (Vec < WhereParam >) , Id (super :: _prisma :: read_filters :: StringFilter) , OrderNumber (super :: _prisma :: read_filters :: StringFilter) , ProductId (super :: _prisma :: read_filters :: StringFilter) , Quantity (super :: _prisma :: read_filters :: IntFilter) , Status (super :: _prisma :: read_filters :: StringFilter) , TotalValue (super :: _prisma :: read_filters :: FloatFilter) , CustomerName (super :: _prisma :: read_filters :: StringFilter) , ProductType (super :: _prisma :: read_filters :: StringFilter) , AssignedTo (super :: _prisma :: read_filters :: StringFilter) , ValidDate (super :: _prisma :: read_filters :: DateTimeFilter) , CreatedAt (super :: _prisma :: read_filters :: DateTimeFilter) , UpdatedAt (super :: _prisma :: read_filters :: DateTimeFilter) } impl :: prisma_client_rust :: WhereInput for WhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (| p | :: prisma_client_rust :: PrismaValue :: Object (vec ! [p . into ()])) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Id (value) => (id :: NAME , value . into ()) , Self :: OrderNumber (value) => (order_number :: NAME , value . into ()) , Self :: ProductId (value) => (product_id :: NAME , value . into ()) , Self :: Quantity (value) => (quantity :: NAME , value . into ()) , Self :: Status (value) => (status :: NAME , value . into ()) , Self :: TotalValue (value) => (total_value :: NAME , value . into ()) , Self :: CustomerName (value) => (customer_name :: NAME , value . into ()) , Self :: ProductType (value) => (product_type :: NAME , value . into ()) , Self :: AssignedTo (value) => (assigned_to :: NAME , value . into ()) , Self :: ValidDate (value) => (valid_date :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) , Self :: UpdatedAt (value) => (updated_at :: NAME , value . into ()) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } # [derive (Debug , Clone)] pub enum UniqueWhereParam { OrderNumberEquals (String) , IdEquals (String) } impl :: prisma_client_rust :: WhereInput for UniqueWhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { UniqueWhereParam :: OrderNumberEquals (value) => ("orderNumber" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: String (value))) , UniqueWhereParam :: IdEquals (value) => ("id" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: String (value))) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } impl From < :: prisma_client_rust :: Operator < Self >> for WhereParam { fn from (op : :: prisma_client_rust :: Operator < Self >) -> Self { match op { :: prisma_client_rust :: Operator :: Not (value) => Self :: Not (value) , :: prisma_client_rust :: Operator :: And (value) => Self :: And (value) , :: prisma_client_rust :: Operator :: Or (value) => Self :: Or (value) , } } } # [derive (Debug , Clone)] pub enum OrderByWithRelationParam { Id (super :: SortOrder) , OrderNumber (super :: SortOrder) , ProductId (super :: SortOrder) , Quantity (super :: SortOrder) , Status (super :: SortOrder) , TotalValue (super :: SortOrder) , CustomerName (super :: SortOrder) , ProductType (super :: SortOrder) , AssignedTo (super :: SortOrder) , ValidDate (super :: SortOrder) , CreatedAt (super :: SortOrder) , UpdatedAt (super :: SortOrder) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByWithRelationParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (param) => ("id" , param . into ()) , Self :: OrderNumber (param) => ("orderNumber" , param . into ()) , Self :: ProductId (param) => ("productId" , param . into ()) , Self :: Quantity (param) => ("quantity" , param . into ()) , Self :: Status (param) => ("status" , param . into ()) , Self :: TotalValue (param) => ("totalValue" , param . into ()) , Self :: CustomerName (param) => ("customerName" , param . into ()) , Self :: ProductType (param) => ("productType" , param . into ()) , Self :: AssignedTo (param) => ("assignedTo" , param . into ()) , Self :: ValidDate (param) => ("validDate" , param . into ()) , Self :: CreatedAt (param) => ("createdAt" , param . into ()) , Self :: UpdatedAt (param) => ("updatedAt" , param . into ()) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum WithParam { } impl Into < :: prisma_client_rust :: Selection > for WithParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { } } } # [derive (Debug , Clone)] pub enum SetParam { Id (super :: _prisma :: write_params :: StringParam) , OrderNumber (super :: _prisma :: write_params :: StringParam) , ProductId (super :: _prisma :: write_params :: StringParam) , Quantity (super :: _prisma :: write_params :: IntParam) , Status (super :: _prisma :: write_params :: StringParam) , TotalValue (super :: _prisma :: write_params :: FloatParam) , CustomerName (super :: _prisma :: write_params :: StringParam) , ProductType (super :: _prisma :: write_params :: StringParam) , AssignedTo (super :: _prisma :: write_params :: StringParam) , ValidDate (super :: _prisma :: write_params :: DateTimeParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) , UpdatedAt (super :: _prisma :: write_params :: DateTimeParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for SetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => (id :: NAME , value . into ()) , Self :: OrderNumber (value) => (order_number :: NAME , value . into ()) , Self :: ProductId (value) => (product_id :: NAME , value . into ()) , Self :: Quantity (value) => (quantity :: NAME , value . into ()) , Self :: Status (value) => (status :: NAME , value . into ()) , Self :: TotalValue (value) => (total_value :: NAME , value . into ()) , Self :: CustomerName (value) => (customer_name :: NAME , value . into ()) , Self :: ProductType (value) => (product_type :: NAME , value . into ()) , Self :: AssignedTo (value) => (assigned_to :: NAME , value . into ()) , Self :: ValidDate (value) => (valid_date :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) , Self :: UpdatedAt (value) => (updated_at :: NAME , value . into ()) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum UncheckedSetParam { Id (super :: _prisma :: write_params :: StringParam) , OrderNumber (super :: _prisma :: write_params :: StringParam) , ProductId (super :: _prisma :: write_params :: StringParam) , Quantity (super :: _prisma :: write_params :: IntParam) , Status (super :: _prisma :: write_params :: StringParam) , TotalValue (super :: _prisma :: write_params :: FloatParam) , CustomerName (super :: _prisma :: write_params :: StringParam) , ProductType (super :: _prisma :: write_params :: StringParam) , AssignedTo (super :: _prisma :: write_params :: StringParam) , ValidDate (super :: _prisma :: write_params :: DateTimeParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) , UpdatedAt (super :: _prisma :: write_params :: DateTimeParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for UncheckedSetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => ("id" , value . into ()) , Self :: OrderNumber (value) => ("orderNumber" , value . into ()) , Self :: ProductId (value) => ("productId" , value . into ()) , Self :: Quantity (value) => ("quantity" , value . into ()) , Self :: Status (value) => ("status" , value . into ()) , Self :: TotalValue (value) => ("totalValue" , value . into ()) , Self :: CustomerName (value) => ("customerName" , value . into ()) , Self :: ProductType (value) => ("productType" , value . into ()) , Self :: AssignedTo (value) => ("assignedTo" , value . into ()) , Self :: ValidDate (value) => ("validDate" , value . into ()) , Self :: CreatedAt (value) => ("createdAt" , value . into ()) , Self :: UpdatedAt (value) => ("updatedAt" , value . into ()) } ; (k . to_string () , v) } } :: prisma_client_rust :: macros :: select_factory ! (_select_order , select , prisma :: order , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "orderNumber")] order_number : order_number :: Type , # [serde (rename = "productId")] product_id : product_id :: Type , # [serde (rename = "quantity")] quantity : quantity :: Type , # [serde (rename = "status")] status : status :: Type , # [serde (rename = "totalValue")] total_value : total_value :: Type , # [serde (rename = "customerName")] customer_name : customer_name :: Type , # [serde (rename = "productType")] product_type : product_type :: Type , # [serde (rename = "assignedTo")] assigned_to : assigned_to :: Type , # [serde (rename = "validDate")] valid_date : valid_date :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type , # [serde (rename = "updatedAt")] updated_at : updated_at :: Type } , [(id , Scalar) , (order_number , Scalar) , (product_id , Scalar) , (quantity , Scalar) , (status , Scalar) , (total_value , Scalar) , (customer_name , Scalar) , (product_type , Scalar) , (assigned_to , Scalar) , (valid_date , Scalar) , (created_at , Scalar) , (updated_at , Scalar)]) ; pub enum SelectParam { Id (id :: Select) , OrderNumber (order_number :: Select) , ProductId (product_id :: Select) , Quantity (quantity :: Select) , Status (status :: Select) , TotalValue (total_value :: Select) , CustomerName (customer_name :: Select) , ProductType (product_type :: Select) , AssignedTo (assigned_to :: Select) , ValidDate (valid_date :: Select) , CreatedAt (created_at :: Select) , UpdatedAt (updated_at :: Select) } impl Into < :: prisma_client_rust :: Selection > for SelectParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: OrderNumber (data) => data . into () , Self :: ProductId (data) => data . into () , Self :: Quantity (data) => data . into () , Self :: Status (data) => data . into () , Self :: TotalValue (data) => data . into () , Self :: CustomerName (data) => data . into () , Self :: ProductType (data) => data . into () , Self :: AssignedTo (data) => data . into () , Self :: ValidDate (data) => data . into () , Self :: CreatedAt (data) => data . into () , Self :: UpdatedAt (data) => data . into () } } } :: prisma_client_rust :: macros :: include_factory ! (_include_order , include , prisma :: order , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "orderNumber")] order_number : order_number :: Type , # [serde (rename = "productId")] product_id : product_id :: Type , # [serde (rename = "quantity")] quantity : quantity :: Type , # [serde (rename = "status")] status : status :: Type , # [serde (rename = "totalValue")] total_value : total_value :: Type , # [serde (rename = "customerName")] customer_name : customer_name :: Type , # [serde (rename = "productType")] product_type : product_type :: Type , # [serde (rename = "assignedTo")] assigned_to : assigned_to :: Type , # [serde (rename = "validDate")] valid_date : valid_date :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type , # [serde (rename = "updatedAt")] updated_at : updated_at :: Type } , []) ; pub enum IncludeParam { Id (id :: Include) , OrderNumber (order_number :: Include) , ProductId (product_id :: Include) , Quantity (quantity :: Include) , Status (status :: Include) , TotalValue (total_value :: Include) , CustomerName (customer_name :: Include) , ProductType (product_type :: Include) , AssignedTo (assigned_to :: Include) , ValidDate (valid_date :: Include) , CreatedAt (created_at :: Include) , UpdatedAt (updated_at :: Include) } impl Into < :: prisma_client_rust :: Selection > for IncludeParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: OrderNumber (data) => data . into () , Self :: ProductId (data) => data . into () , Self :: Quantity (data) => data . into () , Self :: Status (data) => data . into () , Self :: TotalValue (data) => data . into () , Self :: CustomerName (data) => data . into () , Self :: ProductType (data) => data . into () , Self :: AssignedTo (data) => data . into () , Self :: ValidDate (data) => data . into () , Self :: CreatedAt (data) => data . into () , Self :: UpdatedAt (data) => data . into () } } } # [derive (Debug , Clone)] pub struct Create { pub order_number : String , pub product_id : String , pub quantity : Int , pub status : String , pub total_value : Float , pub customer_name : String , pub product_type : String , pub assigned_to : String , pub valid_date : DateTime , pub _params : Vec < SetParam > } impl Create { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateQuery < 'a > { client . order () . create (self . order_number , self . product_id , self . quantity , self . status , self . total_value , self . customer_name , self . product_type , self . assigned_to , self . valid_date , self . _params) } pub fn to_params (mut self) -> Vec < SetParam > { self . _params . extend ([order_number :: set (self . order_number) , product_id :: set (self . product_id) , quantity :: set (self . quantity) , status :: set (self . status) , total_value :: set (self . total_value) , customer_name :: set (self . customer_name) , product_type :: set (self . product_type) , assigned_to :: set (self . assigned_to) , valid_date :: set (self . valid_date)]) ; self . _params } } pub fn create (order_number : String , product_id : String , quantity : Int , status : String , total_value : Float , customer_name : String , product_type : String , assigned_to : String , valid_date : DateTime , _params : Vec < SetParam >) -> Create { Create { order_number , product_id , quantity , status , total_value , customer_name , product_type , assigned_to , valid_date , _params } } # [derive (Debug , Clone)] pub struct CreateUnchecked { pub order_number : String , pub product_id : String , pub quantity : Int , pub status : String , pub total_value : Float , pub customer_name : String , pub product_type : String , pub assigned_to : String , pub valid_date : DateTime , pub _params : Vec < UncheckedSetParam > } impl CreateUnchecked { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateUncheckedQuery < 'a > { client . order () . create_unchecked (self . order_number , self . product_id , self . quantity , self . status , self . total_value , self . customer_name , self . product_type , self . assigned_to , self . valid_date , self . _params) } pub fn to_params (mut self) -> Vec < UncheckedSetParam > { self . _params . extend ([order_number :: set (self . order_number) , product_id :: set (self . product_id) , quantity :: set (self . quantity) , status :: set (self . status) , total_value :: set (self . total_value) , customer_name :: set (self . customer_name) , product_type :: set (self . product_type) , assigned_to :: set (self . assigned_to) , valid_date :: set (self . valid_date)]) ; self . _params } } pub fn create_unchecked (order_number : String , product_id : String , quantity : Int , status : String , total_value : Float , customer_name : String , product_type : String , assigned_to : String , valid_date : DateTime , _params : Vec < UncheckedSetParam >) -> CreateUnchecked { CreateUnchecked { order_number , product_id , quantity , status , total_value , customer_name , product_type , assigned_to , valid_date , _params } } # [derive (Debug , Clone)] pub struct Types ; impl :: prisma_client_rust :: ModelTypes for Types { type Data = Data ; type Where = WhereParam ; type WhereUnique = UniqueWhereParam ; type UncheckedSet = UncheckedSetParam ; type Set = SetParam ; type With = WithParam ; type OrderBy = OrderByWithRelationParam ; type Cursor = UniqueWhereParam ; const MODEL : & 'static str = NAME ; fn scalar_selections () -> Vec < :: prisma_client_rust :: Selection > { vec ! [:: prisma_client_rust :: sel (id :: NAME) , :: prisma_client_rust :: sel (order_number :: NAME) , :: prisma_client_rust :: sel (product_id :: NAME) , :: prisma_client_rust :: sel (quantity :: NAME) , :: prisma_client_rust :: sel (status :: NAME) , :: prisma_client_rust :: sel (total_value :: NAME) , :: prisma_client_rust :: sel (customer_name :: NAME) , :: prisma_client_rust :: sel (product_type :: NAME) , :: prisma_client_rust :: sel (assigned_to :: NAME) , :: prisma_client_rust :: sel (valid_date :: NAME) , :: prisma_client_rust :: sel (created_at :: NAME) , :: prisma_client_rust :: sel (updated_at :: NAME)] } } # [derive (Debug , Clone , :: serde :: Serialize , :: serde :: Deserialize)] pub struct Data { # [serde (rename = "id")] pub id : id :: Type , # [serde (rename = "orderNumber")] pub order_number : order_number :: Type , # [serde (rename = "productId")] pub product_id : product_id :: Type , # [serde (rename = "quantity")] pub quantity : quantity :: Type , # [serde (rename = "status")] pub status : status :: Type , # [serde (rename = "totalValue")] pub total_value : total_value :: Type , # [serde (rename = "customerName")] pub customer_name : customer_name :: Type , # [serde (rename = "productType")] pub product_type : product_type :: Type , # [serde (rename = "assignedTo")] pub assigned_to : assigned_to :: Type , # [serde (rename = "validDate")] pub valid_date : valid_date :: Type , # [serde (rename = "createdAt")] pub created_at : created_at :: Type , # [serde (rename = "updatedAt")] pub updated_at : updated_at :: Type } impl Data { } :: prisma_client_rust :: macros :: partial_unchecked_factory ! (_partial_unchecked_order , prisma :: order , struct Data { # [serde (rename = "id")] pub id : prisma :: order :: id :: Type , # [serde (rename = "orderNumber")] pub order_number : prisma :: order :: order_number :: Type , # [serde (rename = "productId")] pub product_id : prisma :: order :: product_id :: Type , # [serde (rename = "quantity")] pub quantity : prisma :: order :: quantity :: Type , # [serde (rename = "status")] pub status : prisma :: order :: status :: Type , # [serde (rename = "totalValue")] pub total_value : prisma :: order :: total_value :: Type , # [serde (rename = "customerName")] pub customer_name : prisma :: order :: customer_name :: Type , # [serde (rename = "productType")] pub product_type : prisma :: order :: product_type :: Type , # [serde (rename = "assignedTo")] pub assigned_to : prisma :: order :: assigned_to :: Type , # [serde (rename = "validDate")] pub valid_date : prisma :: order :: valid_date :: Type , # [serde (rename = "createdAt")] pub created_at : prisma :: order :: created_at :: Type , # [serde (rename = "updatedAt")] pub updated_at : prisma :: order :: updated_at :: Type }) ; :: prisma_client_rust :: macros :: filter_factory ! (_order_filter , prisma :: order , [(id , Scalar) , (order_number , Scalar) , (product_id , Scalar) , (quantity , Scalar) , (status , Scalar) , (total_value , Scalar) , (customer_name , Scalar) , (product_type , Scalar) , (assigned_to , Scalar) , (valid_date , Scalar) , (created_at , Scalar) , (updated_at , Scalar)]) ; pub type UniqueArgs = :: prisma_client_rust :: UniqueArgs < Types > ; pub type ManyArgs = :: prisma_client_rust :: ManyArgs < Types > ; pub type CountQuery < 'a > = :: prisma_client_rust :: Count < 'a , Types > ; pub type CreateQuery < 'a > = :: prisma_client_rust :: Create < 'a , Types > ; pub type CreateUncheckedQuery < 'a > = :: prisma_client_rust :: CreateUnchecked < 'a , Types > ; pub type CreateManyQuery < 'a > = :: prisma_client_rust :: CreateMany < 'a , Types > ; pub type FindUniqueQuery < 'a > = :: prisma_client_rust :: FindUnique < 'a , Types > ; pub type FindManyQuery < 'a > = :: prisma_client_rust :: FindMany < 'a , Types > ; pub type FindFirstQuery < 'a > = :: prisma_client_rust :: FindFirst < 'a , Types > ; pub type UpdateQuery < 'a > = :: prisma_client_rust :: Update < 'a , Types > ; pub type UpdateUncheckedQuery < 'a > = :: prisma_client_rust :: UpdateUnchecked < 'a , Types > ; pub type UpdateManyQuery < 'a > = :: prisma_client_rust :: UpdateMany < 'a , Types > ; pub type UpsertQuery < 'a > = :: prisma_client_rust :: Upsert < 'a , Types > ; pub type DeleteQuery < 'a > = :: prisma_client_rust :: Delete < 'a , Types > ; pub type DeleteManyQuery < 'a > = :: prisma_client_rust :: DeleteMany < 'a , Types > ; # [derive (Clone)] pub struct Actions < 'a > { pub client : & 'a :: prisma_client_rust :: PrismaClientInternals , } impl < 'a > Actions < 'a > { pub fn find_unique (self , _where : UniqueWhereParam) -> FindUniqueQuery < 'a > { FindUniqueQuery :: new (self . client , _where) } pub fn find_first (self , _where : Vec < WhereParam >) -> FindFirstQuery < 'a > { FindFirstQuery :: new (self . client , _where) } pub fn find_many (self , _where : Vec < WhereParam >) -> FindManyQuery < 'a > { FindManyQuery :: new (self . client , _where) } pub fn create (self , order_number : impl Into < String > , product_id : impl Into < String > , quantity : impl Into < Int > , status : impl Into < String > , total_value : impl Into < Float > , customer_name : impl Into < String > , product_type : impl Into < String > , assigned_to : impl Into < String > , valid_date : impl Into < DateTime > , mut _params : Vec < SetParam >) -> CreateQuery < 'a > { let order_number = order_number . into () ; let product_id = product_id . into () ; let quantity = quantity . into () ; let status = status . into () ; let total_value = total_value . into () ; let customer_name = customer_name . into () ; let product_type = product_type . into () ; let assigned_to = assigned_to . into () ; let valid_date = valid_date . into () ; _params . extend ([order_number :: set (order_number) , product_id :: set (product_id) , quantity :: set (quantity) , status :: set (status) , total_value :: set (total_value) , customer_name :: set (customer_name) , product_type :: set (product_type) , assigned_to :: set (assigned_to) , valid_date :: set (valid_date)]) ; CreateQuery :: new (self . client , _params) } pub fn create_unchecked (self , order_number : impl Into < String > , product_id : impl Into < String > , quantity : impl Into < Int > , status : impl Into < String > , total_value : impl Into < Float > , customer_name : impl Into < String > , product_type : impl Into < String > , assigned_to : impl Into < String > , valid_date : impl Into < DateTime > , mut _params : Vec < UncheckedSetParam >) -> CreateUncheckedQuery < 'a > { let order_number = order_number . into () ; let product_id = product_id . into () ; let quantity = quantity . into () ; let status = status . into () ; let total_value = total_value . into () ; let customer_name = customer_name . into () ; let product_type = product_type . into () ; let assigned_to = assigned_to . into () ; let valid_date = valid_date . into () ; _params . extend ([order_number :: set (order_number) , product_id :: set (product_id) , quantity :: set (quantity) , status :: set (status) , total_value :: set (total_value) , customer_name :: set (customer_name) , product_type :: set (product_type) , assigned_to :: set (assigned_to) , valid_date :: set (valid_date)]) ; CreateUncheckedQuery :: new (self . client , _params . into_iter () . map (Into :: into) . collect ()) } pub fn create_many (self , data : Vec < CreateUnchecked >) -> CreateManyQuery < 'a > { let data = data . into_iter () . map (CreateUnchecked :: to_params) . collect () ; CreateManyQuery :: new (self . client , data) } pub fn update (self , _where : UniqueWhereParam , _params : Vec < SetParam >) -> UpdateQuery < 'a > { UpdateQuery :: new (self . client , _where , _params , vec ! []) } pub fn update_unchecked (self , _where : UniqueWhereParam , _params : Vec < UncheckedSetParam >) -> UpdateUncheckedQuery < 'a > { UpdateUncheckedQuery :: new (self . client , _where , _params . into_iter () . map (Into :: into) . collect () , vec ! []) } pub fn update_many (self , _where : Vec < WhereParam > , _params : Vec < SetParam >) -> UpdateManyQuery < 'a > { UpdateManyQuery :: new (self . client , _where , _params ,) } pub fn upsert (self , _where : UniqueWhereParam , _create : Create , _update : Vec < SetParam >) -> UpsertQuery < 'a > { UpsertQuery :: new (self . client , _where , _create . to_params () , _update) } pub fn delete (self , _where : UniqueWhereParam) -> DeleteQuery < 'a > { DeleteQuery :: new (self . client , _where , vec ! []) } pub fn delete_many (self , _where : Vec < WhereParam >) -> DeleteManyQuery < 'a > { DeleteManyQuery :: new (self . client , _where) } pub fn count (self , _where : Vec < WhereParam >) -> CountQuery < 'a > { CountQuery :: new (self . client , _where) } } pub mod assigned_to { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "assignedTo" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: AssignedTo (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , AssignedTo , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: AssignedTo (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: AssignedTo (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: AssignedTo (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: AssignedTo (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: AssignedTo (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: AssignedTo (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: AssignedTo (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod created_at { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "createdAt" ; pub type Type = DateTime ; pub type RecursiveSafeType = Type ; pub struct Equals (pub DateTime) ; pub fn equals < T : From < Equals >> (value : impl Into < DateTime >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: CreatedAt (_prisma :: read_filters :: DateTimeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , CreatedAt , { fn in_vec (_ : Vec < DateTime >) -> InVec ; fn not_in_vec (_ : Vec < DateTime >) -> NotInVec ; fn lt (_ : DateTime) -> Lt ; fn lte (_ : DateTime) -> Lte ; fn gt (_ : DateTime) -> Gt ; fn gte (_ : DateTime) -> Gte ; fn not (_ : DateTime) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: CreatedAt (v) } } pub struct Set (pub DateTime) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < DateTime >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: DateTimeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod customer_name { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "customerName" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: CustomerName (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , CustomerName , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: CustomerName (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: CustomerName (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CustomerName (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: CustomerName (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CustomerName (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: CustomerName (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: CustomerName (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "id" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: IdEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Id (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Id , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Id (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod order_number { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "orderNumber" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: OrderNumberEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: OrderNumber (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , OrderNumber , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: OrderNumber (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: OrderNumber (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: OrderNumber (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: OrderNumber (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: OrderNumber (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: OrderNumber (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: OrderNumber (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod product_id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "productId" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: ProductId (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , ProductId , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: ProductId (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: ProductId (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ProductId (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: ProductId (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ProductId (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: ProductId (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: ProductId (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod product_type { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "productType" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: ProductType (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , ProductType , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: ProductType (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: ProductType (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ProductType (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: ProductType (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ProductType (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: ProductType (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: ProductType (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod quantity { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "quantity" ; pub type Type = Int ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Int) ; pub fn equals < T : From < Equals >> (value : impl Into < Int >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Quantity (_prisma :: read_filters :: IntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: IntFilter , Quantity , { fn in_vec (_ : Vec < Int >) -> InVec ; fn not_in_vec (_ : Vec < Int >) -> NotInVec ; fn lt (_ : Int) -> Lt ; fn lte (_ : Int) -> Lte ; fn gt (_ : Int) -> Gt ; fn gte (_ : Int) -> Gte ; fn not (_ : Int) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Quantity (v) } } pub struct Set (pub Int) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Quantity (_prisma :: write_params :: IntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Int >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: IntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Quantity (v) } } pub fn increment < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Quantity (_prisma :: write_params :: IntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Quantity (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Quantity (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Quantity (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod status { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "status" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Status (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Status , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Status (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Status (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Status (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Status (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Status (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Status (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Status (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod total_value { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "totalValue" ; pub type Type = Float ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Float) ; pub fn equals < T : From < Equals >> (value : impl Into < Float >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: TotalValue (_prisma :: read_filters :: FloatFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: FloatFilter , TotalValue , { fn in_vec (_ : Vec < Float >) -> InVec ; fn not_in_vec (_ : Vec < Float >) -> NotInVec ; fn lt (_ : Float) -> Lt ; fn lte (_ : Float) -> Lte ; fn gt (_ : Float) -> Gt ; fn gte (_ : Float) -> Gte ; fn not (_ : Float) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: TotalValue (v) } } pub struct Set (pub Float) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: TotalValue (_prisma :: write_params :: FloatParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Float >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: FloatParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: TotalValue (v) } } pub fn increment < T : From < UpdateOperation >> (value : Float) -> T { UpdateOperation (_prisma :: write_params :: FloatParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : Float) -> T { UpdateOperation (_prisma :: write_params :: FloatParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : Float) -> T { UpdateOperation (_prisma :: write_params :: FloatParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : Float) -> T { UpdateOperation (_prisma :: write_params :: FloatParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: TotalValue (_prisma :: write_params :: FloatParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: TotalValue (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: TotalValue (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: TotalValue (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod updated_at { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "updatedAt" ; pub type Type = DateTime ; pub type RecursiveSafeType = Type ; pub struct Equals (pub DateTime) ; pub fn equals < T : From < Equals >> (value : impl Into < DateTime >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: UpdatedAt (_prisma :: read_filters :: DateTimeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , UpdatedAt , { fn in_vec (_ : Vec < DateTime >) -> InVec ; fn not_in_vec (_ : Vec < DateTime >) -> NotInVec ; fn lt (_ : DateTime) -> Lt ; fn lte (_ : DateTime) -> Lte ; fn gt (_ : DateTime) -> Gt ; fn gte (_ : DateTime) -> Gte ; fn not (_ : DateTime) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: UpdatedAt (v) } } pub struct Set (pub DateTime) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: UpdatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < DateTime >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: DateTimeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: UpdatedAt (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: UpdatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: UpdatedAt (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: UpdatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: UpdatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod valid_date { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "validDate" ; pub type Type = DateTime ; pub type RecursiveSafeType = Type ; pub struct Equals (pub DateTime) ; pub fn equals < T : From < Equals >> (value : impl Into < DateTime >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: ValidDate (_prisma :: read_filters :: DateTimeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , ValidDate , { fn in_vec (_ : Vec < DateTime >) -> InVec ; fn not_in_vec (_ : Vec < DateTime >) -> NotInVec ; fn lt (_ : DateTime) -> Lt ; fn lte (_ : DateTime) -> Lte ; fn gt (_ : DateTime) -> Gt ; fn gte (_ : DateTime) -> Gte ; fn not (_ : DateTime) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: ValidDate (v) } } pub struct Set (pub DateTime) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: ValidDate (_prisma :: write_params :: DateTimeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < DateTime >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: DateTimeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ValidDate (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: ValidDate (_prisma :: write_params :: DateTimeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ValidDate (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: ValidDate (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: ValidDate (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } } pub mod sample { use super :: { _prisma :: * , * } ; pub const NAME : & str = "Sample" ; # [derive (Debug , Clone)] pub enum WhereParam { Not (Vec < WhereParam >) , Or (Vec < WhereParam >) , And (Vec < WhereParam >) , Id (super :: _prisma :: read_filters :: StringFilter) , ProductIs (Vec < super :: product :: WhereParam >) , ProductIsNot (Vec < super :: product :: WhereParam >) , ProductId (super :: _prisma :: read_filters :: StringFilter) , Type (super :: _prisma :: read_filters :: StringFilter) , Status (super :: _prisma :: read_filters :: StringFilter) , Notes (super :: _prisma :: read_filters :: StringNullableFilter) , Version (super :: _prisma :: read_filters :: IntNullableFilter) , Feedback (super :: _prisma :: read_filters :: StringNullableFilter) , ApprovedBy (super :: _prisma :: read_filters :: StringNullableFilter) , CreatedAt (super :: _prisma :: read_filters :: DateTimeFilter) } impl :: prisma_client_rust :: WhereInput for WhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (| p | :: prisma_client_rust :: PrismaValue :: Object (vec ! [p . into ()])) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Id (value) => (id :: NAME , value . into ()) , Self :: ProductIs (where_params) => (product :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("is" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: ProductIsNot (where_params) => (product :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("isNot" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: ProductId (value) => (product_id :: NAME , value . into ()) , Self :: Type (value) => (r#type :: NAME , value . into ()) , Self :: Status (value) => (status :: NAME , value . into ()) , Self :: Notes (value) => (notes :: NAME , value . into ()) , Self :: Version (value) => (version :: NAME , value . into ()) , Self :: Feedback (value) => (feedback :: NAME , value . into ()) , Self :: ApprovedBy (value) => (approved_by :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } # [derive (Debug , Clone)] pub enum UniqueWhereParam { IdEquals (String) } impl :: prisma_client_rust :: WhereInput for UniqueWhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { UniqueWhereParam :: IdEquals (value) => ("id" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: String (value))) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } impl From < :: prisma_client_rust :: Operator < Self >> for WhereParam { fn from (op : :: prisma_client_rust :: Operator < Self >) -> Self { match op { :: prisma_client_rust :: Operator :: Not (value) => Self :: Not (value) , :: prisma_client_rust :: Operator :: And (value) => Self :: And (value) , :: prisma_client_rust :: Operator :: Or (value) => Self :: Or (value) , } } } # [derive (Debug , Clone)] pub enum OrderByWithRelationParam { Id (super :: SortOrder) , ProductId (super :: SortOrder) , Type (super :: SortOrder) , Status (super :: SortOrder) , Notes (super :: SortOrder) , Version (super :: SortOrder) , Feedback (super :: SortOrder) , ApprovedBy (super :: SortOrder) , CreatedAt (super :: SortOrder) , Product (Vec < super :: product :: OrderByWithRelationParam >) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByWithRelationParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (param) => ("id" , param . into ()) , Self :: ProductId (param) => ("productId" , param . into ()) , Self :: Type (param) => ("type" , param . into ()) , Self :: Status (param) => ("status" , param . into ()) , Self :: Notes (param) => ("notes" , param . into ()) , Self :: Version (param) => ("version" , param . into ()) , Self :: Feedback (param) => ("feedback" , param . into ()) , Self :: ApprovedBy (param) => ("approvedBy" , param . into ()) , Self :: CreatedAt (param) => ("createdAt" , param . into ()) , Self :: Product (param) => ("product" , :: prisma_client_rust :: PrismaValue :: Object (param . into_iter () . map (Into :: into) . collect ())) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum OrderByRelationAggregateParam { _Count (super :: SortOrder) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByRelationAggregateParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: _Count (param) => ("_count" , param . into ()) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum WithParam { Product (super :: product :: UniqueArgs) } impl Into < :: prisma_client_rust :: Selection > for WithParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Product (args) => { let mut selections = < super :: product :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; selections . extend (args . with_params . into_iter () . map (Into :: < :: prisma_client_rust :: Selection > :: into)) ; :: prisma_client_rust :: Selection :: new (product :: NAME , None , [] , selections) } } } } # [derive (Debug , Clone)] pub enum SetParam { Id (super :: _prisma :: write_params :: StringParam) , ConnectProduct (super :: product :: UniqueWhereParam) , ProductId (super :: _prisma :: write_params :: StringParam) , Type (super :: _prisma :: write_params :: StringParam) , Status (super :: _prisma :: write_params :: StringParam) , Notes (super :: _prisma :: write_params :: StringNullableParam) , Version (super :: _prisma :: write_params :: IntNullableParam) , Feedback (super :: _prisma :: write_params :: StringNullableParam) , ApprovedBy (super :: _prisma :: write_params :: StringNullableParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for SetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => (id :: NAME , value . into ()) , Self :: ConnectProduct (where_param) => (product :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: Object ([where_param] . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()))])) , Self :: ProductId (value) => (product_id :: NAME , value . into ()) , Self :: Type (value) => (r#type :: NAME , value . into ()) , Self :: Status (value) => (status :: NAME , value . into ()) , Self :: Notes (value) => (notes :: NAME , value . into ()) , Self :: Version (value) => (version :: NAME , value . into ()) , Self :: Feedback (value) => (feedback :: NAME , value . into ()) , Self :: ApprovedBy (value) => (approved_by :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum UncheckedSetParam { Id (super :: _prisma :: write_params :: StringParam) , ProductId (super :: _prisma :: write_params :: StringParam) , Type (super :: _prisma :: write_params :: StringParam) , Status (super :: _prisma :: write_params :: StringParam) , Notes (super :: _prisma :: write_params :: StringNullableParam) , Version (super :: _prisma :: write_params :: IntNullableParam) , Feedback (super :: _prisma :: write_params :: StringNullableParam) , ApprovedBy (super :: _prisma :: write_params :: StringNullableParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for UncheckedSetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => ("id" , value . into ()) , Self :: ProductId (value) => ("productId" , value . into ()) , Self :: Type (value) => ("type" , value . into ()) , Self :: Status (value) => ("status" , value . into ()) , Self :: Notes (value) => ("notes" , value . into ()) , Self :: Version (value) => ("version" , value . into ()) , Self :: Feedback (value) => ("feedback" , value . into ()) , Self :: ApprovedBy (value) => ("approvedBy" , value . into ()) , Self :: CreatedAt (value) => ("createdAt" , value . into ()) } ; (k . to_string () , v) } } :: prisma_client_rust :: macros :: select_factory ! (_select_sample , select , prisma :: sample , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "product")] product : product :: Type , # [serde (rename = "productId")] product_id : product_id :: Type , # [serde (rename = "type")] r#type : r#type :: Type , # [serde (rename = "status")] status : status :: Type , # [serde (rename = "notes")] notes : notes :: Type , # [serde (rename = "version")] version : version :: Type , # [serde (rename = "feedback")] feedback : feedback :: Type , # [serde (rename = "approvedBy")] approved_by : approved_by :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type } , [(id , Scalar) , (product , Relation (prisma :: product , One)) , (product_id , Scalar) , (r#type , Scalar) , (status , Scalar) , (notes , Scalar) , (version , Scalar) , (feedback , Scalar) , (approved_by , Scalar) , (created_at , Scalar)]) ; pub enum SelectParam { Id (id :: Select) , Product (product :: Select) , ProductId (product_id :: Select) , Type (r#type :: Select) , Status (status :: Select) , Notes (notes :: Select) , Version (version :: Select) , Feedback (feedback :: Select) , ApprovedBy (approved_by :: Select) , CreatedAt (created_at :: Select) } impl Into < :: prisma_client_rust :: Selection > for SelectParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: Product (data) => data . into () , Self :: ProductId (data) => data . into () , Self :: Type (data) => data . into () , Self :: Status (data) => data . into () , Self :: Notes (data) => data . into () , Self :: Version (data) => data . into () , Self :: Feedback (data) => data . into () , Self :: ApprovedBy (data) => data . into () , Self :: CreatedAt (data) => data . into () } } } :: prisma_client_rust :: macros :: include_factory ! (_include_sample , include , prisma :: sample , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "product")] product : product :: Type , # [serde (rename = "productId")] product_id : product_id :: Type , # [serde (rename = "type")] r#type : r#type :: Type , # [serde (rename = "status")] status : status :: Type , # [serde (rename = "notes")] notes : notes :: Type , # [serde (rename = "version")] version : version :: Type , # [serde (rename = "feedback")] feedback : feedback :: Type , # [serde (rename = "approvedBy")] approved_by : approved_by :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type } , [(product , Relation (prisma :: product , One))]) ; pub enum IncludeParam { Id (id :: Include) , Product (product :: Include) , ProductId (product_id :: Include) , Type (r#type :: Include) , Status (status :: Include) , Notes (notes :: Include) , Version (version :: Include) , Feedback (feedback :: Include) , ApprovedBy (approved_by :: Include) , CreatedAt (created_at :: Include) } impl Into < :: prisma_client_rust :: Selection > for IncludeParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: Product (data) => data . into () , Self :: ProductId (data) => data . into () , Self :: Type (data) => data . into () , Self :: Status (data) => data . into () , Self :: Notes (data) => data . into () , Self :: Version (data) => data . into () , Self :: Feedback (data) => data . into () , Self :: ApprovedBy (data) => data . into () , Self :: CreatedAt (data) => data . into () } } } # [derive (Debug , Clone)] pub struct Create { pub product : super :: product :: UniqueWhereParam , pub r#type : String , pub status : String , pub _params : Vec < SetParam > } impl Create { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateQuery < 'a > { client . sample () . create (self . product , self . r#type , self . status , self . _params) } pub fn to_params (mut self) -> Vec < SetParam > { self . _params . extend ([product :: connect (self . product) , r#type :: set (self . r#type) , status :: set (self . status)]) ; self . _params } } pub fn create (product : super :: product :: UniqueWhereParam , r#type : String , status : String , _params : Vec < SetParam >) -> Create { Create { product , r#type , status , _params } } # [derive (Debug , Clone)] pub struct CreateUnchecked { pub product_id : String , pub r#type : String , pub status : String , pub _params : Vec < UncheckedSetParam > } impl CreateUnchecked { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateUncheckedQuery < 'a > { client . sample () . create_unchecked (self . product_id , self . r#type , self . status , self . _params) } pub fn to_params (mut self) -> Vec < UncheckedSetParam > { self . _params . extend ([product_id :: set (self . product_id) , r#type :: set (self . r#type) , status :: set (self . status)]) ; self . _params } } pub fn create_unchecked (product_id : String , r#type : String , status : String , _params : Vec < UncheckedSetParam >) -> CreateUnchecked { CreateUnchecked { product_id , r#type , status , _params } } # [derive (Debug , Clone)] pub struct Types ; impl :: prisma_client_rust :: ModelTypes for Types { type Data = Data ; type Where = WhereParam ; type WhereUnique = UniqueWhereParam ; type UncheckedSet = UncheckedSetParam ; type Set = SetParam ; type With = WithParam ; type OrderBy = OrderByWithRelationParam ; type Cursor = UniqueWhereParam ; const MODEL : & 'static str = NAME ; fn scalar_selections () -> Vec < :: prisma_client_rust :: Selection > { vec ! [:: prisma_client_rust :: sel (id :: NAME) , :: prisma_client_rust :: sel (product_id :: NAME) , :: prisma_client_rust :: sel (r#type :: NAME) , :: prisma_client_rust :: sel (status :: NAME) , :: prisma_client_rust :: sel (notes :: NAME) , :: prisma_client_rust :: sel (version :: NAME) , :: prisma_client_rust :: sel (feedback :: NAME) , :: prisma_client_rust :: sel (approved_by :: NAME) , :: prisma_client_rust :: sel (created_at :: NAME)] } } # [derive (Debug , Clone , :: serde :: Serialize , :: serde :: Deserialize)] pub struct Data { # [serde (rename = "id")] pub id : id :: Type , # [serde (rename = "product")] pub product : Option < product :: RecursiveSafeType > , # [serde (rename = "productId")] pub product_id : product_id :: Type , # [serde (rename = "type")] pub r#type : r#type :: Type , # [serde (rename = "status")] pub status : status :: Type , # [serde (rename = "notes")] pub notes : notes :: Type , # [serde (rename = "version")] pub version : version :: Type , # [serde (rename = "feedback")] pub feedback : feedback :: Type , # [serde (rename = "approvedBy")] pub approved_by : approved_by :: Type , # [serde (rename = "createdAt")] pub created_at : created_at :: Type } impl Data { pub fn product (& self) -> Result < & super :: product :: Data , :: prisma_client_rust :: RelationNotFetchedError > { self . product . as_ref () . ok_or (:: prisma_client_rust :: RelationNotFetchedError :: new (stringify ! (product))) . map (| v | v . as_ref ()) } } :: prisma_client_rust :: macros :: partial_unchecked_factory ! (_partial_unchecked_sample , prisma :: sample , struct Data { # [serde (rename = "id")] pub id : prisma :: sample :: id :: Type , # [serde (rename = "productId")] pub product_id : prisma :: sample :: product_id :: Type , # [serde (rename = "type")] pub r#type : prisma :: sample :: r#type :: Type , # [serde (rename = "status")] pub status : prisma :: sample :: status :: Type , # [serde (rename = "notes")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub notes : prisma :: sample :: notes :: Type , # [serde (rename = "version")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub version : prisma :: sample :: version :: Type , # [serde (rename = "feedback")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub feedback : prisma :: sample :: feedback :: Type , # [serde (rename = "approvedBy")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub approved_by : prisma :: sample :: approved_by :: Type , # [serde (rename = "createdAt")] pub created_at : prisma :: sample :: created_at :: Type }) ; :: prisma_client_rust :: macros :: filter_factory ! (_sample_filter , prisma :: sample , [(id , Scalar) , (product , Relation (prisma :: product , One)) , (product_id , Scalar) , (r#type , Scalar) , (status , Scalar) , (notes , Scalar) , (version , Scalar) , (feedback , Scalar) , (approved_by , Scalar) , (created_at , Scalar)]) ; pub type UniqueArgs = :: prisma_client_rust :: UniqueArgs < Types > ; pub type ManyArgs = :: prisma_client_rust :: ManyArgs < Types > ; pub type CountQuery < 'a > = :: prisma_client_rust :: Count < 'a , Types > ; pub type CreateQuery < 'a > = :: prisma_client_rust :: Create < 'a , Types > ; pub type CreateUncheckedQuery < 'a > = :: prisma_client_rust :: CreateUnchecked < 'a , Types > ; pub type CreateManyQuery < 'a > = :: prisma_client_rust :: CreateMany < 'a , Types > ; pub type FindUniqueQuery < 'a > = :: prisma_client_rust :: FindUnique < 'a , Types > ; pub type FindManyQuery < 'a > = :: prisma_client_rust :: FindMany < 'a , Types > ; pub type FindFirstQuery < 'a > = :: prisma_client_rust :: FindFirst < 'a , Types > ; pub type UpdateQuery < 'a > = :: prisma_client_rust :: Update < 'a , Types > ; pub type UpdateUncheckedQuery < 'a > = :: prisma_client_rust :: UpdateUnchecked < 'a , Types > ; pub type UpdateManyQuery < 'a > = :: prisma_client_rust :: UpdateMany < 'a , Types > ; pub type UpsertQuery < 'a > = :: prisma_client_rust :: Upsert < 'a , Types > ; pub type DeleteQuery < 'a > = :: prisma_client_rust :: Delete < 'a , Types > ; pub type DeleteManyQuery < 'a > = :: prisma_client_rust :: DeleteMany < 'a , Types > ; # [derive (Clone)] pub struct Actions < 'a > { pub client : & 'a :: prisma_client_rust :: PrismaClientInternals , } impl < 'a > Actions < 'a > { pub fn find_unique (self , _where : UniqueWhereParam) -> FindUniqueQuery < 'a > { FindUniqueQuery :: new (self . client , _where) } pub fn find_first (self , _where : Vec < WhereParam >) -> FindFirstQuery < 'a > { FindFirstQuery :: new (self . client , _where) } pub fn find_many (self , _where : Vec < WhereParam >) -> FindManyQuery < 'a > { FindManyQuery :: new (self . client , _where) } pub fn create (self , product : super :: product :: UniqueWhereParam , r#type : impl Into < String > , status : impl Into < String > , mut _params : Vec < SetParam >) -> CreateQuery < 'a > { let product = product . into () ; let r#type = r#type . into () ; let status = status . into () ; _params . extend ([product :: connect (product) , r#type :: set (r#type) , status :: set (status)]) ; CreateQuery :: new (self . client , _params) } pub fn create_unchecked (self , product_id : impl Into < String > , r#type : impl Into < String > , status : impl Into < String > , mut _params : Vec < UncheckedSetParam >) -> CreateUncheckedQuery < 'a > { let product_id = product_id . into () ; let r#type = r#type . into () ; let status = status . into () ; _params . extend ([product_id :: set (product_id) , r#type :: set (r#type) , status :: set (status)]) ; CreateUncheckedQuery :: new (self . client , _params . into_iter () . map (Into :: into) . collect ()) } pub fn create_many (self , data : Vec < CreateUnchecked >) -> CreateManyQuery < 'a > { let data = data . into_iter () . map (CreateUnchecked :: to_params) . collect () ; CreateManyQuery :: new (self . client , data) } pub fn update (self , _where : UniqueWhereParam , _params : Vec < SetParam >) -> UpdateQuery < 'a > { UpdateQuery :: new (self . client , _where , _params , vec ! []) } pub fn update_unchecked (self , _where : UniqueWhereParam , _params : Vec < UncheckedSetParam >) -> UpdateUncheckedQuery < 'a > { UpdateUncheckedQuery :: new (self . client , _where , _params . into_iter () . map (Into :: into) . collect () , vec ! []) } pub fn update_many (self , _where : Vec < WhereParam > , _params : Vec < SetParam >) -> UpdateManyQuery < 'a > { UpdateManyQuery :: new (self . client , _where , _params ,) } pub fn upsert (self , _where : UniqueWhereParam , _create : Create , _update : Vec < SetParam >) -> UpsertQuery < 'a > { UpsertQuery :: new (self . client , _where , _create . to_params () , _update) } pub fn delete (self , _where : UniqueWhereParam) -> DeleteQuery < 'a > { DeleteQuery :: new (self . client , _where , vec ! []) } pub fn delete_many (self , _where : Vec < WhereParam >) -> DeleteManyQuery < 'a > { DeleteManyQuery :: new (self . client , _where) } pub fn count (self , _where : Vec < WhereParam >) -> CountQuery < 'a > { CountQuery :: new (self . client , _where) } } pub mod _count { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "_count" ; pub struct Order (super :: SortOrder) ; pub fn order < T : From < Order >> (v : super :: SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByRelationAggregateParam { fn from (Order (v) : Order) -> Self { Self :: _Count (v) } } } pub mod approved_by { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "approvedBy" ; pub type Type = Option < String > ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Option < String >) ; pub fn equals < T : From < Equals >> (value : impl Into < Option < String > >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: ApprovedBy (_prisma :: read_filters :: StringNullableFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringNullableFilter , ApprovedBy , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : Option < String >) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: ApprovedBy (v) } } pub struct Set (pub Option < String >) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: ApprovedBy (_prisma :: write_params :: StringNullableParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Option < String > >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringNullableParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ApprovedBy (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: ApprovedBy (_prisma :: write_params :: StringNullableParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ApprovedBy (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: ApprovedBy (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: ApprovedBy (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod created_at { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "createdAt" ; pub type Type = DateTime ; pub type RecursiveSafeType = Type ; pub struct Equals (pub DateTime) ; pub fn equals < T : From < Equals >> (value : impl Into < DateTime >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: CreatedAt (_prisma :: read_filters :: DateTimeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , CreatedAt , { fn in_vec (_ : Vec < DateTime >) -> InVec ; fn not_in_vec (_ : Vec < DateTime >) -> NotInVec ; fn lt (_ : DateTime) -> Lt ; fn lte (_ : DateTime) -> Lte ; fn gt (_ : DateTime) -> Gt ; fn gte (_ : DateTime) -> Gte ; fn not (_ : DateTime) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: CreatedAt (v) } } pub struct Set (pub DateTime) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < DateTime >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: DateTimeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod feedback { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "feedback" ; pub type Type = Option < String > ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Option < String >) ; pub fn equals < T : From < Equals >> (value : impl Into < Option < String > >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Feedback (_prisma :: read_filters :: StringNullableFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringNullableFilter , Feedback , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : Option < String >) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Feedback (v) } } pub struct Set (pub Option < String >) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Feedback (_prisma :: write_params :: StringNullableParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Option < String > >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringNullableParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Feedback (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Feedback (_prisma :: write_params :: StringNullableParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Feedback (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Feedback (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Feedback (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "id" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: IdEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Id (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Id , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Id (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod notes { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "notes" ; pub type Type = Option < String > ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Option < String >) ; pub fn equals < T : From < Equals >> (value : impl Into < Option < String > >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Notes (_prisma :: read_filters :: StringNullableFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringNullableFilter , Notes , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : Option < String >) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Notes (v) } } pub struct Set (pub Option < String >) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Notes (_prisma :: write_params :: StringNullableParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Option < String > >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringNullableParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Notes (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Notes (_prisma :: write_params :: StringNullableParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Notes (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Notes (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Notes (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod product { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "product" ; pub type Type = product :: Data ; pub type RecursiveSafeType = Box < product :: Data > ; pub fn is (value : Vec < product :: WhereParam >) -> WhereParam { WhereParam :: ProductIs (value) } pub fn is_not (value : Vec < product :: WhereParam >) -> WhereParam { WhereParam :: ProductIsNot (value) } pub struct Order (Vec < product :: OrderByWithRelationParam >) ; pub fn order < T : From < Order >> (v : Vec < product :: OrderByWithRelationParam >) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Product (v) } } pub struct Fetch (pub product :: UniqueArgs) ; impl Fetch { pub fn with (mut self , params : impl Into < product :: WithParam >) -> Self { self . 0 = self . 0 . with (params . into ()) ; self } } impl From < Fetch > for WithParam { fn from (Fetch (v) : Fetch) -> Self { WithParam :: Product (v) } } pub fn fetch () -> Fetch { Fetch (product :: UniqueArgs :: new ()) } pub struct Connect (product :: UniqueWhereParam) ; impl From < Connect > for SetParam { fn from (Connect (v) : Connect) -> Self { Self :: ConnectProduct (v) } } pub fn connect < T : From < Connect >> (value : product :: UniqueWhereParam) -> T { Connect (value) . into () } pub enum Select { Select (Vec < product :: SelectParam >) , Include (Vec < product :: IncludeParam >) , Fetch } impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Product (self) } } impl Select { pub fn select (nested_selections : Vec < product :: SelectParam >) -> Self { Self :: Select (nested_selections) } pub fn include (nested_selections : Vec < product :: IncludeParam >) -> Self { Self :: Include (nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (Into :: into) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections } , Self :: Fetch => { < product :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ; :: prisma_client_rust :: Selection :: new ("product" , None , [] , selections) } } pub enum Include { Select (Vec < product :: SelectParam >) , Include (Vec < product :: IncludeParam >) , Fetch } impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Product (self) } } impl Include { pub fn select (nested_selections : Vec < product :: SelectParam >) -> Self { Self :: Select (nested_selections) } pub fn include (nested_selections : Vec < product :: IncludeParam >) -> Self { Self :: Include (nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (Into :: into) . collect () } , Self :: Include (selections) => { let mut nested_selections = < product :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections } , Self :: Fetch => { < product :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ; :: prisma_client_rust :: Selection :: new ("product" , None , [] , selections) } } } pub mod product_id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "productId" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: ProductId (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , ProductId , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: ProductId (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: ProductId (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ProductId (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: ProductId (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ProductId (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: ProductId (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: ProductId (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod status { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "status" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Status (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Status , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Status (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Status (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Status (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Status (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Status (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Status (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Status (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod r#type { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "type" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Type (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Type , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Type (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Type (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Type (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Type (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Type (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Type (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Type (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod version { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "version" ; pub type Type = Option < Int > ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Option < Int >) ; pub fn equals < T : From < Equals >> (value : impl Into < Option < Int > >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Version (_prisma :: read_filters :: IntNullableFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: IntNullableFilter , Version , { fn in_vec (_ : Vec < Int >) -> InVec ; fn not_in_vec (_ : Vec < Int >) -> NotInVec ; fn lt (_ : Int) -> Lt ; fn lte (_ : Int) -> Lte ; fn gt (_ : Int) -> Gt ; fn gte (_ : Int) -> Gte ; fn not (_ : Option < Int >) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Version (v) } } pub struct Set (pub Option < Int >) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Version (_prisma :: write_params :: IntNullableParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Option < Int > >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: IntNullableParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Version (v) } } pub fn increment < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntNullableParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntNullableParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntNullableParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntNullableParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Version (_prisma :: write_params :: IntNullableParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Version (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Version (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Version (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } } pub mod design_file { use super :: { _prisma :: * , * } ; pub const NAME : & str = "DesignFile" ; # [derive (Debug , Clone)] pub enum WhereParam { Not (Vec < WhereParam >) , Or (Vec < WhereParam >) , And (Vec < WhereParam >) , Id (super :: _prisma :: read_filters :: StringFilter) , ProductIs (Vec < super :: product :: WhereParam >) , ProductIsNot (Vec < super :: product :: WhereParam >) , ProductId (super :: _prisma :: read_filters :: StringFilter) , FileName (super :: _prisma :: read_filters :: StringFilter) , FileType (super :: _prisma :: read_filters :: StringNullableFilter) , Url (super :: _prisma :: read_filters :: StringNullableFilter) , Version (super :: _prisma :: read_filters :: IntNullableFilter) , IsLatest (super :: _prisma :: read_filters :: BooleanNullableFilter) , UploadedBy (super :: _prisma :: read_filters :: StringNullableFilter) , UploadedAt (super :: _prisma :: read_filters :: DateTimeFilter) } impl :: prisma_client_rust :: WhereInput for WhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (| p | :: prisma_client_rust :: PrismaValue :: Object (vec ! [p . into ()])) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Id (value) => (id :: NAME , value . into ()) , Self :: ProductIs (where_params) => (product :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("is" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: ProductIsNot (where_params) => (product :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("isNot" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: ProductId (value) => (product_id :: NAME , value . into ()) , Self :: FileName (value) => (file_name :: NAME , value . into ()) , Self :: FileType (value) => (file_type :: NAME , value . into ()) , Self :: Url (value) => (url :: NAME , value . into ()) , Self :: Version (value) => (version :: NAME , value . into ()) , Self :: IsLatest (value) => (is_latest :: NAME , value . into ()) , Self :: UploadedBy (value) => (uploaded_by :: NAME , value . into ()) , Self :: UploadedAt (value) => (uploaded_at :: NAME , value . into ()) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } # [derive (Debug , Clone)] pub enum UniqueWhereParam { IdEquals (String) } impl :: prisma_client_rust :: WhereInput for UniqueWhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { UniqueWhereParam :: IdEquals (value) => ("id" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: String (value))) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } impl From < :: prisma_client_rust :: Operator < Self >> for WhereParam { fn from (op : :: prisma_client_rust :: Operator < Self >) -> Self { match op { :: prisma_client_rust :: Operator :: Not (value) => Self :: Not (value) , :: prisma_client_rust :: Operator :: And (value) => Self :: And (value) , :: prisma_client_rust :: Operator :: Or (value) => Self :: Or (value) , } } } # [derive (Debug , Clone)] pub enum OrderByWithRelationParam { Id (super :: SortOrder) , ProductId (super :: SortOrder) , FileName (super :: SortOrder) , FileType (super :: SortOrder) , Url (super :: SortOrder) , Version (super :: SortOrder) , IsLatest (super :: SortOrder) , UploadedBy (super :: SortOrder) , UploadedAt (super :: SortOrder) , Product (Vec < super :: product :: OrderByWithRelationParam >) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByWithRelationParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (param) => ("id" , param . into ()) , Self :: ProductId (param) => ("productId" , param . into ()) , Self :: FileName (param) => ("fileName" , param . into ()) , Self :: FileType (param) => ("fileType" , param . into ()) , Self :: Url (param) => ("url" , param . into ()) , Self :: Version (param) => ("version" , param . into ()) , Self :: IsLatest (param) => ("isLatest" , param . into ()) , Self :: UploadedBy (param) => ("uploadedBy" , param . into ()) , Self :: UploadedAt (param) => ("uploadedAt" , param . into ()) , Self :: Product (param) => ("product" , :: prisma_client_rust :: PrismaValue :: Object (param . into_iter () . map (Into :: into) . collect ())) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum OrderByRelationAggregateParam { _Count (super :: SortOrder) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByRelationAggregateParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: _Count (param) => ("_count" , param . into ()) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum WithParam { Product (super :: product :: UniqueArgs) } impl Into < :: prisma_client_rust :: Selection > for WithParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Product (args) => { let mut selections = < super :: product :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; selections . extend (args . with_params . into_iter () . map (Into :: < :: prisma_client_rust :: Selection > :: into)) ; :: prisma_client_rust :: Selection :: new (product :: NAME , None , [] , selections) } } } } # [derive (Debug , Clone)] pub enum SetParam { Id (super :: _prisma :: write_params :: StringParam) , ConnectProduct (super :: product :: UniqueWhereParam) , ProductId (super :: _prisma :: write_params :: StringParam) , FileName (super :: _prisma :: write_params :: StringParam) , FileType (super :: _prisma :: write_params :: StringNullableParam) , Url (super :: _prisma :: write_params :: StringNullableParam) , Version (super :: _prisma :: write_params :: IntNullableParam) , IsLatest (super :: _prisma :: write_params :: BooleanNullableParam) , UploadedBy (super :: _prisma :: write_params :: StringNullableParam) , UploadedAt (super :: _prisma :: write_params :: DateTimeParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for SetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => (id :: NAME , value . into ()) , Self :: ConnectProduct (where_param) => (product :: NAME , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: Object ([where_param] . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()))])) , Self :: ProductId (value) => (product_id :: NAME , value . into ()) , Self :: FileName (value) => (file_name :: NAME , value . into ()) , Self :: FileType (value) => (file_type :: NAME , value . into ()) , Self :: Url (value) => (url :: NAME , value . into ()) , Self :: Version (value) => (version :: NAME , value . into ()) , Self :: IsLatest (value) => (is_latest :: NAME , value . into ()) , Self :: UploadedBy (value) => (uploaded_by :: NAME , value . into ()) , Self :: UploadedAt (value) => (uploaded_at :: NAME , value . into ()) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum UncheckedSetParam { Id (super :: _prisma :: write_params :: StringParam) , ProductId (super :: _prisma :: write_params :: StringParam) , FileName (super :: _prisma :: write_params :: StringParam) , FileType (super :: _prisma :: write_params :: StringNullableParam) , Url (super :: _prisma :: write_params :: StringNullableParam) , Version (super :: _prisma :: write_params :: IntNullableParam) , IsLatest (super :: _prisma :: write_params :: BooleanNullableParam) , UploadedBy (super :: _prisma :: write_params :: StringNullableParam) , UploadedAt (super :: _prisma :: write_params :: DateTimeParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for UncheckedSetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => ("id" , value . into ()) , Self :: ProductId (value) => ("productId" , value . into ()) , Self :: FileName (value) => ("fileName" , value . into ()) , Self :: FileType (value) => ("fileType" , value . into ()) , Self :: Url (value) => ("url" , value . into ()) , Self :: Version (value) => ("version" , value . into ()) , Self :: IsLatest (value) => ("isLatest" , value . into ()) , Self :: UploadedBy (value) => ("uploadedBy" , value . into ()) , Self :: UploadedAt (value) => ("uploadedAt" , value . into ()) } ; (k . to_string () , v) } } :: prisma_client_rust :: macros :: select_factory ! (_select_design_file , select , prisma :: design_file , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "product")] product : product :: Type , # [serde (rename = "productId")] product_id : product_id :: Type , # [serde (rename = "fileName")] file_name : file_name :: Type , # [serde (rename = "fileType")] file_type : file_type :: Type , # [serde (rename = "url")] url : url :: Type , # [serde (rename = "version")] version : version :: Type , # [serde (rename = "isLatest")] is_latest : is_latest :: Type , # [serde (rename = "uploadedBy")] uploaded_by : uploaded_by :: Type , # [serde (rename = "uploadedAt")] uploaded_at : uploaded_at :: Type } , [(id , Scalar) , (product , Relation (prisma :: product , One)) , (product_id , Scalar) , (file_name , Scalar) , (file_type , Scalar) , (url , Scalar) , (version , Scalar) , (is_latest , Scalar) , (uploaded_by , Scalar) , (uploaded_at , Scalar)]) ; pub enum SelectParam { Id (id :: Select) , Product (product :: Select) , ProductId (product_id :: Select) , FileName (file_name :: Select) , FileType (file_type :: Select) , Url (url :: Select) , Version (version :: Select) , IsLatest (is_latest :: Select) , UploadedBy (uploaded_by :: Select) , UploadedAt (uploaded_at :: Select) } impl Into < :: prisma_client_rust :: Selection > for SelectParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: Product (data) => data . into () , Self :: ProductId (data) => data . into () , Self :: FileName (data) => data . into () , Self :: FileType (data) => data . into () , Self :: Url (data) => data . into () , Self :: Version (data) => data . into () , Self :: IsLatest (data) => data . into () , Self :: UploadedBy (data) => data . into () , Self :: UploadedAt (data) => data . into () } } } :: prisma_client_rust :: macros :: include_factory ! (_include_design_file , include , prisma :: design_file , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "product")] product : product :: Type , # [serde (rename = "productId")] product_id : product_id :: Type , # [serde (rename = "fileName")] file_name : file_name :: Type , # [serde (rename = "fileType")] file_type : file_type :: Type , # [serde (rename = "url")] url : url :: Type , # [serde (rename = "version")] version : version :: Type , # [serde (rename = "isLatest")] is_latest : is_latest :: Type , # [serde (rename = "uploadedBy")] uploaded_by : uploaded_by :: Type , # [serde (rename = "uploadedAt")] uploaded_at : uploaded_at :: Type } , [(product , Relation (prisma :: product , One))]) ; pub enum IncludeParam { Id (id :: Include) , Product (product :: Include) , ProductId (product_id :: Include) , FileName (file_name :: Include) , FileType (file_type :: Include) , Url (url :: Include) , Version (version :: Include) , IsLatest (is_latest :: Include) , UploadedBy (uploaded_by :: Include) , UploadedAt (uploaded_at :: Include) } impl Into < :: prisma_client_rust :: Selection > for IncludeParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: Product (data) => data . into () , Self :: ProductId (data) => data . into () , Self :: FileName (data) => data . into () , Self :: FileType (data) => data . into () , Self :: Url (data) => data . into () , Self :: Version (data) => data . into () , Self :: IsLatest (data) => data . into () , Self :: UploadedBy (data) => data . into () , Self :: UploadedAt (data) => data . into () } } } # [derive (Debug , Clone)] pub struct Create { pub product : super :: product :: UniqueWhereParam , pub file_name : String , pub _params : Vec < SetParam > } impl Create { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateQuery < 'a > { client . design_file () . create (self . product , self . file_name , self . _params) } pub fn to_params (mut self) -> Vec < SetParam > { self . _params . extend ([product :: connect (self . product) , file_name :: set (self . file_name)]) ; self . _params } } pub fn create (product : super :: product :: UniqueWhereParam , file_name : String , _params : Vec < SetParam >) -> Create { Create { product , file_name , _params } } # [derive (Debug , Clone)] pub struct CreateUnchecked { pub product_id : String , pub file_name : String , pub _params : Vec < UncheckedSetParam > } impl CreateUnchecked { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateUncheckedQuery < 'a > { client . design_file () . create_unchecked (self . product_id , self . file_name , self . _params) } pub fn to_params (mut self) -> Vec < UncheckedSetParam > { self . _params . extend ([product_id :: set (self . product_id) , file_name :: set (self . file_name)]) ; self . _params } } pub fn create_unchecked (product_id : String , file_name : String , _params : Vec < UncheckedSetParam >) -> CreateUnchecked { CreateUnchecked { product_id , file_name , _params } } # [derive (Debug , Clone)] pub struct Types ; impl :: prisma_client_rust :: ModelTypes for Types { type Data = Data ; type Where = WhereParam ; type WhereUnique = UniqueWhereParam ; type UncheckedSet = UncheckedSetParam ; type Set = SetParam ; type With = WithParam ; type OrderBy = OrderByWithRelationParam ; type Cursor = UniqueWhereParam ; const MODEL : & 'static str = NAME ; fn scalar_selections () -> Vec < :: prisma_client_rust :: Selection > { vec ! [:: prisma_client_rust :: sel (id :: NAME) , :: prisma_client_rust :: sel (product_id :: NAME) , :: prisma_client_rust :: sel (file_name :: NAME) , :: prisma_client_rust :: sel (file_type :: NAME) , :: prisma_client_rust :: sel (url :: NAME) , :: prisma_client_rust :: sel (version :: NAME) , :: prisma_client_rust :: sel (is_latest :: NAME) , :: prisma_client_rust :: sel (uploaded_by :: NAME) , :: prisma_client_rust :: sel (uploaded_at :: NAME)] } } # [derive (Debug , Clone , :: serde :: Serialize , :: serde :: Deserialize)] pub struct Data { # [serde (rename = "id")] pub id : id :: Type , # [serde (rename = "product")] pub product : Option < product :: RecursiveSafeType > , # [serde (rename = "productId")] pub product_id : product_id :: Type , # [serde (rename = "fileName")] pub file_name : file_name :: Type , # [serde (rename = "fileType")] pub file_type : file_type :: Type , # [serde (rename = "url")] pub url : url :: Type , # [serde (rename = "version")] pub version : version :: Type , # [serde (rename = "isLatest")] pub is_latest : is_latest :: Type , # [serde (rename = "uploadedBy")] pub uploaded_by : uploaded_by :: Type , # [serde (rename = "uploadedAt")] pub uploaded_at : uploaded_at :: Type } impl Data { pub fn product (& self) -> Result < & super :: product :: Data , :: prisma_client_rust :: RelationNotFetchedError > { self . product . as_ref () . ok_or (:: prisma_client_rust :: RelationNotFetchedError :: new (stringify ! (product))) . map (| v | v . as_ref ()) } } :: prisma_client_rust :: macros :: partial_unchecked_factory ! (_partial_unchecked_design_file , prisma :: design_file , struct Data { # [serde (rename = "id")] pub id : prisma :: design_file :: id :: Type , # [serde (rename = "productId")] pub product_id : prisma :: design_file :: product_id :: Type , # [serde (rename = "fileName")] pub file_name : prisma :: design_file :: file_name :: Type , # [serde (rename = "fileType")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub file_type : prisma :: design_file :: file_type :: Type , # [serde (rename = "url")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub url : prisma :: design_file :: url :: Type , # [serde (rename = "version")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub version : prisma :: design_file :: version :: Type , # [serde (rename = "isLatest")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub is_latest : prisma :: design_file :: is_latest :: Type , # [serde (rename = "uploadedBy")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub uploaded_by : prisma :: design_file :: uploaded_by :: Type , # [serde (rename = "uploadedAt")] pub uploaded_at : prisma :: design_file :: uploaded_at :: Type }) ; :: prisma_client_rust :: macros :: filter_factory ! (_design_file_filter , prisma :: design_file , [(id , Scalar) , (product , Relation (prisma :: product , One)) , (product_id , Scalar) , (file_name , Scalar) , (file_type , Scalar) , (url , Scalar) , (version , Scalar) , (is_latest , Scalar) , (uploaded_by , Scalar) , (uploaded_at , Scalar)]) ; pub type UniqueArgs = :: prisma_client_rust :: UniqueArgs < Types > ; pub type ManyArgs = :: prisma_client_rust :: ManyArgs < Types > ; pub type CountQuery < 'a > = :: prisma_client_rust :: Count < 'a , Types > ; pub type CreateQuery < 'a > = :: prisma_client_rust :: Create < 'a , Types > ; pub type CreateUncheckedQuery < 'a > = :: prisma_client_rust :: CreateUnchecked < 'a , Types > ; pub type CreateManyQuery < 'a > = :: prisma_client_rust :: CreateMany < 'a , Types > ; pub type FindUniqueQuery < 'a > = :: prisma_client_rust :: FindUnique < 'a , Types > ; pub type FindManyQuery < 'a > = :: prisma_client_rust :: FindMany < 'a , Types > ; pub type FindFirstQuery < 'a > = :: prisma_client_rust :: FindFirst < 'a , Types > ; pub type UpdateQuery < 'a > = :: prisma_client_rust :: Update < 'a , Types > ; pub type UpdateUncheckedQuery < 'a > = :: prisma_client_rust :: UpdateUnchecked < 'a , Types > ; pub type UpdateManyQuery < 'a > = :: prisma_client_rust :: UpdateMany < 'a , Types > ; pub type UpsertQuery < 'a > = :: prisma_client_rust :: Upsert < 'a , Types > ; pub type DeleteQuery < 'a > = :: prisma_client_rust :: Delete < 'a , Types > ; pub type DeleteManyQuery < 'a > = :: prisma_client_rust :: DeleteMany < 'a , Types > ; # [derive (Clone)] pub struct Actions < 'a > { pub client : & 'a :: prisma_client_rust :: PrismaClientInternals , } impl < 'a > Actions < 'a > { pub fn find_unique (self , _where : UniqueWhereParam) -> FindUniqueQuery < 'a > { FindUniqueQuery :: new (self . client , _where) } pub fn find_first (self , _where : Vec < WhereParam >) -> FindFirstQuery < 'a > { FindFirstQuery :: new (self . client , _where) } pub fn find_many (self , _where : Vec < WhereParam >) -> FindManyQuery < 'a > { FindManyQuery :: new (self . client , _where) } pub fn create (self , product : super :: product :: UniqueWhereParam , file_name : impl Into < String > , mut _params : Vec < SetParam >) -> CreateQuery < 'a > { let product = product . into () ; let file_name = file_name . into () ; _params . extend ([product :: connect (product) , file_name :: set (file_name)]) ; CreateQuery :: new (self . client , _params) } pub fn create_unchecked (self , product_id : impl Into < String > , file_name : impl Into < String > , mut _params : Vec < UncheckedSetParam >) -> CreateUncheckedQuery < 'a > { let product_id = product_id . into () ; let file_name = file_name . into () ; _params . extend ([product_id :: set (product_id) , file_name :: set (file_name)]) ; CreateUncheckedQuery :: new (self . client , _params . into_iter () . map (Into :: into) . collect ()) } pub fn create_many (self , data : Vec < CreateUnchecked >) -> CreateManyQuery < 'a > { let data = data . into_iter () . map (CreateUnchecked :: to_params) . collect () ; CreateManyQuery :: new (self . client , data) } pub fn update (self , _where : UniqueWhereParam , _params : Vec < SetParam >) -> UpdateQuery < 'a > { UpdateQuery :: new (self . client , _where , _params , vec ! []) } pub fn update_unchecked (self , _where : UniqueWhereParam , _params : Vec < UncheckedSetParam >) -> UpdateUncheckedQuery < 'a > { UpdateUncheckedQuery :: new (self . client , _where , _params . into_iter () . map (Into :: into) . collect () , vec ! []) } pub fn update_many (self , _where : Vec < WhereParam > , _params : Vec < SetParam >) -> UpdateManyQuery < 'a > { UpdateManyQuery :: new (self . client , _where , _params ,) } pub fn upsert (self , _where : UniqueWhereParam , _create : Create , _update : Vec < SetParam >) -> UpsertQuery < 'a > { UpsertQuery :: new (self . client , _where , _create . to_params () , _update) } pub fn delete (self , _where : UniqueWhereParam) -> DeleteQuery < 'a > { DeleteQuery :: new (self . client , _where , vec ! []) } pub fn delete_many (self , _where : Vec < WhereParam >) -> DeleteManyQuery < 'a > { DeleteManyQuery :: new (self . client , _where) } pub fn count (self , _where : Vec < WhereParam >) -> CountQuery < 'a > { CountQuery :: new (self . client , _where) } } pub mod _count { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "_count" ; pub struct Order (super :: SortOrder) ; pub fn order < T : From < Order >> (v : super :: SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByRelationAggregateParam { fn from (Order (v) : Order) -> Self { Self :: _Count (v) } } } pub mod file_name { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "fileName" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: FileName (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , FileName , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: FileName (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: FileName (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: FileName (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: FileName (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: FileName (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: FileName (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: FileName (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod file_type { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "fileType" ; pub type Type = Option < String > ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Option < String >) ; pub fn equals < T : From < Equals >> (value : impl Into < Option < String > >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: FileType (_prisma :: read_filters :: StringNullableFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringNullableFilter , FileType , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : Option < String >) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: FileType (v) } } pub struct Set (pub Option < String >) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: FileType (_prisma :: write_params :: StringNullableParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Option < String > >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringNullableParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: FileType (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: FileType (_prisma :: write_params :: StringNullableParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: FileType (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: FileType (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: FileType (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "id" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: IdEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Id (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Id , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Id (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod is_latest { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "isLatest" ; pub type Type = Option < Boolean > ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Option < Boolean >) ; pub fn equals < T : From < Equals >> (value : impl Into < Option < Boolean > >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: IsLatest (_prisma :: read_filters :: BooleanNullableFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: BooleanNullableFilter , IsLatest , { fn not (_ : Option < Boolean >) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: IsLatest (v) } } pub struct Set (pub Option < Boolean >) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: IsLatest (_prisma :: write_params :: BooleanNullableParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Option < Boolean > >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: BooleanNullableParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: IsLatest (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: IsLatest (_prisma :: write_params :: BooleanNullableParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: IsLatest (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: IsLatest (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: IsLatest (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod product { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "product" ; pub type Type = product :: Data ; pub type RecursiveSafeType = Box < product :: Data > ; pub fn is (value : Vec < product :: WhereParam >) -> WhereParam { WhereParam :: ProductIs (value) } pub fn is_not (value : Vec < product :: WhereParam >) -> WhereParam { WhereParam :: ProductIsNot (value) } pub struct Order (Vec < product :: OrderByWithRelationParam >) ; pub fn order < T : From < Order >> (v : Vec < product :: OrderByWithRelationParam >) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Product (v) } } pub struct Fetch (pub product :: UniqueArgs) ; impl Fetch { pub fn with (mut self , params : impl Into < product :: WithParam >) -> Self { self . 0 = self . 0 . with (params . into ()) ; self } } impl From < Fetch > for WithParam { fn from (Fetch (v) : Fetch) -> Self { WithParam :: Product (v) } } pub fn fetch () -> Fetch { Fetch (product :: UniqueArgs :: new ()) } pub struct Connect (product :: UniqueWhereParam) ; impl From < Connect > for SetParam { fn from (Connect (v) : Connect) -> Self { Self :: ConnectProduct (v) } } pub fn connect < T : From < Connect >> (value : product :: UniqueWhereParam) -> T { Connect (value) . into () } pub enum Select { Select (Vec < product :: SelectParam >) , Include (Vec < product :: IncludeParam >) , Fetch } impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Product (self) } } impl Select { pub fn select (nested_selections : Vec < product :: SelectParam >) -> Self { Self :: Select (nested_selections) } pub fn include (nested_selections : Vec < product :: IncludeParam >) -> Self { Self :: Include (nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (Into :: into) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections } , Self :: Fetch => { < product :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ; :: prisma_client_rust :: Selection :: new ("product" , None , [] , selections) } } pub enum Include { Select (Vec < product :: SelectParam >) , Include (Vec < product :: IncludeParam >) , Fetch } impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Product (self) } } impl Include { pub fn select (nested_selections : Vec < product :: SelectParam >) -> Self { Self :: Select (nested_selections) } pub fn include (nested_selections : Vec < product :: IncludeParam >) -> Self { Self :: Include (nested_selections) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (Into :: into) . collect () } , Self :: Include (selections) => { let mut nested_selections = < product :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections } , Self :: Fetch => { < product :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ; :: prisma_client_rust :: Selection :: new ("product" , None , [] , selections) } } } pub mod product_id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "productId" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: ProductId (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , ProductId , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: ProductId (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: ProductId (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ProductId (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: ProductId (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ProductId (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: ProductId (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: ProductId (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod uploaded_at { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "uploadedAt" ; pub type Type = DateTime ; pub type RecursiveSafeType = Type ; pub struct Equals (pub DateTime) ; pub fn equals < T : From < Equals >> (value : impl Into < DateTime >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: UploadedAt (_prisma :: read_filters :: DateTimeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , UploadedAt , { fn in_vec (_ : Vec < DateTime >) -> InVec ; fn not_in_vec (_ : Vec < DateTime >) -> NotInVec ; fn lt (_ : DateTime) -> Lt ; fn lte (_ : DateTime) -> Lte ; fn gt (_ : DateTime) -> Gt ; fn gte (_ : DateTime) -> Gte ; fn not (_ : DateTime) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: UploadedAt (v) } } pub struct Set (pub DateTime) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: UploadedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < DateTime >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: DateTimeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: UploadedAt (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: UploadedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: UploadedAt (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: UploadedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: UploadedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod uploaded_by { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "uploadedBy" ; pub type Type = Option < String > ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Option < String >) ; pub fn equals < T : From < Equals >> (value : impl Into < Option < String > >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: UploadedBy (_prisma :: read_filters :: StringNullableFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringNullableFilter , UploadedBy , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : Option < String >) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: UploadedBy (v) } } pub struct Set (pub Option < String >) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: UploadedBy (_prisma :: write_params :: StringNullableParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Option < String > >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringNullableParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: UploadedBy (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: UploadedBy (_prisma :: write_params :: StringNullableParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: UploadedBy (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: UploadedBy (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: UploadedBy (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod url { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "url" ; pub type Type = Option < String > ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Option < String >) ; pub fn equals < T : From < Equals >> (value : impl Into < Option < String > >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Url (_prisma :: read_filters :: StringNullableFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringNullableFilter , Url , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : Option < String >) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Url (v) } } pub struct Set (pub Option < String >) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Url (_prisma :: write_params :: StringNullableParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Option < String > >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringNullableParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Url (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Url (_prisma :: write_params :: StringNullableParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Url (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Url (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Url (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod version { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "version" ; pub type Type = Option < Int > ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Option < Int >) ; pub fn equals < T : From < Equals >> (value : impl Into < Option < Int > >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Version (_prisma :: read_filters :: IntNullableFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: IntNullableFilter , Version , { fn in_vec (_ : Vec < Int >) -> InVec ; fn not_in_vec (_ : Vec < Int >) -> NotInVec ; fn lt (_ : Int) -> Lt ; fn lte (_ : Int) -> Lte ; fn gt (_ : Int) -> Gt ; fn gte (_ : Int) -> Gte ; fn not (_ : Option < Int >) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Version (v) } } pub struct Set (pub Option < Int >) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Version (_prisma :: write_params :: IntNullableParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Option < Int > >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: IntNullableParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Version (v) } } pub fn increment < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntNullableParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntNullableParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntNullableParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntNullableParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Version (_prisma :: write_params :: IntNullableParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Version (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Version (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Version (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } } pub mod costing_sheet { use super :: { _prisma :: * , * } ; pub const NAME : & str = "CostingSheet" ; # [derive (Debug , Clone)] pub enum WhereParam { Not (Vec < WhereParam >) , Or (Vec < WhereParam >) , And (Vec < WhereParam >) , Id (super :: _prisma :: read_filters :: StringFilter) , Name (super :: _prisma :: read_filters :: StringFilter) , ProfitMargin (super :: _prisma :: read_filters :: FloatFilter) , SelectedCurrency (super :: _prisma :: read_filters :: StringFilter) , CostBreakdown (super :: _prisma :: read_filters :: StringFilter) , TaxConfig (super :: _prisma :: read_filters :: StringFilter) , CreatedAt (super :: _prisma :: read_filters :: DateTimeFilter) , UpdatedAt (super :: _prisma :: read_filters :: DateTimeFilter) } impl :: prisma_client_rust :: WhereInput for WhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (| p | :: prisma_client_rust :: PrismaValue :: Object (vec ! [p . into ()])) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Id (value) => (id :: NAME , value . into ()) , Self :: Name (value) => (name :: NAME , value . into ()) , Self :: ProfitMargin (value) => (profit_margin :: NAME , value . into ()) , Self :: SelectedCurrency (value) => (selected_currency :: NAME , value . into ()) , Self :: CostBreakdown (value) => (cost_breakdown :: NAME , value . into ()) , Self :: TaxConfig (value) => (tax_config :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) , Self :: UpdatedAt (value) => (updated_at :: NAME , value . into ()) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } # [derive (Debug , Clone)] pub enum UniqueWhereParam { IdEquals (String) } impl :: prisma_client_rust :: WhereInput for UniqueWhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { UniqueWhereParam :: IdEquals (value) => ("id" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: String (value))) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } impl From < :: prisma_client_rust :: Operator < Self >> for WhereParam { fn from (op : :: prisma_client_rust :: Operator < Self >) -> Self { match op { :: prisma_client_rust :: Operator :: Not (value) => Self :: Not (value) , :: prisma_client_rust :: Operator :: And (value) => Self :: And (value) , :: prisma_client_rust :: Operator :: Or (value) => Self :: Or (value) , } } } # [derive (Debug , Clone)] pub enum OrderByWithRelationParam { Id (super :: SortOrder) , Name (super :: SortOrder) , ProfitMargin (super :: SortOrder) , SelectedCurrency (super :: SortOrder) , CostBreakdown (super :: SortOrder) , TaxConfig (super :: SortOrder) , CreatedAt (super :: SortOrder) , UpdatedAt (super :: SortOrder) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByWithRelationParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (param) => ("id" , param . into ()) , Self :: Name (param) => ("name" , param . into ()) , Self :: ProfitMargin (param) => ("profitMargin" , param . into ()) , Self :: SelectedCurrency (param) => ("selectedCurrency" , param . into ()) , Self :: CostBreakdown (param) => ("costBreakdown" , param . into ()) , Self :: TaxConfig (param) => ("taxConfig" , param . into ()) , Self :: CreatedAt (param) => ("createdAt" , param . into ()) , Self :: UpdatedAt (param) => ("updatedAt" , param . into ()) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum WithParam { } impl Into < :: prisma_client_rust :: Selection > for WithParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { } } } # [derive (Debug , Clone)] pub enum SetParam { Id (super :: _prisma :: write_params :: StringParam) , Name (super :: _prisma :: write_params :: StringParam) , ProfitMargin (super :: _prisma :: write_params :: FloatParam) , SelectedCurrency (super :: _prisma :: write_params :: StringParam) , CostBreakdown (super :: _prisma :: write_params :: StringParam) , TaxConfig (super :: _prisma :: write_params :: StringParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) , UpdatedAt (super :: _prisma :: write_params :: DateTimeParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for SetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => (id :: NAME , value . into ()) , Self :: Name (value) => (name :: NAME , value . into ()) , Self :: ProfitMargin (value) => (profit_margin :: NAME , value . into ()) , Self :: SelectedCurrency (value) => (selected_currency :: NAME , value . into ()) , Self :: CostBreakdown (value) => (cost_breakdown :: NAME , value . into ()) , Self :: TaxConfig (value) => (tax_config :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) , Self :: UpdatedAt (value) => (updated_at :: NAME , value . into ()) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum UncheckedSetParam { Id (super :: _prisma :: write_params :: StringParam) , Name (super :: _prisma :: write_params :: StringParam) , ProfitMargin (super :: _prisma :: write_params :: FloatParam) , SelectedCurrency (super :: _prisma :: write_params :: StringParam) , CostBreakdown (super :: _prisma :: write_params :: StringParam) , TaxConfig (super :: _prisma :: write_params :: StringParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) , UpdatedAt (super :: _prisma :: write_params :: DateTimeParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for UncheckedSetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => ("id" , value . into ()) , Self :: Name (value) => ("name" , value . into ()) , Self :: ProfitMargin (value) => ("profitMargin" , value . into ()) , Self :: SelectedCurrency (value) => ("selectedCurrency" , value . into ()) , Self :: CostBreakdown (value) => ("costBreakdown" , value . into ()) , Self :: TaxConfig (value) => ("taxConfig" , value . into ()) , Self :: CreatedAt (value) => ("createdAt" , value . into ()) , Self :: UpdatedAt (value) => ("updatedAt" , value . into ()) } ; (k . to_string () , v) } } :: prisma_client_rust :: macros :: select_factory ! (_select_costing_sheet , select , prisma :: costing_sheet , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "name")] name : name :: Type , # [serde (rename = "profitMargin")] profit_margin : profit_margin :: Type , # [serde (rename = "selectedCurrency")] selected_currency : selected_currency :: Type , # [serde (rename = "costBreakdown")] cost_breakdown : cost_breakdown :: Type , # [serde (rename = "taxConfig")] tax_config : tax_config :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type , # [serde (rename = "updatedAt")] updated_at : updated_at :: Type } , [(id , Scalar) , (name , Scalar) , (profit_margin , Scalar) , (selected_currency , Scalar) , (cost_breakdown , Scalar) , (tax_config , Scalar) , (created_at , Scalar) , (updated_at , Scalar)]) ; pub enum SelectParam { Id (id :: Select) , Name (name :: Select) , ProfitMargin (profit_margin :: Select) , SelectedCurrency (selected_currency :: Select) , CostBreakdown (cost_breakdown :: Select) , TaxConfig (tax_config :: Select) , CreatedAt (created_at :: Select) , UpdatedAt (updated_at :: Select) } impl Into < :: prisma_client_rust :: Selection > for SelectParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: Name (data) => data . into () , Self :: ProfitMargin (data) => data . into () , Self :: SelectedCurrency (data) => data . into () , Self :: CostBreakdown (data) => data . into () , Self :: TaxConfig (data) => data . into () , Self :: CreatedAt (data) => data . into () , Self :: UpdatedAt (data) => data . into () } } } :: prisma_client_rust :: macros :: include_factory ! (_include_costing_sheet , include , prisma :: costing_sheet , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "name")] name : name :: Type , # [serde (rename = "profitMargin")] profit_margin : profit_margin :: Type , # [serde (rename = "selectedCurrency")] selected_currency : selected_currency :: Type , # [serde (rename = "costBreakdown")] cost_breakdown : cost_breakdown :: Type , # [serde (rename = "taxConfig")] tax_config : tax_config :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type , # [serde (rename = "updatedAt")] updated_at : updated_at :: Type } , []) ; pub enum IncludeParam { Id (id :: Include) , Name (name :: Include) , ProfitMargin (profit_margin :: Include) , SelectedCurrency (selected_currency :: Include) , CostBreakdown (cost_breakdown :: Include) , TaxConfig (tax_config :: Include) , CreatedAt (created_at :: Include) , UpdatedAt (updated_at :: Include) } impl Into < :: prisma_client_rust :: Selection > for IncludeParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: Name (data) => data . into () , Self :: ProfitMargin (data) => data . into () , Self :: SelectedCurrency (data) => data . into () , Self :: CostBreakdown (data) => data . into () , Self :: TaxConfig (data) => data . into () , Self :: CreatedAt (data) => data . into () , Self :: UpdatedAt (data) => data . into () } } } # [derive (Debug , Clone)] pub struct Create { pub name : String , pub profit_margin : Float , pub selected_currency : String , pub cost_breakdown : String , pub tax_config : String , pub _params : Vec < SetParam > } impl Create { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateQuery < 'a > { client . costing_sheet () . create (self . name , self . profit_margin , self . selected_currency , self . cost_breakdown , self . tax_config , self . _params) } pub fn to_params (mut self) -> Vec < SetParam > { self . _params . extend ([name :: set (self . name) , profit_margin :: set (self . profit_margin) , selected_currency :: set (self . selected_currency) , cost_breakdown :: set (self . cost_breakdown) , tax_config :: set (self . tax_config)]) ; self . _params } } pub fn create (name : String , profit_margin : Float , selected_currency : String , cost_breakdown : String , tax_config : String , _params : Vec < SetParam >) -> Create { Create { name , profit_margin , selected_currency , cost_breakdown , tax_config , _params } } # [derive (Debug , Clone)] pub struct CreateUnchecked { pub name : String , pub profit_margin : Float , pub selected_currency : String , pub cost_breakdown : String , pub tax_config : String , pub _params : Vec < UncheckedSetParam > } impl CreateUnchecked { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateUncheckedQuery < 'a > { client . costing_sheet () . create_unchecked (self . name , self . profit_margin , self . selected_currency , self . cost_breakdown , self . tax_config , self . _params) } pub fn to_params (mut self) -> Vec < UncheckedSetParam > { self . _params . extend ([name :: set (self . name) , profit_margin :: set (self . profit_margin) , selected_currency :: set (self . selected_currency) , cost_breakdown :: set (self . cost_breakdown) , tax_config :: set (self . tax_config)]) ; self . _params } } pub fn create_unchecked (name : String , profit_margin : Float , selected_currency : String , cost_breakdown : String , tax_config : String , _params : Vec < UncheckedSetParam >) -> CreateUnchecked { CreateUnchecked { name , profit_margin , selected_currency , cost_breakdown , tax_config , _params } } # [derive (Debug , Clone)] pub struct Types ; impl :: prisma_client_rust :: ModelTypes for Types { type Data = Data ; type Where = WhereParam ; type WhereUnique = UniqueWhereParam ; type UncheckedSet = UncheckedSetParam ; type Set = SetParam ; type With = WithParam ; type OrderBy = OrderByWithRelationParam ; type Cursor = UniqueWhereParam ; const MODEL : & 'static str = NAME ; fn scalar_selections () -> Vec < :: prisma_client_rust :: Selection > { vec ! [:: prisma_client_rust :: sel (id :: NAME) , :: prisma_client_rust :: sel (name :: NAME) , :: prisma_client_rust :: sel (profit_margin :: NAME) , :: prisma_client_rust :: sel (selected_currency :: NAME) , :: prisma_client_rust :: sel (cost_breakdown :: NAME) , :: prisma_client_rust :: sel (tax_config :: NAME) , :: prisma_client_rust :: sel (created_at :: NAME) , :: prisma_client_rust :: sel (updated_at :: NAME)] } } # [derive (Debug , Clone , :: serde :: Serialize , :: serde :: Deserialize)] pub struct Data { # [serde (rename = "id")] pub id : id :: Type , # [serde (rename = "name")] pub name : name :: Type , # [serde (rename = "profitMargin")] pub profit_margin : profit_margin :: Type , # [serde (rename = "selectedCurrency")] pub selected_currency : selected_currency :: Type , # [serde (rename = "costBreakdown")] pub cost_breakdown : cost_breakdown :: Type , # [serde (rename = "taxConfig")] pub tax_config : tax_config :: Type , # [serde (rename = "createdAt")] pub created_at : created_at :: Type , # [serde (rename = "updatedAt")] pub updated_at : updated_at :: Type } impl Data { } :: prisma_client_rust :: macros :: partial_unchecked_factory ! (_partial_unchecked_costing_sheet , prisma :: costing_sheet , struct Data { # [serde (rename = "id")] pub id : prisma :: costing_sheet :: id :: Type , # [serde (rename = "name")] pub name : prisma :: costing_sheet :: name :: Type , # [serde (rename = "profitMargin")] pub profit_margin : prisma :: costing_sheet :: profit_margin :: Type , # [serde (rename = "selectedCurrency")] pub selected_currency : prisma :: costing_sheet :: selected_currency :: Type , # [serde (rename = "costBreakdown")] pub cost_breakdown : prisma :: costing_sheet :: cost_breakdown :: Type , # [serde (rename = "taxConfig")] pub tax_config : prisma :: costing_sheet :: tax_config :: Type , # [serde (rename = "createdAt")] pub created_at : prisma :: costing_sheet :: created_at :: Type , # [serde (rename = "updatedAt")] pub updated_at : prisma :: costing_sheet :: updated_at :: Type }) ; :: prisma_client_rust :: macros :: filter_factory ! (_costing_sheet_filter , prisma :: costing_sheet , [(id , Scalar) , (name , Scalar) , (profit_margin , Scalar) , (selected_currency , Scalar) , (cost_breakdown , Scalar) , (tax_config , Scalar) , (created_at , Scalar) , (updated_at , Scalar)]) ; pub type UniqueArgs = :: prisma_client_rust :: UniqueArgs < Types > ; pub type ManyArgs = :: prisma_client_rust :: ManyArgs < Types > ; pub type CountQuery < 'a > = :: prisma_client_rust :: Count < 'a , Types > ; pub type CreateQuery < 'a > = :: prisma_client_rust :: Create < 'a , Types > ; pub type CreateUncheckedQuery < 'a > = :: prisma_client_rust :: CreateUnchecked < 'a , Types > ; pub type CreateManyQuery < 'a > = :: prisma_client_rust :: CreateMany < 'a , Types > ; pub type FindUniqueQuery < 'a > = :: prisma_client_rust :: FindUnique < 'a , Types > ; pub type FindManyQuery < 'a > = :: prisma_client_rust :: FindMany < 'a , Types > ; pub type FindFirstQuery < 'a > = :: prisma_client_rust :: FindFirst < 'a , Types > ; pub type UpdateQuery < 'a > = :: prisma_client_rust :: Update < 'a , Types > ; pub type UpdateUncheckedQuery < 'a > = :: prisma_client_rust :: UpdateUnchecked < 'a , Types > ; pub type UpdateManyQuery < 'a > = :: prisma_client_rust :: UpdateMany < 'a , Types > ; pub type UpsertQuery < 'a > = :: prisma_client_rust :: Upsert < 'a , Types > ; pub type DeleteQuery < 'a > = :: prisma_client_rust :: Delete < 'a , Types > ; pub type DeleteManyQuery < 'a > = :: prisma_client_rust :: DeleteMany < 'a , Types > ; # [derive (Clone)] pub struct Actions < 'a > { pub client : & 'a :: prisma_client_rust :: PrismaClientInternals , } impl < 'a > Actions < 'a > { pub fn find_unique (self , _where : UniqueWhereParam) -> FindUniqueQuery < 'a > { FindUniqueQuery :: new (self . client , _where) } pub fn find_first (self , _where : Vec < WhereParam >) -> FindFirstQuery < 'a > { FindFirstQuery :: new (self . client , _where) } pub fn find_many (self , _where : Vec < WhereParam >) -> FindManyQuery < 'a > { FindManyQuery :: new (self . client , _where) } pub fn create (self , name : impl Into < String > , profit_margin : impl Into < Float > , selected_currency : impl Into < String > , cost_breakdown : impl Into < String > , tax_config : impl Into < String > , mut _params : Vec < SetParam >) -> CreateQuery < 'a > { let name = name . into () ; let profit_margin = profit_margin . into () ; let selected_currency = selected_currency . into () ; let cost_breakdown = cost_breakdown . into () ; let tax_config = tax_config . into () ; _params . extend ([name :: set (name) , profit_margin :: set (profit_margin) , selected_currency :: set (selected_currency) , cost_breakdown :: set (cost_breakdown) , tax_config :: set (tax_config)]) ; CreateQuery :: new (self . client , _params) } pub fn create_unchecked (self , name : impl Into < String > , profit_margin : impl Into < Float > , selected_currency : impl Into < String > , cost_breakdown : impl Into < String > , tax_config : impl Into < String > , mut _params : Vec < UncheckedSetParam >) -> CreateUncheckedQuery < 'a > { let name = name . into () ; let profit_margin = profit_margin . into () ; let selected_currency = selected_currency . into () ; let cost_breakdown = cost_breakdown . into () ; let tax_config = tax_config . into () ; _params . extend ([name :: set (name) , profit_margin :: set (profit_margin) , selected_currency :: set (selected_currency) , cost_breakdown :: set (cost_breakdown) , tax_config :: set (tax_config)]) ; CreateUncheckedQuery :: new (self . client , _params . into_iter () . map (Into :: into) . collect ()) } pub fn create_many (self , data : Vec < CreateUnchecked >) -> CreateManyQuery < 'a > { let data = data . into_iter () . map (CreateUnchecked :: to_params) . collect () ; CreateManyQuery :: new (self . client , data) } pub fn update (self , _where : UniqueWhereParam , _params : Vec < SetParam >) -> UpdateQuery < 'a > { UpdateQuery :: new (self . client , _where , _params , vec ! []) } pub fn update_unchecked (self , _where : UniqueWhereParam , _params : Vec < UncheckedSetParam >) -> UpdateUncheckedQuery < 'a > { UpdateUncheckedQuery :: new (self . client , _where , _params . into_iter () . map (Into :: into) . collect () , vec ! []) } pub fn update_many (self , _where : Vec < WhereParam > , _params : Vec < SetParam >) -> UpdateManyQuery < 'a > { UpdateManyQuery :: new (self . client , _where , _params ,) } pub fn upsert (self , _where : UniqueWhereParam , _create : Create , _update : Vec < SetParam >) -> UpsertQuery < 'a > { UpsertQuery :: new (self . client , _where , _create . to_params () , _update) } pub fn delete (self , _where : UniqueWhereParam) -> DeleteQuery < 'a > { DeleteQuery :: new (self . client , _where , vec ! []) } pub fn delete_many (self , _where : Vec < WhereParam >) -> DeleteManyQuery < 'a > { DeleteManyQuery :: new (self . client , _where) } pub fn count (self , _where : Vec < WhereParam >) -> CountQuery < 'a > { CountQuery :: new (self . client , _where) } } pub mod cost_breakdown { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "costBreakdown" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: CostBreakdown (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , CostBreakdown , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: CostBreakdown (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: CostBreakdown (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CostBreakdown (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: CostBreakdown (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CostBreakdown (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: CostBreakdown (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: CostBreakdown (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod created_at { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "createdAt" ; pub type Type = DateTime ; pub type RecursiveSafeType = Type ; pub struct Equals (pub DateTime) ; pub fn equals < T : From < Equals >> (value : impl Into < DateTime >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: CreatedAt (_prisma :: read_filters :: DateTimeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , CreatedAt , { fn in_vec (_ : Vec < DateTime >) -> InVec ; fn not_in_vec (_ : Vec < DateTime >) -> NotInVec ; fn lt (_ : DateTime) -> Lt ; fn lte (_ : DateTime) -> Lte ; fn gt (_ : DateTime) -> Gt ; fn gte (_ : DateTime) -> Gte ; fn not (_ : DateTime) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: CreatedAt (v) } } pub struct Set (pub DateTime) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < DateTime >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: DateTimeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "id" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: IdEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Id (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Id , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Id (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod name { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "name" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Name (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Name , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Name (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Name (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Name (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Name (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Name (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Name (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Name (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod profit_margin { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "profitMargin" ; pub type Type = Float ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Float) ; pub fn equals < T : From < Equals >> (value : impl Into < Float >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: ProfitMargin (_prisma :: read_filters :: FloatFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: FloatFilter , ProfitMargin , { fn in_vec (_ : Vec < Float >) -> InVec ; fn not_in_vec (_ : Vec < Float >) -> NotInVec ; fn lt (_ : Float) -> Lt ; fn lte (_ : Float) -> Lte ; fn gt (_ : Float) -> Gt ; fn gte (_ : Float) -> Gte ; fn not (_ : Float) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: ProfitMargin (v) } } pub struct Set (pub Float) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: ProfitMargin (_prisma :: write_params :: FloatParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Float >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: FloatParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ProfitMargin (v) } } pub fn increment < T : From < UpdateOperation >> (value : Float) -> T { UpdateOperation (_prisma :: write_params :: FloatParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : Float) -> T { UpdateOperation (_prisma :: write_params :: FloatParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : Float) -> T { UpdateOperation (_prisma :: write_params :: FloatParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : Float) -> T { UpdateOperation (_prisma :: write_params :: FloatParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: ProfitMargin (_prisma :: write_params :: FloatParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ProfitMargin (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: ProfitMargin (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: ProfitMargin (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod selected_currency { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "selectedCurrency" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: SelectedCurrency (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , SelectedCurrency , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: SelectedCurrency (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: SelectedCurrency (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: SelectedCurrency (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: SelectedCurrency (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: SelectedCurrency (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: SelectedCurrency (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: SelectedCurrency (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod tax_config { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "taxConfig" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: TaxConfig (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , TaxConfig , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: TaxConfig (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: TaxConfig (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: TaxConfig (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: TaxConfig (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: TaxConfig (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: TaxConfig (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: TaxConfig (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod updated_at { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "updatedAt" ; pub type Type = DateTime ; pub type RecursiveSafeType = Type ; pub struct Equals (pub DateTime) ; pub fn equals < T : From < Equals >> (value : impl Into < DateTime >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: UpdatedAt (_prisma :: read_filters :: DateTimeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , UpdatedAt , { fn in_vec (_ : Vec < DateTime >) -> InVec ; fn not_in_vec (_ : Vec < DateTime >) -> NotInVec ; fn lt (_ : DateTime) -> Lt ; fn lte (_ : DateTime) -> Lte ; fn gt (_ : DateTime) -> Gt ; fn gte (_ : DateTime) -> Gte ; fn not (_ : DateTime) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: UpdatedAt (v) } } pub struct Set (pub DateTime) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: UpdatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < DateTime >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: DateTimeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: UpdatedAt (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: UpdatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: UpdatedAt (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: UpdatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: UpdatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } } pub mod production_plan { use super :: { _prisma :: * , * } ; pub const NAME : & str = "ProductionPlan" ; # [derive (Debug , Clone)] pub enum WhereParam { Not (Vec < WhereParam >) , Or (Vec < WhereParam >) , And (Vec < WhereParam >) , Id (super :: _prisma :: read_filters :: StringFilter) , ProductName (super :: _prisma :: read_filters :: StringFilter) , Quantity (super :: _prisma :: read_filters :: IntFilter) , StartDate (super :: _prisma :: read_filters :: DateTimeFilter) , EndDate (super :: _prisma :: read_filters :: DateTimeFilter) , Status (super :: _prisma :: read_filters :: StringFilter) , Progress (super :: _prisma :: read_filters :: IntFilter) , AssignedWorkers (super :: _prisma :: read_filters :: IntFilter) , EstimatedHours (super :: _prisma :: read_filters :: IntFilter) , ActualHours (super :: _prisma :: read_filters :: IntFilter) , Priority (super :: _prisma :: read_filters :: StringFilter) , CreatedAt (super :: _prisma :: read_filters :: DateTimeFilter) , UpdatedAt (super :: _prisma :: read_filters :: DateTimeFilter) } impl :: prisma_client_rust :: WhereInput for WhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (| p | :: prisma_client_rust :: PrismaValue :: Object (vec ! [p . into ()])) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Id (value) => (id :: NAME , value . into ()) , Self :: ProductName (value) => (product_name :: NAME , value . into ()) , Self :: Quantity (value) => (quantity :: NAME , value . into ()) , Self :: StartDate (value) => (start_date :: NAME , value . into ()) , Self :: EndDate (value) => (end_date :: NAME , value . into ()) , Self :: Status (value) => (status :: NAME , value . into ()) , Self :: Progress (value) => (progress :: NAME , value . into ()) , Self :: AssignedWorkers (value) => (assigned_workers :: NAME , value . into ()) , Self :: EstimatedHours (value) => (estimated_hours :: NAME , value . into ()) , Self :: ActualHours (value) => (actual_hours :: NAME , value . into ()) , Self :: Priority (value) => (priority :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) , Self :: UpdatedAt (value) => (updated_at :: NAME , value . into ()) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } # [derive (Debug , Clone)] pub enum UniqueWhereParam { IdEquals (String) } impl :: prisma_client_rust :: WhereInput for UniqueWhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { UniqueWhereParam :: IdEquals (value) => ("id" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: String (value))) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } impl From < :: prisma_client_rust :: Operator < Self >> for WhereParam { fn from (op : :: prisma_client_rust :: Operator < Self >) -> Self { match op { :: prisma_client_rust :: Operator :: Not (value) => Self :: Not (value) , :: prisma_client_rust :: Operator :: And (value) => Self :: And (value) , :: prisma_client_rust :: Operator :: Or (value) => Self :: Or (value) , } } } # [derive (Debug , Clone)] pub enum OrderByWithRelationParam { Id (super :: SortOrder) , ProductName (super :: SortOrder) , Quantity (super :: SortOrder) , StartDate (super :: SortOrder) , EndDate (super :: SortOrder) , Status (super :: SortOrder) , Progress (super :: SortOrder) , AssignedWorkers (super :: SortOrder) , EstimatedHours (super :: SortOrder) , ActualHours (super :: SortOrder) , Priority (super :: SortOrder) , CreatedAt (super :: SortOrder) , UpdatedAt (super :: SortOrder) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByWithRelationParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (param) => ("id" , param . into ()) , Self :: ProductName (param) => ("productName" , param . into ()) , Self :: Quantity (param) => ("quantity" , param . into ()) , Self :: StartDate (param) => ("startDate" , param . into ()) , Self :: EndDate (param) => ("endDate" , param . into ()) , Self :: Status (param) => ("status" , param . into ()) , Self :: Progress (param) => ("progress" , param . into ()) , Self :: AssignedWorkers (param) => ("assignedWorkers" , param . into ()) , Self :: EstimatedHours (param) => ("estimatedHours" , param . into ()) , Self :: ActualHours (param) => ("actualHours" , param . into ()) , Self :: Priority (param) => ("priority" , param . into ()) , Self :: CreatedAt (param) => ("createdAt" , param . into ()) , Self :: UpdatedAt (param) => ("updatedAt" , param . into ()) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum WithParam { } impl Into < :: prisma_client_rust :: Selection > for WithParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { } } } # [derive (Debug , Clone)] pub enum SetParam { Id (super :: _prisma :: write_params :: StringParam) , ProductName (super :: _prisma :: write_params :: StringParam) , Quantity (super :: _prisma :: write_params :: IntParam) , StartDate (super :: _prisma :: write_params :: DateTimeParam) , EndDate (super :: _prisma :: write_params :: DateTimeParam) , Status (super :: _prisma :: write_params :: StringParam) , Progress (super :: _prisma :: write_params :: IntParam) , AssignedWorkers (super :: _prisma :: write_params :: IntParam) , EstimatedHours (super :: _prisma :: write_params :: IntParam) , ActualHours (super :: _prisma :: write_params :: IntParam) , Priority (super :: _prisma :: write_params :: StringParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) , UpdatedAt (super :: _prisma :: write_params :: DateTimeParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for SetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => (id :: NAME , value . into ()) , Self :: ProductName (value) => (product_name :: NAME , value . into ()) , Self :: Quantity (value) => (quantity :: NAME , value . into ()) , Self :: StartDate (value) => (start_date :: NAME , value . into ()) , Self :: EndDate (value) => (end_date :: NAME , value . into ()) , Self :: Status (value) => (status :: NAME , value . into ()) , Self :: Progress (value) => (progress :: NAME , value . into ()) , Self :: AssignedWorkers (value) => (assigned_workers :: NAME , value . into ()) , Self :: EstimatedHours (value) => (estimated_hours :: NAME , value . into ()) , Self :: ActualHours (value) => (actual_hours :: NAME , value . into ()) , Self :: Priority (value) => (priority :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) , Self :: UpdatedAt (value) => (updated_at :: NAME , value . into ()) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum UncheckedSetParam { Id (super :: _prisma :: write_params :: StringParam) , ProductName (super :: _prisma :: write_params :: StringParam) , Quantity (super :: _prisma :: write_params :: IntParam) , StartDate (super :: _prisma :: write_params :: DateTimeParam) , EndDate (super :: _prisma :: write_params :: DateTimeParam) , Status (super :: _prisma :: write_params :: StringParam) , Progress (super :: _prisma :: write_params :: IntParam) , AssignedWorkers (super :: _prisma :: write_params :: IntParam) , EstimatedHours (super :: _prisma :: write_params :: IntParam) , ActualHours (super :: _prisma :: write_params :: IntParam) , Priority (super :: _prisma :: write_params :: StringParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) , UpdatedAt (super :: _prisma :: write_params :: DateTimeParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for UncheckedSetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => ("id" , value . into ()) , Self :: ProductName (value) => ("productName" , value . into ()) , Self :: Quantity (value) => ("quantity" , value . into ()) , Self :: StartDate (value) => ("startDate" , value . into ()) , Self :: EndDate (value) => ("endDate" , value . into ()) , Self :: Status (value) => ("status" , value . into ()) , Self :: Progress (value) => ("progress" , value . into ()) , Self :: AssignedWorkers (value) => ("assignedWorkers" , value . into ()) , Self :: EstimatedHours (value) => ("estimatedHours" , value . into ()) , Self :: ActualHours (value) => ("actualHours" , value . into ()) , Self :: Priority (value) => ("priority" , value . into ()) , Self :: CreatedAt (value) => ("createdAt" , value . into ()) , Self :: UpdatedAt (value) => ("updatedAt" , value . into ()) } ; (k . to_string () , v) } } :: prisma_client_rust :: macros :: select_factory ! (_select_production_plan , select , prisma :: production_plan , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "productName")] product_name : product_name :: Type , # [serde (rename = "quantity")] quantity : quantity :: Type , # [serde (rename = "startDate")] start_date : start_date :: Type , # [serde (rename = "endDate")] end_date : end_date :: Type , # [serde (rename = "status")] status : status :: Type , # [serde (rename = "progress")] progress : progress :: Type , # [serde (rename = "assignedWorkers")] assigned_workers : assigned_workers :: Type , # [serde (rename = "estimatedHours")] estimated_hours : estimated_hours :: Type , # [serde (rename = "actualHours")] actual_hours : actual_hours :: Type , # [serde (rename = "priority")] priority : priority :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type , # [serde (rename = "updatedAt")] updated_at : updated_at :: Type } , [(id , Scalar) , (product_name , Scalar) , (quantity , Scalar) , (start_date , Scalar) , (end_date , Scalar) , (status , Scalar) , (progress , Scalar) , (assigned_workers , Scalar) , (estimated_hours , Scalar) , (actual_hours , Scalar) , (priority , Scalar) , (created_at , Scalar) , (updated_at , Scalar)]) ; pub enum SelectParam { Id (id :: Select) , ProductName (product_name :: Select) , Quantity (quantity :: Select) , StartDate (start_date :: Select) , EndDate (end_date :: Select) , Status (status :: Select) , Progress (progress :: Select) , AssignedWorkers (assigned_workers :: Select) , EstimatedHours (estimated_hours :: Select) , ActualHours (actual_hours :: Select) , Priority (priority :: Select) , CreatedAt (created_at :: Select) , UpdatedAt (updated_at :: Select) } impl Into < :: prisma_client_rust :: Selection > for SelectParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: ProductName (data) => data . into () , Self :: Quantity (data) => data . into () , Self :: StartDate (data) => data . into () , Self :: EndDate (data) => data . into () , Self :: Status (data) => data . into () , Self :: Progress (data) => data . into () , Self :: AssignedWorkers (data) => data . into () , Self :: EstimatedHours (data) => data . into () , Self :: ActualHours (data) => data . into () , Self :: Priority (data) => data . into () , Self :: CreatedAt (data) => data . into () , Self :: UpdatedAt (data) => data . into () } } } :: prisma_client_rust :: macros :: include_factory ! (_include_production_plan , include , prisma :: production_plan , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "productName")] product_name : product_name :: Type , # [serde (rename = "quantity")] quantity : quantity :: Type , # [serde (rename = "startDate")] start_date : start_date :: Type , # [serde (rename = "endDate")] end_date : end_date :: Type , # [serde (rename = "status")] status : status :: Type , # [serde (rename = "progress")] progress : progress :: Type , # [serde (rename = "assignedWorkers")] assigned_workers : assigned_workers :: Type , # [serde (rename = "estimatedHours")] estimated_hours : estimated_hours :: Type , # [serde (rename = "actualHours")] actual_hours : actual_hours :: Type , # [serde (rename = "priority")] priority : priority :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type , # [serde (rename = "updatedAt")] updated_at : updated_at :: Type } , []) ; pub enum IncludeParam { Id (id :: Include) , ProductName (product_name :: Include) , Quantity (quantity :: Include) , StartDate (start_date :: Include) , EndDate (end_date :: Include) , Status (status :: Include) , Progress (progress :: Include) , AssignedWorkers (assigned_workers :: Include) , EstimatedHours (estimated_hours :: Include) , ActualHours (actual_hours :: Include) , Priority (priority :: Include) , CreatedAt (created_at :: Include) , UpdatedAt (updated_at :: Include) } impl Into < :: prisma_client_rust :: Selection > for IncludeParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: ProductName (data) => data . into () , Self :: Quantity (data) => data . into () , Self :: StartDate (data) => data . into () , Self :: EndDate (data) => data . into () , Self :: Status (data) => data . into () , Self :: Progress (data) => data . into () , Self :: AssignedWorkers (data) => data . into () , Self :: EstimatedHours (data) => data . into () , Self :: ActualHours (data) => data . into () , Self :: Priority (data) => data . into () , Self :: CreatedAt (data) => data . into () , Self :: UpdatedAt (data) => data . into () } } } # [derive (Debug , Clone)] pub struct Create { pub product_name : String , pub quantity : Int , pub start_date : DateTime , pub end_date : DateTime , pub status : String , pub priority : String , pub _params : Vec < SetParam > } impl Create { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateQuery < 'a > { client . production_plan () . create (self . product_name , self . quantity , self . start_date , self . end_date , self . status , self . priority , self . _params) } pub fn to_params (mut self) -> Vec < SetParam > { self . _params . extend ([product_name :: set (self . product_name) , quantity :: set (self . quantity) , start_date :: set (self . start_date) , end_date :: set (self . end_date) , status :: set (self . status) , priority :: set (self . priority)]) ; self . _params } } pub fn create (product_name : String , quantity : Int , start_date : DateTime , end_date : DateTime , status : String , priority : String , _params : Vec < SetParam >) -> Create { Create { product_name , quantity , start_date , end_date , status , priority , _params } } # [derive (Debug , Clone)] pub struct CreateUnchecked { pub product_name : String , pub quantity : Int , pub start_date : DateTime , pub end_date : DateTime , pub status : String , pub priority : String , pub _params : Vec < UncheckedSetParam > } impl CreateUnchecked { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateUncheckedQuery < 'a > { client . production_plan () . create_unchecked (self . product_name , self . quantity , self . start_date , self . end_date , self . status , self . priority , self . _params) } pub fn to_params (mut self) -> Vec < UncheckedSetParam > { self . _params . extend ([product_name :: set (self . product_name) , quantity :: set (self . quantity) , start_date :: set (self . start_date) , end_date :: set (self . end_date) , status :: set (self . status) , priority :: set (self . priority)]) ; self . _params } } pub fn create_unchecked (product_name : String , quantity : Int , start_date : DateTime , end_date : DateTime , status : String , priority : String , _params : Vec < UncheckedSetParam >) -> CreateUnchecked { CreateUnchecked { product_name , quantity , start_date , end_date , status , priority , _params } } # [derive (Debug , Clone)] pub struct Types ; impl :: prisma_client_rust :: ModelTypes for Types { type Data = Data ; type Where = WhereParam ; type WhereUnique = UniqueWhereParam ; type UncheckedSet = UncheckedSetParam ; type Set = SetParam ; type With = WithParam ; type OrderBy = OrderByWithRelationParam ; type Cursor = UniqueWhereParam ; const MODEL : & 'static str = NAME ; fn scalar_selections () -> Vec < :: prisma_client_rust :: Selection > { vec ! [:: prisma_client_rust :: sel (id :: NAME) , :: prisma_client_rust :: sel (product_name :: NAME) , :: prisma_client_rust :: sel (quantity :: NAME) , :: prisma_client_rust :: sel (start_date :: NAME) , :: prisma_client_rust :: sel (end_date :: NAME) , :: prisma_client_rust :: sel (status :: NAME) , :: prisma_client_rust :: sel (progress :: NAME) , :: prisma_client_rust :: sel (assigned_workers :: NAME) , :: prisma_client_rust :: sel (estimated_hours :: NAME) , :: prisma_client_rust :: sel (actual_hours :: NAME) , :: prisma_client_rust :: sel (priority :: NAME) , :: prisma_client_rust :: sel (created_at :: NAME) , :: prisma_client_rust :: sel (updated_at :: NAME)] } } # [derive (Debug , Clone , :: serde :: Serialize , :: serde :: Deserialize)] pub struct Data { # [serde (rename = "id")] pub id : id :: Type , # [serde (rename = "productName")] pub product_name : product_name :: Type , # [serde (rename = "quantity")] pub quantity : quantity :: Type , # [serde (rename = "startDate")] pub start_date : start_date :: Type , # [serde (rename = "endDate")] pub end_date : end_date :: Type , # [serde (rename = "status")] pub status : status :: Type , # [serde (rename = "progress")] pub progress : progress :: Type , # [serde (rename = "assignedWorkers")] pub assigned_workers : assigned_workers :: Type , # [serde (rename = "estimatedHours")] pub estimated_hours : estimated_hours :: Type , # [serde (rename = "actualHours")] pub actual_hours : actual_hours :: Type , # [serde (rename = "priority")] pub priority : priority :: Type , # [serde (rename = "createdAt")] pub created_at : created_at :: Type , # [serde (rename = "updatedAt")] pub updated_at : updated_at :: Type } impl Data { } :: prisma_client_rust :: macros :: partial_unchecked_factory ! (_partial_unchecked_production_plan , prisma :: production_plan , struct Data { # [serde (rename = "id")] pub id : prisma :: production_plan :: id :: Type , # [serde (rename = "productName")] pub product_name : prisma :: production_plan :: product_name :: Type , # [serde (rename = "quantity")] pub quantity : prisma :: production_plan :: quantity :: Type , # [serde (rename = "startDate")] pub start_date : prisma :: production_plan :: start_date :: Type , # [serde (rename = "endDate")] pub end_date : prisma :: production_plan :: end_date :: Type , # [serde (rename = "status")] pub status : prisma :: production_plan :: status :: Type , # [serde (rename = "progress")] pub progress : prisma :: production_plan :: progress :: Type , # [serde (rename = "assignedWorkers")] pub assigned_workers : prisma :: production_plan :: assigned_workers :: Type , # [serde (rename = "estimatedHours")] pub estimated_hours : prisma :: production_plan :: estimated_hours :: Type , # [serde (rename = "actualHours")] pub actual_hours : prisma :: production_plan :: actual_hours :: Type , # [serde (rename = "priority")] pub priority : prisma :: production_plan :: priority :: Type , # [serde (rename = "createdAt")] pub created_at : prisma :: production_plan :: created_at :: Type , # [serde (rename = "updatedAt")] pub updated_at : prisma :: production_plan :: updated_at :: Type }) ; :: prisma_client_rust :: macros :: filter_factory ! (_production_plan_filter , prisma :: production_plan , [(id , Scalar) , (product_name , Scalar) , (quantity , Scalar) , (start_date , Scalar) , (end_date , Scalar) , (status , Scalar) , (progress , Scalar) , (assigned_workers , Scalar) , (estimated_hours , Scalar) , (actual_hours , Scalar) , (priority , Scalar) , (created_at , Scalar) , (updated_at , Scalar)]) ; pub type UniqueArgs = :: prisma_client_rust :: UniqueArgs < Types > ; pub type ManyArgs = :: prisma_client_rust :: ManyArgs < Types > ; pub type CountQuery < 'a > = :: prisma_client_rust :: Count < 'a , Types > ; pub type CreateQuery < 'a > = :: prisma_client_rust :: Create < 'a , Types > ; pub type CreateUncheckedQuery < 'a > = :: prisma_client_rust :: CreateUnchecked < 'a , Types > ; pub type CreateManyQuery < 'a > = :: prisma_client_rust :: CreateMany < 'a , Types > ; pub type FindUniqueQuery < 'a > = :: prisma_client_rust :: FindUnique < 'a , Types > ; pub type FindManyQuery < 'a > = :: prisma_client_rust :: FindMany < 'a , Types > ; pub type FindFirstQuery < 'a > = :: prisma_client_rust :: FindFirst < 'a , Types > ; pub type UpdateQuery < 'a > = :: prisma_client_rust :: Update < 'a , Types > ; pub type UpdateUncheckedQuery < 'a > = :: prisma_client_rust :: UpdateUnchecked < 'a , Types > ; pub type UpdateManyQuery < 'a > = :: prisma_client_rust :: UpdateMany < 'a , Types > ; pub type UpsertQuery < 'a > = :: prisma_client_rust :: Upsert < 'a , Types > ; pub type DeleteQuery < 'a > = :: prisma_client_rust :: Delete < 'a , Types > ; pub type DeleteManyQuery < 'a > = :: prisma_client_rust :: DeleteMany < 'a , Types > ; # [derive (Clone)] pub struct Actions < 'a > { pub client : & 'a :: prisma_client_rust :: PrismaClientInternals , } impl < 'a > Actions < 'a > { pub fn find_unique (self , _where : UniqueWhereParam) -> FindUniqueQuery < 'a > { FindUniqueQuery :: new (self . client , _where) } pub fn find_first (self , _where : Vec < WhereParam >) -> FindFirstQuery < 'a > { FindFirstQuery :: new (self . client , _where) } pub fn find_many (self , _where : Vec < WhereParam >) -> FindManyQuery < 'a > { FindManyQuery :: new (self . client , _where) } pub fn create (self , product_name : impl Into < String > , quantity : impl Into < Int > , start_date : impl Into < DateTime > , end_date : impl Into < DateTime > , status : impl Into < String > , priority : impl Into < String > , mut _params : Vec < SetParam >) -> CreateQuery < 'a > { let product_name = product_name . into () ; let quantity = quantity . into () ; let start_date = start_date . into () ; let end_date = end_date . into () ; let status = status . into () ; let priority = priority . into () ; _params . extend ([product_name :: set (product_name) , quantity :: set (quantity) , start_date :: set (start_date) , end_date :: set (end_date) , status :: set (status) , priority :: set (priority)]) ; CreateQuery :: new (self . client , _params) } pub fn create_unchecked (self , product_name : impl Into < String > , quantity : impl Into < Int > , start_date : impl Into < DateTime > , end_date : impl Into < DateTime > , status : impl Into < String > , priority : impl Into < String > , mut _params : Vec < UncheckedSetParam >) -> CreateUncheckedQuery < 'a > { let product_name = product_name . into () ; let quantity = quantity . into () ; let start_date = start_date . into () ; let end_date = end_date . into () ; let status = status . into () ; let priority = priority . into () ; _params . extend ([product_name :: set (product_name) , quantity :: set (quantity) , start_date :: set (start_date) , end_date :: set (end_date) , status :: set (status) , priority :: set (priority)]) ; CreateUncheckedQuery :: new (self . client , _params . into_iter () . map (Into :: into) . collect ()) } pub fn create_many (self , data : Vec < CreateUnchecked >) -> CreateManyQuery < 'a > { let data = data . into_iter () . map (CreateUnchecked :: to_params) . collect () ; CreateManyQuery :: new (self . client , data) } pub fn update (self , _where : UniqueWhereParam , _params : Vec < SetParam >) -> UpdateQuery < 'a > { UpdateQuery :: new (self . client , _where , _params , vec ! []) } pub fn update_unchecked (self , _where : UniqueWhereParam , _params : Vec < UncheckedSetParam >) -> UpdateUncheckedQuery < 'a > { UpdateUncheckedQuery :: new (self . client , _where , _params . into_iter () . map (Into :: into) . collect () , vec ! []) } pub fn update_many (self , _where : Vec < WhereParam > , _params : Vec < SetParam >) -> UpdateManyQuery < 'a > { UpdateManyQuery :: new (self . client , _where , _params ,) } pub fn upsert (self , _where : UniqueWhereParam , _create : Create , _update : Vec < SetParam >) -> UpsertQuery < 'a > { UpsertQuery :: new (self . client , _where , _create . to_params () , _update) } pub fn delete (self , _where : UniqueWhereParam) -> DeleteQuery < 'a > { DeleteQuery :: new (self . client , _where , vec ! []) } pub fn delete_many (self , _where : Vec < WhereParam >) -> DeleteManyQuery < 'a > { DeleteManyQuery :: new (self . client , _where) } pub fn count (self , _where : Vec < WhereParam >) -> CountQuery < 'a > { CountQuery :: new (self . client , _where) } } pub mod actual_hours { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "actualHours" ; pub type Type = Int ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Int) ; pub fn equals < T : From < Equals >> (value : impl Into < Int >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: ActualHours (_prisma :: read_filters :: IntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: IntFilter , ActualHours , { fn in_vec (_ : Vec < Int >) -> InVec ; fn not_in_vec (_ : Vec < Int >) -> NotInVec ; fn lt (_ : Int) -> Lt ; fn lte (_ : Int) -> Lte ; fn gt (_ : Int) -> Gt ; fn gte (_ : Int) -> Gte ; fn not (_ : Int) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: ActualHours (v) } } pub struct Set (pub Int) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: ActualHours (_prisma :: write_params :: IntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Int >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: IntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ActualHours (v) } } pub fn increment < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: ActualHours (_prisma :: write_params :: IntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ActualHours (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: ActualHours (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: ActualHours (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod assigned_workers { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "assignedWorkers" ; pub type Type = Int ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Int) ; pub fn equals < T : From < Equals >> (value : impl Into < Int >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: AssignedWorkers (_prisma :: read_filters :: IntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: IntFilter , AssignedWorkers , { fn in_vec (_ : Vec < Int >) -> InVec ; fn not_in_vec (_ : Vec < Int >) -> NotInVec ; fn lt (_ : Int) -> Lt ; fn lte (_ : Int) -> Lte ; fn gt (_ : Int) -> Gt ; fn gte (_ : Int) -> Gte ; fn not (_ : Int) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: AssignedWorkers (v) } } pub struct Set (pub Int) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: AssignedWorkers (_prisma :: write_params :: IntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Int >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: IntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: AssignedWorkers (v) } } pub fn increment < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: AssignedWorkers (_prisma :: write_params :: IntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: AssignedWorkers (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: AssignedWorkers (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: AssignedWorkers (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod created_at { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "createdAt" ; pub type Type = DateTime ; pub type RecursiveSafeType = Type ; pub struct Equals (pub DateTime) ; pub fn equals < T : From < Equals >> (value : impl Into < DateTime >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: CreatedAt (_prisma :: read_filters :: DateTimeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , CreatedAt , { fn in_vec (_ : Vec < DateTime >) -> InVec ; fn not_in_vec (_ : Vec < DateTime >) -> NotInVec ; fn lt (_ : DateTime) -> Lt ; fn lte (_ : DateTime) -> Lte ; fn gt (_ : DateTime) -> Gt ; fn gte (_ : DateTime) -> Gte ; fn not (_ : DateTime) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: CreatedAt (v) } } pub struct Set (pub DateTime) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < DateTime >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: DateTimeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod end_date { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "endDate" ; pub type Type = DateTime ; pub type RecursiveSafeType = Type ; pub struct Equals (pub DateTime) ; pub fn equals < T : From < Equals >> (value : impl Into < DateTime >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: EndDate (_prisma :: read_filters :: DateTimeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , EndDate , { fn in_vec (_ : Vec < DateTime >) -> InVec ; fn not_in_vec (_ : Vec < DateTime >) -> NotInVec ; fn lt (_ : DateTime) -> Lt ; fn lte (_ : DateTime) -> Lte ; fn gt (_ : DateTime) -> Gt ; fn gte (_ : DateTime) -> Gte ; fn not (_ : DateTime) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: EndDate (v) } } pub struct Set (pub DateTime) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: EndDate (_prisma :: write_params :: DateTimeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < DateTime >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: DateTimeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: EndDate (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: EndDate (_prisma :: write_params :: DateTimeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: EndDate (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: EndDate (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: EndDate (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod estimated_hours { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "estimatedHours" ; pub type Type = Int ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Int) ; pub fn equals < T : From < Equals >> (value : impl Into < Int >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: EstimatedHours (_prisma :: read_filters :: IntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: IntFilter , EstimatedHours , { fn in_vec (_ : Vec < Int >) -> InVec ; fn not_in_vec (_ : Vec < Int >) -> NotInVec ; fn lt (_ : Int) -> Lt ; fn lte (_ : Int) -> Lte ; fn gt (_ : Int) -> Gt ; fn gte (_ : Int) -> Gte ; fn not (_ : Int) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: EstimatedHours (v) } } pub struct Set (pub Int) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: EstimatedHours (_prisma :: write_params :: IntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Int >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: IntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: EstimatedHours (v) } } pub fn increment < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: EstimatedHours (_prisma :: write_params :: IntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: EstimatedHours (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: EstimatedHours (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: EstimatedHours (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "id" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: IdEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Id (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Id , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Id (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod priority { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "priority" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Priority (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Priority , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Priority (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Priority (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Priority (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Priority (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Priority (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Priority (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Priority (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod product_name { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "productName" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: ProductName (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , ProductName , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: ProductName (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: ProductName (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ProductName (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: ProductName (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ProductName (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: ProductName (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: ProductName (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod progress { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "progress" ; pub type Type = Int ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Int) ; pub fn equals < T : From < Equals >> (value : impl Into < Int >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Progress (_prisma :: read_filters :: IntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: IntFilter , Progress , { fn in_vec (_ : Vec < Int >) -> InVec ; fn not_in_vec (_ : Vec < Int >) -> NotInVec ; fn lt (_ : Int) -> Lt ; fn lte (_ : Int) -> Lte ; fn gt (_ : Int) -> Gt ; fn gte (_ : Int) -> Gte ; fn not (_ : Int) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Progress (v) } } pub struct Set (pub Int) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Progress (_prisma :: write_params :: IntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Int >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: IntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Progress (v) } } pub fn increment < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Progress (_prisma :: write_params :: IntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Progress (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Progress (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Progress (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod quantity { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "quantity" ; pub type Type = Int ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Int) ; pub fn equals < T : From < Equals >> (value : impl Into < Int >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Quantity (_prisma :: read_filters :: IntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: IntFilter , Quantity , { fn in_vec (_ : Vec < Int >) -> InVec ; fn not_in_vec (_ : Vec < Int >) -> NotInVec ; fn lt (_ : Int) -> Lt ; fn lte (_ : Int) -> Lte ; fn gt (_ : Int) -> Gt ; fn gte (_ : Int) -> Gte ; fn not (_ : Int) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Quantity (v) } } pub struct Set (pub Int) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Quantity (_prisma :: write_params :: IntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Int >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: IntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Quantity (v) } } pub fn increment < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Quantity (_prisma :: write_params :: IntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Quantity (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Quantity (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Quantity (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod start_date { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "startDate" ; pub type Type = DateTime ; pub type RecursiveSafeType = Type ; pub struct Equals (pub DateTime) ; pub fn equals < T : From < Equals >> (value : impl Into < DateTime >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: StartDate (_prisma :: read_filters :: DateTimeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , StartDate , { fn in_vec (_ : Vec < DateTime >) -> InVec ; fn not_in_vec (_ : Vec < DateTime >) -> NotInVec ; fn lt (_ : DateTime) -> Lt ; fn lte (_ : DateTime) -> Lte ; fn gt (_ : DateTime) -> Gt ; fn gte (_ : DateTime) -> Gte ; fn not (_ : DateTime) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: StartDate (v) } } pub struct Set (pub DateTime) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: StartDate (_prisma :: write_params :: DateTimeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < DateTime >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: DateTimeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: StartDate (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: StartDate (_prisma :: write_params :: DateTimeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: StartDate (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: StartDate (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: StartDate (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod status { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "status" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Status (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Status , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Status (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Status (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Status (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Status (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Status (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Status (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Status (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod updated_at { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "updatedAt" ; pub type Type = DateTime ; pub type RecursiveSafeType = Type ; pub struct Equals (pub DateTime) ; pub fn equals < T : From < Equals >> (value : impl Into < DateTime >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: UpdatedAt (_prisma :: read_filters :: DateTimeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , UpdatedAt , { fn in_vec (_ : Vec < DateTime >) -> InVec ; fn not_in_vec (_ : Vec < DateTime >) -> NotInVec ; fn lt (_ : DateTime) -> Lt ; fn lte (_ : DateTime) -> Lte ; fn gt (_ : DateTime) -> Gt ; fn gte (_ : DateTime) -> Gte ; fn not (_ : DateTime) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: UpdatedAt (v) } } pub struct Set (pub DateTime) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: UpdatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < DateTime >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: DateTimeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: UpdatedAt (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: UpdatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: UpdatedAt (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: UpdatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: UpdatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } } pub mod resource { use super :: { _prisma :: * , * } ; pub const NAME : & str = "Resource" ; # [derive (Debug , Clone)] pub enum WhereParam { Not (Vec < WhereParam >) , Or (Vec < WhereParam >) , And (Vec < WhereParam >) , Id (super :: _prisma :: read_filters :: StringFilter) , Name (super :: _prisma :: read_filters :: StringFilter) , Type (super :: _prisma :: read_filters :: StringFilter) , Capacity (super :: _prisma :: read_filters :: IntFilter) , Allocated (super :: _prisma :: read_filters :: IntFilter) , Available (super :: _prisma :: read_filters :: IntFilter) , Efficiency (super :: _prisma :: read_filters :: IntFilter) , CreatedAt (super :: _prisma :: read_filters :: DateTimeFilter) , UpdatedAt (super :: _prisma :: read_filters :: DateTimeFilter) } impl :: prisma_client_rust :: WhereInput for WhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (| p | :: prisma_client_rust :: PrismaValue :: Object (vec ! [p . into ()])) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Id (value) => (id :: NAME , value . into ()) , Self :: Name (value) => (name :: NAME , value . into ()) , Self :: Type (value) => (r#type :: NAME , value . into ()) , Self :: Capacity (value) => (capacity :: NAME , value . into ()) , Self :: Allocated (value) => (allocated :: NAME , value . into ()) , Self :: Available (value) => (available :: NAME , value . into ()) , Self :: Efficiency (value) => (efficiency :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) , Self :: UpdatedAt (value) => (updated_at :: NAME , value . into ()) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } # [derive (Debug , Clone)] pub enum UniqueWhereParam { IdEquals (String) } impl :: prisma_client_rust :: WhereInput for UniqueWhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { UniqueWhereParam :: IdEquals (value) => ("id" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: String (value))) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } impl From < :: prisma_client_rust :: Operator < Self >> for WhereParam { fn from (op : :: prisma_client_rust :: Operator < Self >) -> Self { match op { :: prisma_client_rust :: Operator :: Not (value) => Self :: Not (value) , :: prisma_client_rust :: Operator :: And (value) => Self :: And (value) , :: prisma_client_rust :: Operator :: Or (value) => Self :: Or (value) , } } } # [derive (Debug , Clone)] pub enum OrderByWithRelationParam { Id (super :: SortOrder) , Name (super :: SortOrder) , Type (super :: SortOrder) , Capacity (super :: SortOrder) , Allocated (super :: SortOrder) , Available (super :: SortOrder) , Efficiency (super :: SortOrder) , CreatedAt (super :: SortOrder) , UpdatedAt (super :: SortOrder) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByWithRelationParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (param) => ("id" , param . into ()) , Self :: Name (param) => ("name" , param . into ()) , Self :: Type (param) => ("type" , param . into ()) , Self :: Capacity (param) => ("capacity" , param . into ()) , Self :: Allocated (param) => ("allocated" , param . into ()) , Self :: Available (param) => ("available" , param . into ()) , Self :: Efficiency (param) => ("efficiency" , param . into ()) , Self :: CreatedAt (param) => ("createdAt" , param . into ()) , Self :: UpdatedAt (param) => ("updatedAt" , param . into ()) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum WithParam { } impl Into < :: prisma_client_rust :: Selection > for WithParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { } } } # [derive (Debug , Clone)] pub enum SetParam { Id (super :: _prisma :: write_params :: StringParam) , Name (super :: _prisma :: write_params :: StringParam) , Type (super :: _prisma :: write_params :: StringParam) , Capacity (super :: _prisma :: write_params :: IntParam) , Allocated (super :: _prisma :: write_params :: IntParam) , Available (super :: _prisma :: write_params :: IntParam) , Efficiency (super :: _prisma :: write_params :: IntParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) , UpdatedAt (super :: _prisma :: write_params :: DateTimeParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for SetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => (id :: NAME , value . into ()) , Self :: Name (value) => (name :: NAME , value . into ()) , Self :: Type (value) => (r#type :: NAME , value . into ()) , Self :: Capacity (value) => (capacity :: NAME , value . into ()) , Self :: Allocated (value) => (allocated :: NAME , value . into ()) , Self :: Available (value) => (available :: NAME , value . into ()) , Self :: Efficiency (value) => (efficiency :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) , Self :: UpdatedAt (value) => (updated_at :: NAME , value . into ()) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum UncheckedSetParam { Id (super :: _prisma :: write_params :: StringParam) , Name (super :: _prisma :: write_params :: StringParam) , Type (super :: _prisma :: write_params :: StringParam) , Capacity (super :: _prisma :: write_params :: IntParam) , Allocated (super :: _prisma :: write_params :: IntParam) , Available (super :: _prisma :: write_params :: IntParam) , Efficiency (super :: _prisma :: write_params :: IntParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) , UpdatedAt (super :: _prisma :: write_params :: DateTimeParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for UncheckedSetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => ("id" , value . into ()) , Self :: Name (value) => ("name" , value . into ()) , Self :: Type (value) => ("type" , value . into ()) , Self :: Capacity (value) => ("capacity" , value . into ()) , Self :: Allocated (value) => ("allocated" , value . into ()) , Self :: Available (value) => ("available" , value . into ()) , Self :: Efficiency (value) => ("efficiency" , value . into ()) , Self :: CreatedAt (value) => ("createdAt" , value . into ()) , Self :: UpdatedAt (value) => ("updatedAt" , value . into ()) } ; (k . to_string () , v) } } :: prisma_client_rust :: macros :: select_factory ! (_select_resource , select , prisma :: resource , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "name")] name : name :: Type , # [serde (rename = "type")] r#type : r#type :: Type , # [serde (rename = "capacity")] capacity : capacity :: Type , # [serde (rename = "allocated")] allocated : allocated :: Type , # [serde (rename = "available")] available : available :: Type , # [serde (rename = "efficiency")] efficiency : efficiency :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type , # [serde (rename = "updatedAt")] updated_at : updated_at :: Type } , [(id , Scalar) , (name , Scalar) , (r#type , Scalar) , (capacity , Scalar) , (allocated , Scalar) , (available , Scalar) , (efficiency , Scalar) , (created_at , Scalar) , (updated_at , Scalar)]) ; pub enum SelectParam { Id (id :: Select) , Name (name :: Select) , Type (r#type :: Select) , Capacity (capacity :: Select) , Allocated (allocated :: Select) , Available (available :: Select) , Efficiency (efficiency :: Select) , CreatedAt (created_at :: Select) , UpdatedAt (updated_at :: Select) } impl Into < :: prisma_client_rust :: Selection > for SelectParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: Name (data) => data . into () , Self :: Type (data) => data . into () , Self :: Capacity (data) => data . into () , Self :: Allocated (data) => data . into () , Self :: Available (data) => data . into () , Self :: Efficiency (data) => data . into () , Self :: CreatedAt (data) => data . into () , Self :: UpdatedAt (data) => data . into () } } } :: prisma_client_rust :: macros :: include_factory ! (_include_resource , include , prisma :: resource , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "name")] name : name :: Type , # [serde (rename = "type")] r#type : r#type :: Type , # [serde (rename = "capacity")] capacity : capacity :: Type , # [serde (rename = "allocated")] allocated : allocated :: Type , # [serde (rename = "available")] available : available :: Type , # [serde (rename = "efficiency")] efficiency : efficiency :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type , # [serde (rename = "updatedAt")] updated_at : updated_at :: Type } , []) ; pub enum IncludeParam { Id (id :: Include) , Name (name :: Include) , Type (r#type :: Include) , Capacity (capacity :: Include) , Allocated (allocated :: Include) , Available (available :: Include) , Efficiency (efficiency :: Include) , CreatedAt (created_at :: Include) , UpdatedAt (updated_at :: Include) } impl Into < :: prisma_client_rust :: Selection > for IncludeParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: Name (data) => data . into () , Self :: Type (data) => data . into () , Self :: Capacity (data) => data . into () , Self :: Allocated (data) => data . into () , Self :: Available (data) => data . into () , Self :: Efficiency (data) => data . into () , Self :: CreatedAt (data) => data . into () , Self :: UpdatedAt (data) => data . into () } } } # [derive (Debug , Clone)] pub struct Create { pub name : String , pub r#type : String , pub capacity : Int , pub _params : Vec < SetParam > } impl Create { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateQuery < 'a > { client . resource () . create (self . name , self . r#type , self . capacity , self . _params) } pub fn to_params (mut self) -> Vec < SetParam > { self . _params . extend ([name :: set (self . name) , r#type :: set (self . r#type) , capacity :: set (self . capacity)]) ; self . _params } } pub fn create (name : String , r#type : String , capacity : Int , _params : Vec < SetParam >) -> Create { Create { name , r#type , capacity , _params } } # [derive (Debug , Clone)] pub struct CreateUnchecked { pub name : String , pub r#type : String , pub capacity : Int , pub _params : Vec < UncheckedSetParam > } impl CreateUnchecked { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateUncheckedQuery < 'a > { client . resource () . create_unchecked (self . name , self . r#type , self . capacity , self . _params) } pub fn to_params (mut self) -> Vec < UncheckedSetParam > { self . _params . extend ([name :: set (self . name) , r#type :: set (self . r#type) , capacity :: set (self . capacity)]) ; self . _params } } pub fn create_unchecked (name : String , r#type : String , capacity : Int , _params : Vec < UncheckedSetParam >) -> CreateUnchecked { CreateUnchecked { name , r#type , capacity , _params } } # [derive (Debug , Clone)] pub struct Types ; impl :: prisma_client_rust :: ModelTypes for Types { type Data = Data ; type Where = WhereParam ; type WhereUnique = UniqueWhereParam ; type UncheckedSet = UncheckedSetParam ; type Set = SetParam ; type With = WithParam ; type OrderBy = OrderByWithRelationParam ; type Cursor = UniqueWhereParam ; const MODEL : & 'static str = NAME ; fn scalar_selections () -> Vec < :: prisma_client_rust :: Selection > { vec ! [:: prisma_client_rust :: sel (id :: NAME) , :: prisma_client_rust :: sel (name :: NAME) , :: prisma_client_rust :: sel (r#type :: NAME) , :: prisma_client_rust :: sel (capacity :: NAME) , :: prisma_client_rust :: sel (allocated :: NAME) , :: prisma_client_rust :: sel (available :: NAME) , :: prisma_client_rust :: sel (efficiency :: NAME) , :: prisma_client_rust :: sel (created_at :: NAME) , :: prisma_client_rust :: sel (updated_at :: NAME)] } } # [derive (Debug , Clone , :: serde :: Serialize , :: serde :: Deserialize)] pub struct Data { # [serde (rename = "id")] pub id : id :: Type , # [serde (rename = "name")] pub name : name :: Type , # [serde (rename = "type")] pub r#type : r#type :: Type , # [serde (rename = "capacity")] pub capacity : capacity :: Type , # [serde (rename = "allocated")] pub allocated : allocated :: Type , # [serde (rename = "available")] pub available : available :: Type , # [serde (rename = "efficiency")] pub efficiency : efficiency :: Type , # [serde (rename = "createdAt")] pub created_at : created_at :: Type , # [serde (rename = "updatedAt")] pub updated_at : updated_at :: Type } impl Data { } :: prisma_client_rust :: macros :: partial_unchecked_factory ! (_partial_unchecked_resource , prisma :: resource , struct Data { # [serde (rename = "id")] pub id : prisma :: resource :: id :: Type , # [serde (rename = "name")] pub name : prisma :: resource :: name :: Type , # [serde (rename = "type")] pub r#type : prisma :: resource :: r#type :: Type , # [serde (rename = "capacity")] pub capacity : prisma :: resource :: capacity :: Type , # [serde (rename = "allocated")] pub allocated : prisma :: resource :: allocated :: Type , # [serde (rename = "available")] pub available : prisma :: resource :: available :: Type , # [serde (rename = "efficiency")] pub efficiency : prisma :: resource :: efficiency :: Type , # [serde (rename = "createdAt")] pub created_at : prisma :: resource :: created_at :: Type , # [serde (rename = "updatedAt")] pub updated_at : prisma :: resource :: updated_at :: Type }) ; :: prisma_client_rust :: macros :: filter_factory ! (_resource_filter , prisma :: resource , [(id , Scalar) , (name , Scalar) , (r#type , Scalar) , (capacity , Scalar) , (allocated , Scalar) , (available , Scalar) , (efficiency , Scalar) , (created_at , Scalar) , (updated_at , Scalar)]) ; pub type UniqueArgs = :: prisma_client_rust :: UniqueArgs < Types > ; pub type ManyArgs = :: prisma_client_rust :: ManyArgs < Types > ; pub type CountQuery < 'a > = :: prisma_client_rust :: Count < 'a , Types > ; pub type CreateQuery < 'a > = :: prisma_client_rust :: Create < 'a , Types > ; pub type CreateUncheckedQuery < 'a > = :: prisma_client_rust :: CreateUnchecked < 'a , Types > ; pub type CreateManyQuery < 'a > = :: prisma_client_rust :: CreateMany < 'a , Types > ; pub type FindUniqueQuery < 'a > = :: prisma_client_rust :: FindUnique < 'a , Types > ; pub type FindManyQuery < 'a > = :: prisma_client_rust :: FindMany < 'a , Types > ; pub type FindFirstQuery < 'a > = :: prisma_client_rust :: FindFirst < 'a , Types > ; pub type UpdateQuery < 'a > = :: prisma_client_rust :: Update < 'a , Types > ; pub type UpdateUncheckedQuery < 'a > = :: prisma_client_rust :: UpdateUnchecked < 'a , Types > ; pub type UpdateManyQuery < 'a > = :: prisma_client_rust :: UpdateMany < 'a , Types > ; pub type UpsertQuery < 'a > = :: prisma_client_rust :: Upsert < 'a , Types > ; pub type DeleteQuery < 'a > = :: prisma_client_rust :: Delete < 'a , Types > ; pub type DeleteManyQuery < 'a > = :: prisma_client_rust :: DeleteMany < 'a , Types > ; # [derive (Clone)] pub struct Actions < 'a > { pub client : & 'a :: prisma_client_rust :: PrismaClientInternals , } impl < 'a > Actions < 'a > { pub fn find_unique (self , _where : UniqueWhereParam) -> FindUniqueQuery < 'a > { FindUniqueQuery :: new (self . client , _where) } pub fn find_first (self , _where : Vec < WhereParam >) -> FindFirstQuery < 'a > { FindFirstQuery :: new (self . client , _where) } pub fn find_many (self , _where : Vec < WhereParam >) -> FindManyQuery < 'a > { FindManyQuery :: new (self . client , _where) } pub fn create (self , name : impl Into < String > , r#type : impl Into < String > , capacity : impl Into < Int > , mut _params : Vec < SetParam >) -> CreateQuery < 'a > { let name = name . into () ; let r#type = r#type . into () ; let capacity = capacity . into () ; _params . extend ([name :: set (name) , r#type :: set (r#type) , capacity :: set (capacity)]) ; CreateQuery :: new (self . client , _params) } pub fn create_unchecked (self , name : impl Into < String > , r#type : impl Into < String > , capacity : impl Into < Int > , mut _params : Vec < UncheckedSetParam >) -> CreateUncheckedQuery < 'a > { let name = name . into () ; let r#type = r#type . into () ; let capacity = capacity . into () ; _params . extend ([name :: set (name) , r#type :: set (r#type) , capacity :: set (capacity)]) ; CreateUncheckedQuery :: new (self . client , _params . into_iter () . map (Into :: into) . collect ()) } pub fn create_many (self , data : Vec < CreateUnchecked >) -> CreateManyQuery < 'a > { let data = data . into_iter () . map (CreateUnchecked :: to_params) . collect () ; CreateManyQuery :: new (self . client , data) } pub fn update (self , _where : UniqueWhereParam , _params : Vec < SetParam >) -> UpdateQuery < 'a > { UpdateQuery :: new (self . client , _where , _params , vec ! []) } pub fn update_unchecked (self , _where : UniqueWhereParam , _params : Vec < UncheckedSetParam >) -> UpdateUncheckedQuery < 'a > { UpdateUncheckedQuery :: new (self . client , _where , _params . into_iter () . map (Into :: into) . collect () , vec ! []) } pub fn update_many (self , _where : Vec < WhereParam > , _params : Vec < SetParam >) -> UpdateManyQuery < 'a > { UpdateManyQuery :: new (self . client , _where , _params ,) } pub fn upsert (self , _where : UniqueWhereParam , _create : Create , _update : Vec < SetParam >) -> UpsertQuery < 'a > { UpsertQuery :: new (self . client , _where , _create . to_params () , _update) } pub fn delete (self , _where : UniqueWhereParam) -> DeleteQuery < 'a > { DeleteQuery :: new (self . client , _where , vec ! []) } pub fn delete_many (self , _where : Vec < WhereParam >) -> DeleteManyQuery < 'a > { DeleteManyQuery :: new (self . client , _where) } pub fn count (self , _where : Vec < WhereParam >) -> CountQuery < 'a > { CountQuery :: new (self . client , _where) } } pub mod allocated { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "allocated" ; pub type Type = Int ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Int) ; pub fn equals < T : From < Equals >> (value : impl Into < Int >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Allocated (_prisma :: read_filters :: IntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: IntFilter , Allocated , { fn in_vec (_ : Vec < Int >) -> InVec ; fn not_in_vec (_ : Vec < Int >) -> NotInVec ; fn lt (_ : Int) -> Lt ; fn lte (_ : Int) -> Lte ; fn gt (_ : Int) -> Gt ; fn gte (_ : Int) -> Gte ; fn not (_ : Int) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Allocated (v) } } pub struct Set (pub Int) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Allocated (_prisma :: write_params :: IntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Int >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: IntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Allocated (v) } } pub fn increment < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Allocated (_prisma :: write_params :: IntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Allocated (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Allocated (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Allocated (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod available { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "available" ; pub type Type = Int ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Int) ; pub fn equals < T : From < Equals >> (value : impl Into < Int >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Available (_prisma :: read_filters :: IntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: IntFilter , Available , { fn in_vec (_ : Vec < Int >) -> InVec ; fn not_in_vec (_ : Vec < Int >) -> NotInVec ; fn lt (_ : Int) -> Lt ; fn lte (_ : Int) -> Lte ; fn gt (_ : Int) -> Gt ; fn gte (_ : Int) -> Gte ; fn not (_ : Int) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Available (v) } } pub struct Set (pub Int) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Available (_prisma :: write_params :: IntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Int >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: IntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Available (v) } } pub fn increment < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Available (_prisma :: write_params :: IntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Available (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Available (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Available (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod capacity { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "capacity" ; pub type Type = Int ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Int) ; pub fn equals < T : From < Equals >> (value : impl Into < Int >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Capacity (_prisma :: read_filters :: IntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: IntFilter , Capacity , { fn in_vec (_ : Vec < Int >) -> InVec ; fn not_in_vec (_ : Vec < Int >) -> NotInVec ; fn lt (_ : Int) -> Lt ; fn lte (_ : Int) -> Lte ; fn gt (_ : Int) -> Gt ; fn gte (_ : Int) -> Gte ; fn not (_ : Int) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Capacity (v) } } pub struct Set (pub Int) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Capacity (_prisma :: write_params :: IntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Int >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: IntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Capacity (v) } } pub fn increment < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Capacity (_prisma :: write_params :: IntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Capacity (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Capacity (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Capacity (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod created_at { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "createdAt" ; pub type Type = DateTime ; pub type RecursiveSafeType = Type ; pub struct Equals (pub DateTime) ; pub fn equals < T : From < Equals >> (value : impl Into < DateTime >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: CreatedAt (_prisma :: read_filters :: DateTimeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , CreatedAt , { fn in_vec (_ : Vec < DateTime >) -> InVec ; fn not_in_vec (_ : Vec < DateTime >) -> NotInVec ; fn lt (_ : DateTime) -> Lt ; fn lte (_ : DateTime) -> Lte ; fn gt (_ : DateTime) -> Gt ; fn gte (_ : DateTime) -> Gte ; fn not (_ : DateTime) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: CreatedAt (v) } } pub struct Set (pub DateTime) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < DateTime >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: DateTimeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod efficiency { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "efficiency" ; pub type Type = Int ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Int) ; pub fn equals < T : From < Equals >> (value : impl Into < Int >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Efficiency (_prisma :: read_filters :: IntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: IntFilter , Efficiency , { fn in_vec (_ : Vec < Int >) -> InVec ; fn not_in_vec (_ : Vec < Int >) -> NotInVec ; fn lt (_ : Int) -> Lt ; fn lte (_ : Int) -> Lte ; fn gt (_ : Int) -> Gt ; fn gte (_ : Int) -> Gte ; fn not (_ : Int) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Efficiency (v) } } pub struct Set (pub Int) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Efficiency (_prisma :: write_params :: IntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Int >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: IntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Efficiency (v) } } pub fn increment < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Efficiency (_prisma :: write_params :: IntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Efficiency (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Efficiency (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Efficiency (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "id" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: IdEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Id (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Id , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Id (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod name { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "name" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Name (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Name , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Name (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Name (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Name (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Name (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Name (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Name (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Name (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod r#type { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "type" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Type (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Type , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Type (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Type (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Type (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Type (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Type (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Type (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Type (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod updated_at { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "updatedAt" ; pub type Type = DateTime ; pub type RecursiveSafeType = Type ; pub struct Equals (pub DateTime) ; pub fn equals < T : From < Equals >> (value : impl Into < DateTime >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: UpdatedAt (_prisma :: read_filters :: DateTimeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , UpdatedAt , { fn in_vec (_ : Vec < DateTime >) -> InVec ; fn not_in_vec (_ : Vec < DateTime >) -> NotInVec ; fn lt (_ : DateTime) -> Lt ; fn lte (_ : DateTime) -> Lte ; fn gt (_ : DateTime) -> Gt ; fn gte (_ : DateTime) -> Gte ; fn not (_ : DateTime) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: UpdatedAt (v) } } pub struct Set (pub DateTime) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: UpdatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < DateTime >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: DateTimeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: UpdatedAt (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: UpdatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: UpdatedAt (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: UpdatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: UpdatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } } pub mod inventory_item { use super :: { _prisma :: * , * } ; pub const NAME : & str = "InventoryItem" ; # [derive (Debug , Clone)] pub enum WhereParam { Not (Vec < WhereParam >) , Or (Vec < WhereParam >) , And (Vec < WhereParam >) , Id (super :: _prisma :: read_filters :: StringFilter) , Name (super :: _prisma :: read_filters :: StringFilter) , Category (super :: _prisma :: read_filters :: StringFilter) , CurrentStock (super :: _prisma :: read_filters :: IntFilter) , MinStock (super :: _prisma :: read_filters :: IntFilter) , MaxStock (super :: _prisma :: read_filters :: IntFilter) , Unit (super :: _prisma :: read_filters :: StringFilter) , UnitCost (super :: _prisma :: read_filters :: FloatFilter) , TotalValue (super :: _prisma :: read_filters :: FloatFilter) , Location (super :: _prisma :: read_filters :: StringFilter) , LastUpdated (super :: _prisma :: read_filters :: DateTimeFilter) , Supplier (super :: _prisma :: read_filters :: StringNullableFilter) , CreatedAt (super :: _prisma :: read_filters :: DateTimeFilter) , UpdatedAt (super :: _prisma :: read_filters :: DateTimeFilter) } impl :: prisma_client_rust :: WhereInput for WhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (| p | :: prisma_client_rust :: PrismaValue :: Object (vec ! [p . into ()])) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Id (value) => (id :: NAME , value . into ()) , Self :: Name (value) => (name :: NAME , value . into ()) , Self :: Category (value) => (category :: NAME , value . into ()) , Self :: CurrentStock (value) => (current_stock :: NAME , value . into ()) , Self :: MinStock (value) => (min_stock :: NAME , value . into ()) , Self :: MaxStock (value) => (max_stock :: NAME , value . into ()) , Self :: Unit (value) => (unit :: NAME , value . into ()) , Self :: UnitCost (value) => (unit_cost :: NAME , value . into ()) , Self :: TotalValue (value) => (total_value :: NAME , value . into ()) , Self :: Location (value) => (location :: NAME , value . into ()) , Self :: LastUpdated (value) => (last_updated :: NAME , value . into ()) , Self :: Supplier (value) => (supplier :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) , Self :: UpdatedAt (value) => (updated_at :: NAME , value . into ()) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } # [derive (Debug , Clone)] pub enum UniqueWhereParam { IdEquals (String) } impl :: prisma_client_rust :: WhereInput for UniqueWhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { UniqueWhereParam :: IdEquals (value) => ("id" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: String (value))) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } impl From < :: prisma_client_rust :: Operator < Self >> for WhereParam { fn from (op : :: prisma_client_rust :: Operator < Self >) -> Self { match op { :: prisma_client_rust :: Operator :: Not (value) => Self :: Not (value) , :: prisma_client_rust :: Operator :: And (value) => Self :: And (value) , :: prisma_client_rust :: Operator :: Or (value) => Self :: Or (value) , } } } # [derive (Debug , Clone)] pub enum OrderByWithRelationParam { Id (super :: SortOrder) , Name (super :: SortOrder) , Category (super :: SortOrder) , CurrentStock (super :: SortOrder) , MinStock (super :: SortOrder) , MaxStock (super :: SortOrder) , Unit (super :: SortOrder) , UnitCost (super :: SortOrder) , TotalValue (super :: SortOrder) , Location (super :: SortOrder) , LastUpdated (super :: SortOrder) , Supplier (super :: SortOrder) , CreatedAt (super :: SortOrder) , UpdatedAt (super :: SortOrder) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByWithRelationParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (param) => ("id" , param . into ()) , Self :: Name (param) => ("name" , param . into ()) , Self :: Category (param) => ("category" , param . into ()) , Self :: CurrentStock (param) => ("currentStock" , param . into ()) , Self :: MinStock (param) => ("minStock" , param . into ()) , Self :: MaxStock (param) => ("maxStock" , param . into ()) , Self :: Unit (param) => ("unit" , param . into ()) , Self :: UnitCost (param) => ("unitCost" , param . into ()) , Self :: TotalValue (param) => ("totalValue" , param . into ()) , Self :: Location (param) => ("location" , param . into ()) , Self :: LastUpdated (param) => ("lastUpdated" , param . into ()) , Self :: Supplier (param) => ("supplier" , param . into ()) , Self :: CreatedAt (param) => ("createdAt" , param . into ()) , Self :: UpdatedAt (param) => ("updatedAt" , param . into ()) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum WithParam { } impl Into < :: prisma_client_rust :: Selection > for WithParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { } } } # [derive (Debug , Clone)] pub enum SetParam { Id (super :: _prisma :: write_params :: StringParam) , Name (super :: _prisma :: write_params :: StringParam) , Category (super :: _prisma :: write_params :: StringParam) , CurrentStock (super :: _prisma :: write_params :: IntParam) , MinStock (super :: _prisma :: write_params :: IntParam) , MaxStock (super :: _prisma :: write_params :: IntParam) , Unit (super :: _prisma :: write_params :: StringParam) , UnitCost (super :: _prisma :: write_params :: FloatParam) , TotalValue (super :: _prisma :: write_params :: FloatParam) , Location (super :: _prisma :: write_params :: StringParam) , LastUpdated (super :: _prisma :: write_params :: DateTimeParam) , Supplier (super :: _prisma :: write_params :: StringNullableParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) , UpdatedAt (super :: _prisma :: write_params :: DateTimeParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for SetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => (id :: NAME , value . into ()) , Self :: Name (value) => (name :: NAME , value . into ()) , Self :: Category (value) => (category :: NAME , value . into ()) , Self :: CurrentStock (value) => (current_stock :: NAME , value . into ()) , Self :: MinStock (value) => (min_stock :: NAME , value . into ()) , Self :: MaxStock (value) => (max_stock :: NAME , value . into ()) , Self :: Unit (value) => (unit :: NAME , value . into ()) , Self :: UnitCost (value) => (unit_cost :: NAME , value . into ()) , Self :: TotalValue (value) => (total_value :: NAME , value . into ()) , Self :: Location (value) => (location :: NAME , value . into ()) , Self :: LastUpdated (value) => (last_updated :: NAME , value . into ()) , Self :: Supplier (value) => (supplier :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) , Self :: UpdatedAt (value) => (updated_at :: NAME , value . into ()) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum UncheckedSetParam { Id (super :: _prisma :: write_params :: StringParam) , Name (super :: _prisma :: write_params :: StringParam) , Category (super :: _prisma :: write_params :: StringParam) , CurrentStock (super :: _prisma :: write_params :: IntParam) , MinStock (super :: _prisma :: write_params :: IntParam) , MaxStock (super :: _prisma :: write_params :: IntParam) , Unit (super :: _prisma :: write_params :: StringParam) , UnitCost (super :: _prisma :: write_params :: FloatParam) , TotalValue (super :: _prisma :: write_params :: FloatParam) , Location (super :: _prisma :: write_params :: StringParam) , LastUpdated (super :: _prisma :: write_params :: DateTimeParam) , Supplier (super :: _prisma :: write_params :: StringNullableParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) , UpdatedAt (super :: _prisma :: write_params :: DateTimeParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for UncheckedSetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => ("id" , value . into ()) , Self :: Name (value) => ("name" , value . into ()) , Self :: Category (value) => ("category" , value . into ()) , Self :: CurrentStock (value) => ("currentStock" , value . into ()) , Self :: MinStock (value) => ("minStock" , value . into ()) , Self :: MaxStock (value) => ("maxStock" , value . into ()) , Self :: Unit (value) => ("unit" , value . into ()) , Self :: UnitCost (value) => ("unitCost" , value . into ()) , Self :: TotalValue (value) => ("totalValue" , value . into ()) , Self :: Location (value) => ("location" , value . into ()) , Self :: LastUpdated (value) => ("lastUpdated" , value . into ()) , Self :: Supplier (value) => ("supplier" , value . into ()) , Self :: CreatedAt (value) => ("createdAt" , value . into ()) , Self :: UpdatedAt (value) => ("updatedAt" , value . into ()) } ; (k . to_string () , v) } } :: prisma_client_rust :: macros :: select_factory ! (_select_inventory_item , select , prisma :: inventory_item , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "name")] name : name :: Type , # [serde (rename = "category")] category : category :: Type , # [serde (rename = "currentStock")] current_stock : current_stock :: Type , # [serde (rename = "minStock")] min_stock : min_stock :: Type , # [serde (rename = "maxStock")] max_stock : max_stock :: Type , # [serde (rename = "unit")] unit : unit :: Type , # [serde (rename = "unitCost")] unit_cost : unit_cost :: Type , # [serde (rename = "totalValue")] total_value : total_value :: Type , # [serde (rename = "location")] location : location :: Type , # [serde (rename = "lastUpdated")] last_updated : last_updated :: Type , # [serde (rename = "supplier")] supplier : supplier :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type , # [serde (rename = "updatedAt")] updated_at : updated_at :: Type } , [(id , Scalar) , (name , Scalar) , (category , Scalar) , (current_stock , Scalar) , (min_stock , Scalar) , (max_stock , Scalar) , (unit , Scalar) , (unit_cost , Scalar) , (total_value , Scalar) , (location , Scalar) , (last_updated , Scalar) , (supplier , Scalar) , (created_at , Scalar) , (updated_at , Scalar)]) ; pub enum SelectParam { Id (id :: Select) , Name (name :: Select) , Category (category :: Select) , CurrentStock (current_stock :: Select) , MinStock (min_stock :: Select) , MaxStock (max_stock :: Select) , Unit (unit :: Select) , UnitCost (unit_cost :: Select) , TotalValue (total_value :: Select) , Location (location :: Select) , LastUpdated (last_updated :: Select) , Supplier (supplier :: Select) , CreatedAt (created_at :: Select) , UpdatedAt (updated_at :: Select) } impl Into < :: prisma_client_rust :: Selection > for SelectParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: Name (data) => data . into () , Self :: Category (data) => data . into () , Self :: CurrentStock (data) => data . into () , Self :: MinStock (data) => data . into () , Self :: MaxStock (data) => data . into () , Self :: Unit (data) => data . into () , Self :: UnitCost (data) => data . into () , Self :: TotalValue (data) => data . into () , Self :: Location (data) => data . into () , Self :: LastUpdated (data) => data . into () , Self :: Supplier (data) => data . into () , Self :: CreatedAt (data) => data . into () , Self :: UpdatedAt (data) => data . into () } } } :: prisma_client_rust :: macros :: include_factory ! (_include_inventory_item , include , prisma :: inventory_item , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "name")] name : name :: Type , # [serde (rename = "category")] category : category :: Type , # [serde (rename = "currentStock")] current_stock : current_stock :: Type , # [serde (rename = "minStock")] min_stock : min_stock :: Type , # [serde (rename = "maxStock")] max_stock : max_stock :: Type , # [serde (rename = "unit")] unit : unit :: Type , # [serde (rename = "unitCost")] unit_cost : unit_cost :: Type , # [serde (rename = "totalValue")] total_value : total_value :: Type , # [serde (rename = "location")] location : location :: Type , # [serde (rename = "lastUpdated")] last_updated : last_updated :: Type , # [serde (rename = "supplier")] supplier : supplier :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type , # [serde (rename = "updatedAt")] updated_at : updated_at :: Type } , []) ; pub enum IncludeParam { Id (id :: Include) , Name (name :: Include) , Category (category :: Include) , CurrentStock (current_stock :: Include) , MinStock (min_stock :: Include) , MaxStock (max_stock :: Include) , Unit (unit :: Include) , UnitCost (unit_cost :: Include) , TotalValue (total_value :: Include) , Location (location :: Include) , LastUpdated (last_updated :: Include) , Supplier (supplier :: Include) , CreatedAt (created_at :: Include) , UpdatedAt (updated_at :: Include) } impl Into < :: prisma_client_rust :: Selection > for IncludeParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: Name (data) => data . into () , Self :: Category (data) => data . into () , Self :: CurrentStock (data) => data . into () , Self :: MinStock (data) => data . into () , Self :: MaxStock (data) => data . into () , Self :: Unit (data) => data . into () , Self :: UnitCost (data) => data . into () , Self :: TotalValue (data) => data . into () , Self :: Location (data) => data . into () , Self :: LastUpdated (data) => data . into () , Self :: Supplier (data) => data . into () , Self :: CreatedAt (data) => data . into () , Self :: UpdatedAt (data) => data . into () } } } # [derive (Debug , Clone)] pub struct Create { pub name : String , pub category : String , pub current_stock : Int , pub min_stock : Int , pub max_stock : Int , pub unit : String , pub unit_cost : Float , pub total_value : Float , pub location : String , pub _params : Vec < SetParam > } impl Create { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateQuery < 'a > { client . inventory_item () . create (self . name , self . category , self . current_stock , self . min_stock , self . max_stock , self . unit , self . unit_cost , self . total_value , self . location , self . _params) } pub fn to_params (mut self) -> Vec < SetParam > { self . _params . extend ([name :: set (self . name) , category :: set (self . category) , current_stock :: set (self . current_stock) , min_stock :: set (self . min_stock) , max_stock :: set (self . max_stock) , unit :: set (self . unit) , unit_cost :: set (self . unit_cost) , total_value :: set (self . total_value) , location :: set (self . location)]) ; self . _params } } pub fn create (name : String , category : String , current_stock : Int , min_stock : Int , max_stock : Int , unit : String , unit_cost : Float , total_value : Float , location : String , _params : Vec < SetParam >) -> Create { Create { name , category , current_stock , min_stock , max_stock , unit , unit_cost , total_value , location , _params } } # [derive (Debug , Clone)] pub struct CreateUnchecked { pub name : String , pub category : String , pub current_stock : Int , pub min_stock : Int , pub max_stock : Int , pub unit : String , pub unit_cost : Float , pub total_value : Float , pub location : String , pub _params : Vec < UncheckedSetParam > } impl CreateUnchecked { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateUncheckedQuery < 'a > { client . inventory_item () . create_unchecked (self . name , self . category , self . current_stock , self . min_stock , self . max_stock , self . unit , self . unit_cost , self . total_value , self . location , self . _params) } pub fn to_params (mut self) -> Vec < UncheckedSetParam > { self . _params . extend ([name :: set (self . name) , category :: set (self . category) , current_stock :: set (self . current_stock) , min_stock :: set (self . min_stock) , max_stock :: set (self . max_stock) , unit :: set (self . unit) , unit_cost :: set (self . unit_cost) , total_value :: set (self . total_value) , location :: set (self . location)]) ; self . _params } } pub fn create_unchecked (name : String , category : String , current_stock : Int , min_stock : Int , max_stock : Int , unit : String , unit_cost : Float , total_value : Float , location : String , _params : Vec < UncheckedSetParam >) -> CreateUnchecked { CreateUnchecked { name , category , current_stock , min_stock , max_stock , unit , unit_cost , total_value , location , _params } } # [derive (Debug , Clone)] pub struct Types ; impl :: prisma_client_rust :: ModelTypes for Types { type Data = Data ; type Where = WhereParam ; type WhereUnique = UniqueWhereParam ; type UncheckedSet = UncheckedSetParam ; type Set = SetParam ; type With = WithParam ; type OrderBy = OrderByWithRelationParam ; type Cursor = UniqueWhereParam ; const MODEL : & 'static str = NAME ; fn scalar_selections () -> Vec < :: prisma_client_rust :: Selection > { vec ! [:: prisma_client_rust :: sel (id :: NAME) , :: prisma_client_rust :: sel (name :: NAME) , :: prisma_client_rust :: sel (category :: NAME) , :: prisma_client_rust :: sel (current_stock :: NAME) , :: prisma_client_rust :: sel (min_stock :: NAME) , :: prisma_client_rust :: sel (max_stock :: NAME) , :: prisma_client_rust :: sel (unit :: NAME) , :: prisma_client_rust :: sel (unit_cost :: NAME) , :: prisma_client_rust :: sel (total_value :: NAME) , :: prisma_client_rust :: sel (location :: NAME) , :: prisma_client_rust :: sel (last_updated :: NAME) , :: prisma_client_rust :: sel (supplier :: NAME) , :: prisma_client_rust :: sel (created_at :: NAME) , :: prisma_client_rust :: sel (updated_at :: NAME)] } } # [derive (Debug , Clone , :: serde :: Serialize , :: serde :: Deserialize)] pub struct Data { # [serde (rename = "id")] pub id : id :: Type , # [serde (rename = "name")] pub name : name :: Type , # [serde (rename = "category")] pub category : category :: Type , # [serde (rename = "currentStock")] pub current_stock : current_stock :: Type , # [serde (rename = "minStock")] pub min_stock : min_stock :: Type , # [serde (rename = "maxStock")] pub max_stock : max_stock :: Type , # [serde (rename = "unit")] pub unit : unit :: Type , # [serde (rename = "unitCost")] pub unit_cost : unit_cost :: Type , # [serde (rename = "totalValue")] pub total_value : total_value :: Type , # [serde (rename = "location")] pub location : location :: Type , # [serde (rename = "lastUpdated")] pub last_updated : last_updated :: Type , # [serde (rename = "supplier")] pub supplier : supplier :: Type , # [serde (rename = "createdAt")] pub created_at : created_at :: Type , # [serde (rename = "updatedAt")] pub updated_at : updated_at :: Type } impl Data { } :: prisma_client_rust :: macros :: partial_unchecked_factory ! (_partial_unchecked_inventory_item , prisma :: inventory_item , struct Data { # [serde (rename = "id")] pub id : prisma :: inventory_item :: id :: Type , # [serde (rename = "name")] pub name : prisma :: inventory_item :: name :: Type , # [serde (rename = "category")] pub category : prisma :: inventory_item :: category :: Type , # [serde (rename = "currentStock")] pub current_stock : prisma :: inventory_item :: current_stock :: Type , # [serde (rename = "minStock")] pub min_stock : prisma :: inventory_item :: min_stock :: Type , # [serde (rename = "maxStock")] pub max_stock : prisma :: inventory_item :: max_stock :: Type , # [serde (rename = "unit")] pub unit : prisma :: inventory_item :: unit :: Type , # [serde (rename = "unitCost")] pub unit_cost : prisma :: inventory_item :: unit_cost :: Type , # [serde (rename = "totalValue")] pub total_value : prisma :: inventory_item :: total_value :: Type , # [serde (rename = "location")] pub location : prisma :: inventory_item :: location :: Type , # [serde (rename = "lastUpdated")] pub last_updated : prisma :: inventory_item :: last_updated :: Type , # [serde (rename = "supplier")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub supplier : prisma :: inventory_item :: supplier :: Type , # [serde (rename = "createdAt")] pub created_at : prisma :: inventory_item :: created_at :: Type , # [serde (rename = "updatedAt")] pub updated_at : prisma :: inventory_item :: updated_at :: Type }) ; :: prisma_client_rust :: macros :: filter_factory ! (_inventory_item_filter , prisma :: inventory_item , [(id , Scalar) , (name , Scalar) , (category , Scalar) , (current_stock , Scalar) , (min_stock , Scalar) , (max_stock , Scalar) , (unit , Scalar) , (unit_cost , Scalar) , (total_value , Scalar) , (location , Scalar) , (last_updated , Scalar) , (supplier , Scalar) , (created_at , Scalar) , (updated_at , Scalar)]) ; pub type UniqueArgs = :: prisma_client_rust :: UniqueArgs < Types > ; pub type ManyArgs = :: prisma_client_rust :: ManyArgs < Types > ; pub type CountQuery < 'a > = :: prisma_client_rust :: Count < 'a , Types > ; pub type CreateQuery < 'a > = :: prisma_client_rust :: Create < 'a , Types > ; pub type CreateUncheckedQuery < 'a > = :: prisma_client_rust :: CreateUnchecked < 'a , Types > ; pub type CreateManyQuery < 'a > = :: prisma_client_rust :: CreateMany < 'a , Types > ; pub type FindUniqueQuery < 'a > = :: prisma_client_rust :: FindUnique < 'a , Types > ; pub type FindManyQuery < 'a > = :: prisma_client_rust :: FindMany < 'a , Types > ; pub type FindFirstQuery < 'a > = :: prisma_client_rust :: FindFirst < 'a , Types > ; pub type UpdateQuery < 'a > = :: prisma_client_rust :: Update < 'a , Types > ; pub type UpdateUncheckedQuery < 'a > = :: prisma_client_rust :: UpdateUnchecked < 'a , Types > ; pub type UpdateManyQuery < 'a > = :: prisma_client_rust :: UpdateMany < 'a , Types > ; pub type UpsertQuery < 'a > = :: prisma_client_rust :: Upsert < 'a , Types > ; pub type DeleteQuery < 'a > = :: prisma_client_rust :: Delete < 'a , Types > ; pub type DeleteManyQuery < 'a > = :: prisma_client_rust :: DeleteMany < 'a , Types > ; # [derive (Clone)] pub struct Actions < 'a > { pub client : & 'a :: prisma_client_rust :: PrismaClientInternals , } impl < 'a > Actions < 'a > { pub fn find_unique (self , _where : UniqueWhereParam) -> FindUniqueQuery < 'a > { FindUniqueQuery :: new (self . client , _where) } pub fn find_first (self , _where : Vec < WhereParam >) -> FindFirstQuery < 'a > { FindFirstQuery :: new (self . client , _where) } pub fn find_many (self , _where : Vec < WhereParam >) -> FindManyQuery < 'a > { FindManyQuery :: new (self . client , _where) } pub fn create (self , name : impl Into < String > , category : impl Into < String > , current_stock : impl Into < Int > , min_stock : impl Into < Int > , max_stock : impl Into < Int > , unit : impl Into < String > , unit_cost : impl Into < Float > , total_value : impl Into < Float > , location : impl Into < String > , mut _params : Vec < SetParam >) -> CreateQuery < 'a > { let name = name . into () ; let category = category . into () ; let current_stock = current_stock . into () ; let min_stock = min_stock . into () ; let max_stock = max_stock . into () ; let unit = unit . into () ; let unit_cost = unit_cost . into () ; let total_value = total_value . into () ; let location = location . into () ; _params . extend ([name :: set (name) , category :: set (category) , current_stock :: set (current_stock) , min_stock :: set (min_stock) , max_stock :: set (max_stock) , unit :: set (unit) , unit_cost :: set (unit_cost) , total_value :: set (total_value) , location :: set (location)]) ; CreateQuery :: new (self . client , _params) } pub fn create_unchecked (self , name : impl Into < String > , category : impl Into < String > , current_stock : impl Into < Int > , min_stock : impl Into < Int > , max_stock : impl Into < Int > , unit : impl Into < String > , unit_cost : impl Into < Float > , total_value : impl Into < Float > , location : impl Into < String > , mut _params : Vec < UncheckedSetParam >) -> CreateUncheckedQuery < 'a > { let name = name . into () ; let category = category . into () ; let current_stock = current_stock . into () ; let min_stock = min_stock . into () ; let max_stock = max_stock . into () ; let unit = unit . into () ; let unit_cost = unit_cost . into () ; let total_value = total_value . into () ; let location = location . into () ; _params . extend ([name :: set (name) , category :: set (category) , current_stock :: set (current_stock) , min_stock :: set (min_stock) , max_stock :: set (max_stock) , unit :: set (unit) , unit_cost :: set (unit_cost) , total_value :: set (total_value) , location :: set (location)]) ; CreateUncheckedQuery :: new (self . client , _params . into_iter () . map (Into :: into) . collect ()) } pub fn create_many (self , data : Vec < CreateUnchecked >) -> CreateManyQuery < 'a > { let data = data . into_iter () . map (CreateUnchecked :: to_params) . collect () ; CreateManyQuery :: new (self . client , data) } pub fn update (self , _where : UniqueWhereParam , _params : Vec < SetParam >) -> UpdateQuery < 'a > { UpdateQuery :: new (self . client , _where , _params , vec ! []) } pub fn update_unchecked (self , _where : UniqueWhereParam , _params : Vec < UncheckedSetParam >) -> UpdateUncheckedQuery < 'a > { UpdateUncheckedQuery :: new (self . client , _where , _params . into_iter () . map (Into :: into) . collect () , vec ! []) } pub fn update_many (self , _where : Vec < WhereParam > , _params : Vec < SetParam >) -> UpdateManyQuery < 'a > { UpdateManyQuery :: new (self . client , _where , _params ,) } pub fn upsert (self , _where : UniqueWhereParam , _create : Create , _update : Vec < SetParam >) -> UpsertQuery < 'a > { UpsertQuery :: new (self . client , _where , _create . to_params () , _update) } pub fn delete (self , _where : UniqueWhereParam) -> DeleteQuery < 'a > { DeleteQuery :: new (self . client , _where , vec ! []) } pub fn delete_many (self , _where : Vec < WhereParam >) -> DeleteManyQuery < 'a > { DeleteManyQuery :: new (self . client , _where) } pub fn count (self , _where : Vec < WhereParam >) -> CountQuery < 'a > { CountQuery :: new (self . client , _where) } } pub mod category { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "category" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Category (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Category , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Category (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Category (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Category (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Category (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Category (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Category (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Category (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod created_at { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "createdAt" ; pub type Type = DateTime ; pub type RecursiveSafeType = Type ; pub struct Equals (pub DateTime) ; pub fn equals < T : From < Equals >> (value : impl Into < DateTime >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: CreatedAt (_prisma :: read_filters :: DateTimeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , CreatedAt , { fn in_vec (_ : Vec < DateTime >) -> InVec ; fn not_in_vec (_ : Vec < DateTime >) -> NotInVec ; fn lt (_ : DateTime) -> Lt ; fn lte (_ : DateTime) -> Lte ; fn gt (_ : DateTime) -> Gt ; fn gte (_ : DateTime) -> Gte ; fn not (_ : DateTime) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: CreatedAt (v) } } pub struct Set (pub DateTime) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < DateTime >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: DateTimeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod current_stock { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "currentStock" ; pub type Type = Int ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Int) ; pub fn equals < T : From < Equals >> (value : impl Into < Int >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: CurrentStock (_prisma :: read_filters :: IntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: IntFilter , CurrentStock , { fn in_vec (_ : Vec < Int >) -> InVec ; fn not_in_vec (_ : Vec < Int >) -> NotInVec ; fn lt (_ : Int) -> Lt ; fn lte (_ : Int) -> Lte ; fn gt (_ : Int) -> Gt ; fn gte (_ : Int) -> Gte ; fn not (_ : Int) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: CurrentStock (v) } } pub struct Set (pub Int) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: CurrentStock (_prisma :: write_params :: IntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Int >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: IntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CurrentStock (v) } } pub fn increment < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: CurrentStock (_prisma :: write_params :: IntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CurrentStock (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: CurrentStock (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: CurrentStock (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "id" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: IdEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Id (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Id , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Id (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod last_updated { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "lastUpdated" ; pub type Type = DateTime ; pub type RecursiveSafeType = Type ; pub struct Equals (pub DateTime) ; pub fn equals < T : From < Equals >> (value : impl Into < DateTime >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: LastUpdated (_prisma :: read_filters :: DateTimeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , LastUpdated , { fn in_vec (_ : Vec < DateTime >) -> InVec ; fn not_in_vec (_ : Vec < DateTime >) -> NotInVec ; fn lt (_ : DateTime) -> Lt ; fn lte (_ : DateTime) -> Lte ; fn gt (_ : DateTime) -> Gt ; fn gte (_ : DateTime) -> Gte ; fn not (_ : DateTime) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: LastUpdated (v) } } pub struct Set (pub DateTime) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: LastUpdated (_prisma :: write_params :: DateTimeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < DateTime >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: DateTimeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: LastUpdated (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: LastUpdated (_prisma :: write_params :: DateTimeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: LastUpdated (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: LastUpdated (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: LastUpdated (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod location { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "location" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Location (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Location , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Location (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Location (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Location (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Location (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Location (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Location (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Location (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod max_stock { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "maxStock" ; pub type Type = Int ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Int) ; pub fn equals < T : From < Equals >> (value : impl Into < Int >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: MaxStock (_prisma :: read_filters :: IntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: IntFilter , MaxStock , { fn in_vec (_ : Vec < Int >) -> InVec ; fn not_in_vec (_ : Vec < Int >) -> NotInVec ; fn lt (_ : Int) -> Lt ; fn lte (_ : Int) -> Lte ; fn gt (_ : Int) -> Gt ; fn gte (_ : Int) -> Gte ; fn not (_ : Int) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: MaxStock (v) } } pub struct Set (pub Int) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: MaxStock (_prisma :: write_params :: IntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Int >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: IntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: MaxStock (v) } } pub fn increment < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: MaxStock (_prisma :: write_params :: IntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: MaxStock (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: MaxStock (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: MaxStock (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod min_stock { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "minStock" ; pub type Type = Int ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Int) ; pub fn equals < T : From < Equals >> (value : impl Into < Int >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: MinStock (_prisma :: read_filters :: IntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: IntFilter , MinStock , { fn in_vec (_ : Vec < Int >) -> InVec ; fn not_in_vec (_ : Vec < Int >) -> NotInVec ; fn lt (_ : Int) -> Lt ; fn lte (_ : Int) -> Lte ; fn gt (_ : Int) -> Gt ; fn gte (_ : Int) -> Gte ; fn not (_ : Int) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: MinStock (v) } } pub struct Set (pub Int) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: MinStock (_prisma :: write_params :: IntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Int >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: IntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: MinStock (v) } } pub fn increment < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: MinStock (_prisma :: write_params :: IntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: MinStock (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: MinStock (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: MinStock (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod name { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "name" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Name (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Name , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Name (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Name (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Name (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Name (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Name (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Name (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Name (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod supplier { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "supplier" ; pub type Type = Option < String > ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Option < String >) ; pub fn equals < T : From < Equals >> (value : impl Into < Option < String > >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Supplier (_prisma :: read_filters :: StringNullableFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringNullableFilter , Supplier , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : Option < String >) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Supplier (v) } } pub struct Set (pub Option < String >) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Supplier (_prisma :: write_params :: StringNullableParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Option < String > >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringNullableParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Supplier (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Supplier (_prisma :: write_params :: StringNullableParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Supplier (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Supplier (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Supplier (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod total_value { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "totalValue" ; pub type Type = Float ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Float) ; pub fn equals < T : From < Equals >> (value : impl Into < Float >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: TotalValue (_prisma :: read_filters :: FloatFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: FloatFilter , TotalValue , { fn in_vec (_ : Vec < Float >) -> InVec ; fn not_in_vec (_ : Vec < Float >) -> NotInVec ; fn lt (_ : Float) -> Lt ; fn lte (_ : Float) -> Lte ; fn gt (_ : Float) -> Gt ; fn gte (_ : Float) -> Gte ; fn not (_ : Float) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: TotalValue (v) } } pub struct Set (pub Float) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: TotalValue (_prisma :: write_params :: FloatParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Float >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: FloatParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: TotalValue (v) } } pub fn increment < T : From < UpdateOperation >> (value : Float) -> T { UpdateOperation (_prisma :: write_params :: FloatParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : Float) -> T { UpdateOperation (_prisma :: write_params :: FloatParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : Float) -> T { UpdateOperation (_prisma :: write_params :: FloatParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : Float) -> T { UpdateOperation (_prisma :: write_params :: FloatParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: TotalValue (_prisma :: write_params :: FloatParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: TotalValue (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: TotalValue (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: TotalValue (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod unit { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "unit" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Unit (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Unit , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Unit (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Unit (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Unit (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Unit (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Unit (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Unit (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Unit (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod unit_cost { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "unitCost" ; pub type Type = Float ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Float) ; pub fn equals < T : From < Equals >> (value : impl Into < Float >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: UnitCost (_prisma :: read_filters :: FloatFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: FloatFilter , UnitCost , { fn in_vec (_ : Vec < Float >) -> InVec ; fn not_in_vec (_ : Vec < Float >) -> NotInVec ; fn lt (_ : Float) -> Lt ; fn lte (_ : Float) -> Lte ; fn gt (_ : Float) -> Gt ; fn gte (_ : Float) -> Gte ; fn not (_ : Float) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: UnitCost (v) } } pub struct Set (pub Float) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: UnitCost (_prisma :: write_params :: FloatParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Float >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: FloatParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: UnitCost (v) } } pub fn increment < T : From < UpdateOperation >> (value : Float) -> T { UpdateOperation (_prisma :: write_params :: FloatParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : Float) -> T { UpdateOperation (_prisma :: write_params :: FloatParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : Float) -> T { UpdateOperation (_prisma :: write_params :: FloatParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : Float) -> T { UpdateOperation (_prisma :: write_params :: FloatParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: UnitCost (_prisma :: write_params :: FloatParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: UnitCost (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: UnitCost (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: UnitCost (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod updated_at { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "updatedAt" ; pub type Type = DateTime ; pub type RecursiveSafeType = Type ; pub struct Equals (pub DateTime) ; pub fn equals < T : From < Equals >> (value : impl Into < DateTime >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: UpdatedAt (_prisma :: read_filters :: DateTimeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , UpdatedAt , { fn in_vec (_ : Vec < DateTime >) -> InVec ; fn not_in_vec (_ : Vec < DateTime >) -> NotInVec ; fn lt (_ : DateTime) -> Lt ; fn lte (_ : DateTime) -> Lte ; fn gt (_ : DateTime) -> Gt ; fn gte (_ : DateTime) -> Gte ; fn not (_ : DateTime) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: UpdatedAt (v) } } pub struct Set (pub DateTime) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: UpdatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < DateTime >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: DateTimeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: UpdatedAt (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: UpdatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: UpdatedAt (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: UpdatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: UpdatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } } pub mod inventory_history { use super :: { _prisma :: * , * } ; pub const NAME : & str = "InventoryHistory" ; # [derive (Debug , Clone)] pub enum WhereParam { Not (Vec < WhereParam >) , Or (Vec < WhereParam >) , And (Vec < WhereParam >) , Id (super :: _prisma :: read_filters :: StringFilter) , ItemId (super :: _prisma :: read_filters :: StringFilter) , Action (super :: _prisma :: read_filters :: StringFilter) , QuantityChange (super :: _prisma :: read_filters :: IntFilter) , PreviousStock (super :: _prisma :: read_filters :: IntFilter) , NewStock (super :: _prisma :: read_filters :: IntFilter) , Note (super :: _prisma :: read_filters :: StringNullableFilter) , User (super :: _prisma :: read_filters :: StringNullableFilter) , CreatedAt (super :: _prisma :: read_filters :: DateTimeFilter) } impl :: prisma_client_rust :: WhereInput for WhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (| p | :: prisma_client_rust :: PrismaValue :: Object (vec ! [p . into ()])) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Id (value) => (id :: NAME , value . into ()) , Self :: ItemId (value) => (item_id :: NAME , value . into ()) , Self :: Action (value) => (action :: NAME , value . into ()) , Self :: QuantityChange (value) => (quantity_change :: NAME , value . into ()) , Self :: PreviousStock (value) => (previous_stock :: NAME , value . into ()) , Self :: NewStock (value) => (new_stock :: NAME , value . into ()) , Self :: Note (value) => (note :: NAME , value . into ()) , Self :: User (value) => (user :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } # [derive (Debug , Clone)] pub enum UniqueWhereParam { IdEquals (String) } impl :: prisma_client_rust :: WhereInput for UniqueWhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { UniqueWhereParam :: IdEquals (value) => ("id" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: String (value))) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } impl From < :: prisma_client_rust :: Operator < Self >> for WhereParam { fn from (op : :: prisma_client_rust :: Operator < Self >) -> Self { match op { :: prisma_client_rust :: Operator :: Not (value) => Self :: Not (value) , :: prisma_client_rust :: Operator :: And (value) => Self :: And (value) , :: prisma_client_rust :: Operator :: Or (value) => Self :: Or (value) , } } } # [derive (Debug , Clone)] pub enum OrderByWithRelationParam { Id (super :: SortOrder) , ItemId (super :: SortOrder) , Action (super :: SortOrder) , QuantityChange (super :: SortOrder) , PreviousStock (super :: SortOrder) , NewStock (super :: SortOrder) , Note (super :: SortOrder) , User (super :: SortOrder) , CreatedAt (super :: SortOrder) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByWithRelationParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (param) => ("id" , param . into ()) , Self :: ItemId (param) => ("itemId" , param . into ()) , Self :: Action (param) => ("action" , param . into ()) , Self :: QuantityChange (param) => ("quantityChange" , param . into ()) , Self :: PreviousStock (param) => ("previousStock" , param . into ()) , Self :: NewStock (param) => ("newStock" , param . into ()) , Self :: Note (param) => ("note" , param . into ()) , Self :: User (param) => ("user" , param . into ()) , Self :: CreatedAt (param) => ("createdAt" , param . into ()) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum WithParam { } impl Into < :: prisma_client_rust :: Selection > for WithParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { } } } # [derive (Debug , Clone)] pub enum SetParam { Id (super :: _prisma :: write_params :: StringParam) , ItemId (super :: _prisma :: write_params :: StringParam) , Action (super :: _prisma :: write_params :: StringParam) , QuantityChange (super :: _prisma :: write_params :: IntParam) , PreviousStock (super :: _prisma :: write_params :: IntParam) , NewStock (super :: _prisma :: write_params :: IntParam) , Note (super :: _prisma :: write_params :: StringNullableParam) , User (super :: _prisma :: write_params :: StringNullableParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for SetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => (id :: NAME , value . into ()) , Self :: ItemId (value) => (item_id :: NAME , value . into ()) , Self :: Action (value) => (action :: NAME , value . into ()) , Self :: QuantityChange (value) => (quantity_change :: NAME , value . into ()) , Self :: PreviousStock (value) => (previous_stock :: NAME , value . into ()) , Self :: NewStock (value) => (new_stock :: NAME , value . into ()) , Self :: Note (value) => (note :: NAME , value . into ()) , Self :: User (value) => (user :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum UncheckedSetParam { Id (super :: _prisma :: write_params :: StringParam) , ItemId (super :: _prisma :: write_params :: StringParam) , Action (super :: _prisma :: write_params :: StringParam) , QuantityChange (super :: _prisma :: write_params :: IntParam) , PreviousStock (super :: _prisma :: write_params :: IntParam) , NewStock (super :: _prisma :: write_params :: IntParam) , Note (super :: _prisma :: write_params :: StringNullableParam) , User (super :: _prisma :: write_params :: StringNullableParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for UncheckedSetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => ("id" , value . into ()) , Self :: ItemId (value) => ("itemId" , value . into ()) , Self :: Action (value) => ("action" , value . into ()) , Self :: QuantityChange (value) => ("quantityChange" , value . into ()) , Self :: PreviousStock (value) => ("previousStock" , value . into ()) , Self :: NewStock (value) => ("newStock" , value . into ()) , Self :: Note (value) => ("note" , value . into ()) , Self :: User (value) => ("user" , value . into ()) , Self :: CreatedAt (value) => ("createdAt" , value . into ()) } ; (k . to_string () , v) } } :: prisma_client_rust :: macros :: select_factory ! (_select_inventory_history , select , prisma :: inventory_history , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "itemId")] item_id : item_id :: Type , # [serde (rename = "action")] action : action :: Type , # [serde (rename = "quantityChange")] quantity_change : quantity_change :: Type , # [serde (rename = "previousStock")] previous_stock : previous_stock :: Type , # [serde (rename = "newStock")] new_stock : new_stock :: Type , # [serde (rename = "note")] note : note :: Type , # [serde (rename = "user")] user : user :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type } , [(id , Scalar) , (item_id , Scalar) , (action , Scalar) , (quantity_change , Scalar) , (previous_stock , Scalar) , (new_stock , Scalar) , (note , Scalar) , (user , Scalar) , (created_at , Scalar)]) ; pub enum SelectParam { Id (id :: Select) , ItemId (item_id :: Select) , Action (action :: Select) , QuantityChange (quantity_change :: Select) , PreviousStock (previous_stock :: Select) , NewStock (new_stock :: Select) , Note (note :: Select) , User (user :: Select) , CreatedAt (created_at :: Select) } impl Into < :: prisma_client_rust :: Selection > for SelectParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: ItemId (data) => data . into () , Self :: Action (data) => data . into () , Self :: QuantityChange (data) => data . into () , Self :: PreviousStock (data) => data . into () , Self :: NewStock (data) => data . into () , Self :: Note (data) => data . into () , Self :: User (data) => data . into () , Self :: CreatedAt (data) => data . into () } } } :: prisma_client_rust :: macros :: include_factory ! (_include_inventory_history , include , prisma :: inventory_history , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "itemId")] item_id : item_id :: Type , # [serde (rename = "action")] action : action :: Type , # [serde (rename = "quantityChange")] quantity_change : quantity_change :: Type , # [serde (rename = "previousStock")] previous_stock : previous_stock :: Type , # [serde (rename = "newStock")] new_stock : new_stock :: Type , # [serde (rename = "note")] note : note :: Type , # [serde (rename = "user")] user : user :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type } , []) ; pub enum IncludeParam { Id (id :: Include) , ItemId (item_id :: Include) , Action (action :: Include) , QuantityChange (quantity_change :: Include) , PreviousStock (previous_stock :: Include) , NewStock (new_stock :: Include) , Note (note :: Include) , User (user :: Include) , CreatedAt (created_at :: Include) } impl Into < :: prisma_client_rust :: Selection > for IncludeParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: ItemId (data) => data . into () , Self :: Action (data) => data . into () , Self :: QuantityChange (data) => data . into () , Self :: PreviousStock (data) => data . into () , Self :: NewStock (data) => data . into () , Self :: Note (data) => data . into () , Self :: User (data) => data . into () , Self :: CreatedAt (data) => data . into () } } } # [derive (Debug , Clone)] pub struct Create { pub item_id : String , pub action : String , pub quantity_change : Int , pub previous_stock : Int , pub new_stock : Int , pub _params : Vec < SetParam > } impl Create { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateQuery < 'a > { client . inventory_history () . create (self . item_id , self . action , self . quantity_change , self . previous_stock , self . new_stock , self . _params) } pub fn to_params (mut self) -> Vec < SetParam > { self . _params . extend ([item_id :: set (self . item_id) , action :: set (self . action) , quantity_change :: set (self . quantity_change) , previous_stock :: set (self . previous_stock) , new_stock :: set (self . new_stock)]) ; self . _params } } pub fn create (item_id : String , action : String , quantity_change : Int , previous_stock : Int , new_stock : Int , _params : Vec < SetParam >) -> Create { Create { item_id , action , quantity_change , previous_stock , new_stock , _params } } # [derive (Debug , Clone)] pub struct CreateUnchecked { pub item_id : String , pub action : String , pub quantity_change : Int , pub previous_stock : Int , pub new_stock : Int , pub _params : Vec < UncheckedSetParam > } impl CreateUnchecked { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateUncheckedQuery < 'a > { client . inventory_history () . create_unchecked (self . item_id , self . action , self . quantity_change , self . previous_stock , self . new_stock , self . _params) } pub fn to_params (mut self) -> Vec < UncheckedSetParam > { self . _params . extend ([item_id :: set (self . item_id) , action :: set (self . action) , quantity_change :: set (self . quantity_change) , previous_stock :: set (self . previous_stock) , new_stock :: set (self . new_stock)]) ; self . _params } } pub fn create_unchecked (item_id : String , action : String , quantity_change : Int , previous_stock : Int , new_stock : Int , _params : Vec < UncheckedSetParam >) -> CreateUnchecked { CreateUnchecked { item_id , action , quantity_change , previous_stock , new_stock , _params } } # [derive (Debug , Clone)] pub struct Types ; impl :: prisma_client_rust :: ModelTypes for Types { type Data = Data ; type Where = WhereParam ; type WhereUnique = UniqueWhereParam ; type UncheckedSet = UncheckedSetParam ; type Set = SetParam ; type With = WithParam ; type OrderBy = OrderByWithRelationParam ; type Cursor = UniqueWhereParam ; const MODEL : & 'static str = NAME ; fn scalar_selections () -> Vec < :: prisma_client_rust :: Selection > { vec ! [:: prisma_client_rust :: sel (id :: NAME) , :: prisma_client_rust :: sel (item_id :: NAME) , :: prisma_client_rust :: sel (action :: NAME) , :: prisma_client_rust :: sel (quantity_change :: NAME) , :: prisma_client_rust :: sel (previous_stock :: NAME) , :: prisma_client_rust :: sel (new_stock :: NAME) , :: prisma_client_rust :: sel (note :: NAME) , :: prisma_client_rust :: sel (user :: NAME) , :: prisma_client_rust :: sel (created_at :: NAME)] } } # [derive (Debug , Clone , :: serde :: Serialize , :: serde :: Deserialize)] pub struct Data { # [serde (rename = "id")] pub id : id :: Type , # [serde (rename = "itemId")] pub item_id : item_id :: Type , # [serde (rename = "action")] pub action : action :: Type , # [serde (rename = "quantityChange")] pub quantity_change : quantity_change :: Type , # [serde (rename = "previousStock")] pub previous_stock : previous_stock :: Type , # [serde (rename = "newStock")] pub new_stock : new_stock :: Type , # [serde (rename = "note")] pub note : note :: Type , # [serde (rename = "user")] pub user : user :: Type , # [serde (rename = "createdAt")] pub created_at : created_at :: Type } impl Data { } :: prisma_client_rust :: macros :: partial_unchecked_factory ! (_partial_unchecked_inventory_history , prisma :: inventory_history , struct Data { # [serde (rename = "id")] pub id : prisma :: inventory_history :: id :: Type , # [serde (rename = "itemId")] pub item_id : prisma :: inventory_history :: item_id :: Type , # [serde (rename = "action")] pub action : prisma :: inventory_history :: action :: Type , # [serde (rename = "quantityChange")] pub quantity_change : prisma :: inventory_history :: quantity_change :: Type , # [serde (rename = "previousStock")] pub previous_stock : prisma :: inventory_history :: previous_stock :: Type , # [serde (rename = "newStock")] pub new_stock : prisma :: inventory_history :: new_stock :: Type , # [serde (rename = "note")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub note : prisma :: inventory_history :: note :: Type , # [serde (rename = "user")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub user : prisma :: inventory_history :: user :: Type , # [serde (rename = "createdAt")] pub created_at : prisma :: inventory_history :: created_at :: Type }) ; :: prisma_client_rust :: macros :: filter_factory ! (_inventory_history_filter , prisma :: inventory_history , [(id , Scalar) , (item_id , Scalar) , (action , Scalar) , (quantity_change , Scalar) , (previous_stock , Scalar) , (new_stock , Scalar) , (note , Scalar) , (user , Scalar) , (created_at , Scalar)]) ; pub type UniqueArgs = :: prisma_client_rust :: UniqueArgs < Types > ; pub type ManyArgs = :: prisma_client_rust :: ManyArgs < Types > ; pub type CountQuery < 'a > = :: prisma_client_rust :: Count < 'a , Types > ; pub type CreateQuery < 'a > = :: prisma_client_rust :: Create < 'a , Types > ; pub type CreateUncheckedQuery < 'a > = :: prisma_client_rust :: CreateUnchecked < 'a , Types > ; pub type CreateManyQuery < 'a > = :: prisma_client_rust :: CreateMany < 'a , Types > ; pub type FindUniqueQuery < 'a > = :: prisma_client_rust :: FindUnique < 'a , Types > ; pub type FindManyQuery < 'a > = :: prisma_client_rust :: FindMany < 'a , Types > ; pub type FindFirstQuery < 'a > = :: prisma_client_rust :: FindFirst < 'a , Types > ; pub type UpdateQuery < 'a > = :: prisma_client_rust :: Update < 'a , Types > ; pub type UpdateUncheckedQuery < 'a > = :: prisma_client_rust :: UpdateUnchecked < 'a , Types > ; pub type UpdateManyQuery < 'a > = :: prisma_client_rust :: UpdateMany < 'a , Types > ; pub type UpsertQuery < 'a > = :: prisma_client_rust :: Upsert < 'a , Types > ; pub type DeleteQuery < 'a > = :: prisma_client_rust :: Delete < 'a , Types > ; pub type DeleteManyQuery < 'a > = :: prisma_client_rust :: DeleteMany < 'a , Types > ; # [derive (Clone)] pub struct Actions < 'a > { pub client : & 'a :: prisma_client_rust :: PrismaClientInternals , } impl < 'a > Actions < 'a > { pub fn find_unique (self , _where : UniqueWhereParam) -> FindUniqueQuery < 'a > { FindUniqueQuery :: new (self . client , _where) } pub fn find_first (self , _where : Vec < WhereParam >) -> FindFirstQuery < 'a > { FindFirstQuery :: new (self . client , _where) } pub fn find_many (self , _where : Vec < WhereParam >) -> FindManyQuery < 'a > { FindManyQuery :: new (self . client , _where) } pub fn create (self , item_id : impl Into < String > , action : impl Into < String > , quantity_change : impl Into < Int > , previous_stock : impl Into < Int > , new_stock : impl Into < Int > , mut _params : Vec < SetParam >) -> CreateQuery < 'a > { let item_id = item_id . into () ; let action = action . into () ; let quantity_change = quantity_change . into () ; let previous_stock = previous_stock . into () ; let new_stock = new_stock . into () ; _params . extend ([item_id :: set (item_id) , action :: set (action) , quantity_change :: set (quantity_change) , previous_stock :: set (previous_stock) , new_stock :: set (new_stock)]) ; CreateQuery :: new (self . client , _params) } pub fn create_unchecked (self , item_id : impl Into < String > , action : impl Into < String > , quantity_change : impl Into < Int > , previous_stock : impl Into < Int > , new_stock : impl Into < Int > , mut _params : Vec < UncheckedSetParam >) -> CreateUncheckedQuery < 'a > { let item_id = item_id . into () ; let action = action . into () ; let quantity_change = quantity_change . into () ; let previous_stock = previous_stock . into () ; let new_stock = new_stock . into () ; _params . extend ([item_id :: set (item_id) , action :: set (action) , quantity_change :: set (quantity_change) , previous_stock :: set (previous_stock) , new_stock :: set (new_stock)]) ; CreateUncheckedQuery :: new (self . client , _params . into_iter () . map (Into :: into) . collect ()) } pub fn create_many (self , data : Vec < CreateUnchecked >) -> CreateManyQuery < 'a > { let data = data . into_iter () . map (CreateUnchecked :: to_params) . collect () ; CreateManyQuery :: new (self . client , data) } pub fn update (self , _where : UniqueWhereParam , _params : Vec < SetParam >) -> UpdateQuery < 'a > { UpdateQuery :: new (self . client , _where , _params , vec ! []) } pub fn update_unchecked (self , _where : UniqueWhereParam , _params : Vec < UncheckedSetParam >) -> UpdateUncheckedQuery < 'a > { UpdateUncheckedQuery :: new (self . client , _where , _params . into_iter () . map (Into :: into) . collect () , vec ! []) } pub fn update_many (self , _where : Vec < WhereParam > , _params : Vec < SetParam >) -> UpdateManyQuery < 'a > { UpdateManyQuery :: new (self . client , _where , _params ,) } pub fn upsert (self , _where : UniqueWhereParam , _create : Create , _update : Vec < SetParam >) -> UpsertQuery < 'a > { UpsertQuery :: new (self . client , _where , _create . to_params () , _update) } pub fn delete (self , _where : UniqueWhereParam) -> DeleteQuery < 'a > { DeleteQuery :: new (self . client , _where , vec ! []) } pub fn delete_many (self , _where : Vec < WhereParam >) -> DeleteManyQuery < 'a > { DeleteManyQuery :: new (self . client , _where) } pub fn count (self , _where : Vec < WhereParam >) -> CountQuery < 'a > { CountQuery :: new (self . client , _where) } } pub mod action { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "action" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Action (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Action , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Action (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Action (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Action (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Action (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Action (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Action (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Action (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod created_at { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "createdAt" ; pub type Type = DateTime ; pub type RecursiveSafeType = Type ; pub struct Equals (pub DateTime) ; pub fn equals < T : From < Equals >> (value : impl Into < DateTime >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: CreatedAt (_prisma :: read_filters :: DateTimeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , CreatedAt , { fn in_vec (_ : Vec < DateTime >) -> InVec ; fn not_in_vec (_ : Vec < DateTime >) -> NotInVec ; fn lt (_ : DateTime) -> Lt ; fn lte (_ : DateTime) -> Lte ; fn gt (_ : DateTime) -> Gt ; fn gte (_ : DateTime) -> Gte ; fn not (_ : DateTime) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: CreatedAt (v) } } pub struct Set (pub DateTime) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < DateTime >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: DateTimeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "id" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: IdEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Id (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Id , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Id (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod item_id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "itemId" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: ItemId (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , ItemId , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: ItemId (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: ItemId (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ItemId (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: ItemId (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ItemId (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: ItemId (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: ItemId (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod new_stock { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "newStock" ; pub type Type = Int ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Int) ; pub fn equals < T : From < Equals >> (value : impl Into < Int >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: NewStock (_prisma :: read_filters :: IntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: IntFilter , NewStock , { fn in_vec (_ : Vec < Int >) -> InVec ; fn not_in_vec (_ : Vec < Int >) -> NotInVec ; fn lt (_ : Int) -> Lt ; fn lte (_ : Int) -> Lte ; fn gt (_ : Int) -> Gt ; fn gte (_ : Int) -> Gte ; fn not (_ : Int) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: NewStock (v) } } pub struct Set (pub Int) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: NewStock (_prisma :: write_params :: IntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Int >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: IntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: NewStock (v) } } pub fn increment < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: NewStock (_prisma :: write_params :: IntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: NewStock (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: NewStock (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: NewStock (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod note { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "note" ; pub type Type = Option < String > ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Option < String >) ; pub fn equals < T : From < Equals >> (value : impl Into < Option < String > >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Note (_prisma :: read_filters :: StringNullableFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringNullableFilter , Note , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : Option < String >) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Note (v) } } pub struct Set (pub Option < String >) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Note (_prisma :: write_params :: StringNullableParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Option < String > >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringNullableParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Note (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Note (_prisma :: write_params :: StringNullableParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Note (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Note (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Note (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod previous_stock { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "previousStock" ; pub type Type = Int ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Int) ; pub fn equals < T : From < Equals >> (value : impl Into < Int >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: PreviousStock (_prisma :: read_filters :: IntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: IntFilter , PreviousStock , { fn in_vec (_ : Vec < Int >) -> InVec ; fn not_in_vec (_ : Vec < Int >) -> NotInVec ; fn lt (_ : Int) -> Lt ; fn lte (_ : Int) -> Lte ; fn gt (_ : Int) -> Gt ; fn gte (_ : Int) -> Gte ; fn not (_ : Int) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: PreviousStock (v) } } pub struct Set (pub Int) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: PreviousStock (_prisma :: write_params :: IntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Int >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: IntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: PreviousStock (v) } } pub fn increment < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: PreviousStock (_prisma :: write_params :: IntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: PreviousStock (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: PreviousStock (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: PreviousStock (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod quantity_change { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "quantityChange" ; pub type Type = Int ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Int) ; pub fn equals < T : From < Equals >> (value : impl Into < Int >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: QuantityChange (_prisma :: read_filters :: IntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: IntFilter , QuantityChange , { fn in_vec (_ : Vec < Int >) -> InVec ; fn not_in_vec (_ : Vec < Int >) -> NotInVec ; fn lt (_ : Int) -> Lt ; fn lte (_ : Int) -> Lte ; fn gt (_ : Int) -> Gt ; fn gte (_ : Int) -> Gte ; fn not (_ : Int) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: QuantityChange (v) } } pub struct Set (pub Int) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: QuantityChange (_prisma :: write_params :: IntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Int >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: IntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: QuantityChange (v) } } pub fn increment < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: QuantityChange (_prisma :: write_params :: IntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: QuantityChange (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: QuantityChange (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: QuantityChange (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod user { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "user" ; pub type Type = Option < String > ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Option < String >) ; pub fn equals < T : From < Equals >> (value : impl Into < Option < String > >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: User (_prisma :: read_filters :: StringNullableFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringNullableFilter , User , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : Option < String >) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: User (v) } } pub struct Set (pub Option < String >) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: User (_prisma :: write_params :: StringNullableParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Option < String > >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringNullableParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: User (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: User (_prisma :: write_params :: StringNullableParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: User (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: User (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: User (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } } pub mod inventory_reorder { use super :: { _prisma :: * , * } ; pub const NAME : & str = "InventoryReorder" ; # [derive (Debug , Clone)] pub enum WhereParam { Not (Vec < WhereParam >) , Or (Vec < WhereParam >) , And (Vec < WhereParam >) , Id (super :: _prisma :: read_filters :: StringFilter) , ItemId (super :: _prisma :: read_filters :: StringFilter) , Quantity (super :: _prisma :: read_filters :: IntFilter) , Supplier (super :: _prisma :: read_filters :: StringNullableFilter) , Status (super :: _prisma :: read_filters :: StringFilter) , Note (super :: _prisma :: read_filters :: StringNullableFilter) , User (super :: _prisma :: read_filters :: StringNullableFilter) , CreatedAt (super :: _prisma :: read_filters :: DateTimeFilter) } impl :: prisma_client_rust :: WhereInput for WhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (| p | :: prisma_client_rust :: PrismaValue :: Object (vec ! [p . into ()])) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Id (value) => (id :: NAME , value . into ()) , Self :: ItemId (value) => (item_id :: NAME , value . into ()) , Self :: Quantity (value) => (quantity :: NAME , value . into ()) , Self :: Supplier (value) => (supplier :: NAME , value . into ()) , Self :: Status (value) => (status :: NAME , value . into ()) , Self :: Note (value) => (note :: NAME , value . into ()) , Self :: User (value) => (user :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } # [derive (Debug , Clone)] pub enum UniqueWhereParam { IdEquals (String) } impl :: prisma_client_rust :: WhereInput for UniqueWhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { UniqueWhereParam :: IdEquals (value) => ("id" , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: String (value))) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name . to_string () , value . into ()) } } impl From < :: prisma_client_rust :: Operator < Self >> for WhereParam { fn from (op : :: prisma_client_rust :: Operator < Self >) -> Self { match op { :: prisma_client_rust :: Operator :: Not (value) => Self :: Not (value) , :: prisma_client_rust :: Operator :: And (value) => Self :: And (value) , :: prisma_client_rust :: Operator :: Or (value) => Self :: Or (value) , } } } # [derive (Debug , Clone)] pub enum OrderByWithRelationParam { Id (super :: SortOrder) , ItemId (super :: SortOrder) , Quantity (super :: SortOrder) , Supplier (super :: SortOrder) , Status (super :: SortOrder) , Note (super :: SortOrder) , User (super :: SortOrder) , CreatedAt (super :: SortOrder) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByWithRelationParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (param) => ("id" , param . into ()) , Self :: ItemId (param) => ("itemId" , param . into ()) , Self :: Quantity (param) => ("quantity" , param . into ()) , Self :: Supplier (param) => ("supplier" , param . into ()) , Self :: Status (param) => ("status" , param . into ()) , Self :: Note (param) => ("note" , param . into ()) , Self :: User (param) => ("user" , param . into ()) , Self :: CreatedAt (param) => ("createdAt" , param . into ()) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum WithParam { } impl Into < :: prisma_client_rust :: Selection > for WithParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { } } } # [derive (Debug , Clone)] pub enum SetParam { Id (super :: _prisma :: write_params :: StringParam) , ItemId (super :: _prisma :: write_params :: StringParam) , Quantity (super :: _prisma :: write_params :: IntParam) , Supplier (super :: _prisma :: write_params :: StringNullableParam) , Status (super :: _prisma :: write_params :: StringParam) , Note (super :: _prisma :: write_params :: StringNullableParam) , User (super :: _prisma :: write_params :: StringNullableParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for SetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => (id :: NAME , value . into ()) , Self :: ItemId (value) => (item_id :: NAME , value . into ()) , Self :: Quantity (value) => (quantity :: NAME , value . into ()) , Self :: Supplier (value) => (supplier :: NAME , value . into ()) , Self :: Status (value) => (status :: NAME , value . into ()) , Self :: Note (value) => (note :: NAME , value . into ()) , Self :: User (value) => (user :: NAME , value . into ()) , Self :: CreatedAt (value) => (created_at :: NAME , value . into ()) } ; (k . to_string () , v) } } # [derive (Debug , Clone)] pub enum UncheckedSetParam { Id (super :: _prisma :: write_params :: StringParam) , ItemId (super :: _prisma :: write_params :: StringParam) , Quantity (super :: _prisma :: write_params :: IntParam) , Supplier (super :: _prisma :: write_params :: StringNullableParam) , Status (super :: _prisma :: write_params :: StringParam) , Note (super :: _prisma :: write_params :: StringNullableParam) , User (super :: _prisma :: write_params :: StringNullableParam) , CreatedAt (super :: _prisma :: write_params :: DateTimeParam) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for UncheckedSetParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { let (k , v) = match self { Self :: Id (value) => ("id" , value . into ()) , Self :: ItemId (value) => ("itemId" , value . into ()) , Self :: Quantity (value) => ("quantity" , value . into ()) , Self :: Supplier (value) => ("supplier" , value . into ()) , Self :: Status (value) => ("status" , value . into ()) , Self :: Note (value) => ("note" , value . into ()) , Self :: User (value) => ("user" , value . into ()) , Self :: CreatedAt (value) => ("createdAt" , value . into ()) } ; (k . to_string () , v) } } :: prisma_client_rust :: macros :: select_factory ! (_select_inventory_reorder , select , prisma :: inventory_reorder , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "itemId")] item_id : item_id :: Type , # [serde (rename = "quantity")] quantity : quantity :: Type , # [serde (rename = "supplier")] supplier : supplier :: Type , # [serde (rename = "status")] status : status :: Type , # [serde (rename = "note")] note : note :: Type , # [serde (rename = "user")] user : user :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type } , [(id , Scalar) , (item_id , Scalar) , (quantity , Scalar) , (supplier , Scalar) , (status , Scalar) , (note , Scalar) , (user , Scalar) , (created_at , Scalar)]) ; pub enum SelectParam { Id (id :: Select) , ItemId (item_id :: Select) , Quantity (quantity :: Select) , Supplier (supplier :: Select) , Status (status :: Select) , Note (note :: Select) , User (user :: Select) , CreatedAt (created_at :: Select) } impl Into < :: prisma_client_rust :: Selection > for SelectParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: ItemId (data) => data . into () , Self :: Quantity (data) => data . into () , Self :: Supplier (data) => data . into () , Self :: Status (data) => data . into () , Self :: Note (data) => data . into () , Self :: User (data) => data . into () , Self :: CreatedAt (data) => data . into () } } } :: prisma_client_rust :: macros :: include_factory ! (_include_inventory_reorder , include , prisma :: inventory_reorder , struct Data { # [serde (rename = "id")] id : id :: Type , # [serde (rename = "itemId")] item_id : item_id :: Type , # [serde (rename = "quantity")] quantity : quantity :: Type , # [serde (rename = "supplier")] supplier : supplier :: Type , # [serde (rename = "status")] status : status :: Type , # [serde (rename = "note")] note : note :: Type , # [serde (rename = "user")] user : user :: Type , # [serde (rename = "createdAt")] created_at : created_at :: Type } , []) ; pub enum IncludeParam { Id (id :: Include) , ItemId (item_id :: Include) , Quantity (quantity :: Include) , Supplier (supplier :: Include) , Status (status :: Include) , Note (note :: Include) , User (user :: Include) , CreatedAt (created_at :: Include) } impl Into < :: prisma_client_rust :: Selection > for IncludeParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . into () , Self :: ItemId (data) => data . into () , Self :: Quantity (data) => data . into () , Self :: Supplier (data) => data . into () , Self :: Status (data) => data . into () , Self :: Note (data) => data . into () , Self :: User (data) => data . into () , Self :: CreatedAt (data) => data . into () } } } # [derive (Debug , Clone)] pub struct Create { pub item_id : String , pub quantity : Int , pub status : String , pub _params : Vec < SetParam > } impl Create { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateQuery < 'a > { client . inventory_reorder () . create (self . item_id , self . quantity , self . status , self . _params) } pub fn to_params (mut self) -> Vec < SetParam > { self . _params . extend ([item_id :: set (self . item_id) , quantity :: set (self . quantity) , status :: set (self . status)]) ; self . _params } } pub fn create (item_id : String , quantity : Int , status : String , _params : Vec < SetParam >) -> Create { Create { item_id , quantity , status , _params } } # [derive (Debug , Clone)] pub struct CreateUnchecked { pub item_id : String , pub quantity : Int , pub status : String , pub _params : Vec < UncheckedSetParam > } impl CreateUnchecked { pub fn to_query < 'a > (self , client : & 'a PrismaClient) -> CreateUncheckedQuery < 'a > { client . inventory_reorder () . create_unchecked (self . item_id , self . quantity , self . status , self . _params) } pub fn to_params (mut self) -> Vec < UncheckedSetParam > { self . _params . extend ([item_id :: set (self . item_id) , quantity :: set (self . quantity) , status :: set (self . status)]) ; self . _params } } pub fn create_unchecked (item_id : String , quantity : Int , status : String , _params : Vec < UncheckedSetParam >) -> CreateUnchecked { CreateUnchecked { item_id , quantity , status , _params } } # [derive (Debug , Clone)] pub struct Types ; impl :: prisma_client_rust :: ModelTypes for Types { type Data = Data ; type Where = WhereParam ; type WhereUnique = UniqueWhereParam ; type UncheckedSet = UncheckedSetParam ; type Set = SetParam ; type With = WithParam ; type OrderBy = OrderByWithRelationParam ; type Cursor = UniqueWhereParam ; const MODEL : & 'static str = NAME ; fn scalar_selections () -> Vec < :: prisma_client_rust :: Selection > { vec ! [:: prisma_client_rust :: sel (id :: NAME) , :: prisma_client_rust :: sel (item_id :: NAME) , :: prisma_client_rust :: sel (quantity :: NAME) , :: prisma_client_rust :: sel (supplier :: NAME) , :: prisma_client_rust :: sel (status :: NAME) , :: prisma_client_rust :: sel (note :: NAME) , :: prisma_client_rust :: sel (user :: NAME) , :: prisma_client_rust :: sel (created_at :: NAME)] } } # [derive (Debug , Clone , :: serde :: Serialize , :: serde :: Deserialize)] pub struct Data { # [serde (rename = "id")] pub id : id :: Type , # [serde (rename = "itemId")] pub item_id : item_id :: Type , # [serde (rename = "quantity")] pub quantity : quantity :: Type , # [serde (rename = "supplier")] pub supplier : supplier :: Type , # [serde (rename = "status")] pub status : status :: Type , # [serde (rename = "note")] pub note : note :: Type , # [serde (rename = "user")] pub user : user :: Type , # [serde (rename = "createdAt")] pub created_at : created_at :: Type } impl Data { } :: prisma_client_rust :: macros :: partial_unchecked_factory ! (_partial_unchecked_inventory_reorder , prisma :: inventory_reorder , struct Data { # [serde (rename = "id")] pub id : prisma :: inventory_reorder :: id :: Type , # [serde (rename = "itemId")] pub item_id : prisma :: inventory_reorder :: item_id :: Type , # [serde (rename = "quantity")] pub quantity : prisma :: inventory_reorder :: quantity :: Type , # [serde (rename = "supplier")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub supplier : prisma :: inventory_reorder :: supplier :: Type , # [serde (rename = "status")] pub status : prisma :: inventory_reorder :: status :: Type , # [serde (rename = "note")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub note : prisma :: inventory_reorder :: note :: Type , # [serde (rename = "user")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub user : prisma :: inventory_reorder :: user :: Type , # [serde (rename = "createdAt")] pub created_at : prisma :: inventory_reorder :: created_at :: Type }) ; :: prisma_client_rust :: macros :: filter_factory ! (_inventory_reorder_filter , prisma :: inventory_reorder , [(id , Scalar) , (item_id , Scalar) , (quantity , Scalar) , (supplier , Scalar) , (status , Scalar) , (note , Scalar) , (user , Scalar) , (created_at , Scalar)]) ; pub type UniqueArgs = :: prisma_client_rust :: UniqueArgs < Types > ; pub type ManyArgs = :: prisma_client_rust :: ManyArgs < Types > ; pub type CountQuery < 'a > = :: prisma_client_rust :: Count < 'a , Types > ; pub type CreateQuery < 'a > = :: prisma_client_rust :: Create < 'a , Types > ; pub type CreateUncheckedQuery < 'a > = :: prisma_client_rust :: CreateUnchecked < 'a , Types > ; pub type CreateManyQuery < 'a > = :: prisma_client_rust :: CreateMany < 'a , Types > ; pub type FindUniqueQuery < 'a > = :: prisma_client_rust :: FindUnique < 'a , Types > ; pub type FindManyQuery < 'a > = :: prisma_client_rust :: FindMany < 'a , Types > ; pub type FindFirstQuery < 'a > = :: prisma_client_rust :: FindFirst < 'a , Types > ; pub type UpdateQuery < 'a > = :: prisma_client_rust :: Update < 'a , Types > ; pub type UpdateUncheckedQuery < 'a > = :: prisma_client_rust :: UpdateUnchecked < 'a , Types > ; pub type UpdateManyQuery < 'a > = :: prisma_client_rust :: UpdateMany < 'a , Types > ; pub type UpsertQuery < 'a > = :: prisma_client_rust :: Upsert < 'a , Types > ; pub type DeleteQuery < 'a > = :: prisma_client_rust :: Delete < 'a , Types > ; pub type DeleteManyQuery < 'a > = :: prisma_client_rust :: DeleteMany < 'a , Types > ; # [derive (Clone)] pub struct Actions < 'a > { pub client : & 'a :: prisma_client_rust :: PrismaClientInternals , } impl < 'a > Actions < 'a > { pub fn find_unique (self , _where : UniqueWhereParam) -> FindUniqueQuery < 'a > { FindUniqueQuery :: new (self . client , _where) } pub fn find_first (self , _where : Vec < WhereParam >) -> FindFirstQuery < 'a > { FindFirstQuery :: new (self . client , _where) } pub fn find_many (self , _where : Vec < WhereParam >) -> FindManyQuery < 'a > { FindManyQuery :: new (self . client , _where) } pub fn create (self , item_id : impl Into < String > , quantity : impl Into < Int > , status : impl Into < String > , mut _params : Vec < SetParam >) -> CreateQuery < 'a > { let item_id = item_id . into () ; let quantity = quantity . into () ; let status = status . into () ; _params . extend ([item_id :: set (item_id) , quantity :: set (quantity) , status :: set (status)]) ; CreateQuery :: new (self . client , _params) } pub fn create_unchecked (self , item_id : impl Into < String > , quantity : impl Into < Int > , status : impl Into < String > , mut _params : Vec < UncheckedSetParam >) -> CreateUncheckedQuery < 'a > { let item_id = item_id . into () ; let quantity = quantity . into () ; let status = status . into () ; _params . extend ([item_id :: set (item_id) , quantity :: set (quantity) , status :: set (status)]) ; CreateUncheckedQuery :: new (self . client , _params . into_iter () . map (Into :: into) . collect ()) } pub fn create_many (self , data : Vec < CreateUnchecked >) -> CreateManyQuery < 'a > { let data = data . into_iter () . map (CreateUnchecked :: to_params) . collect () ; CreateManyQuery :: new (self . client , data) } pub fn update (self , _where : UniqueWhereParam , _params : Vec < SetParam >) -> UpdateQuery < 'a > { UpdateQuery :: new (self . client , _where , _params , vec ! []) } pub fn update_unchecked (self , _where : UniqueWhereParam , _params : Vec < UncheckedSetParam >) -> UpdateUncheckedQuery < 'a > { UpdateUncheckedQuery :: new (self . client , _where , _params . into_iter () . map (Into :: into) . collect () , vec ! []) } pub fn update_many (self , _where : Vec < WhereParam > , _params : Vec < SetParam >) -> UpdateManyQuery < 'a > { UpdateManyQuery :: new (self . client , _where , _params ,) } pub fn upsert (self , _where : UniqueWhereParam , _create : Create , _update : Vec < SetParam >) -> UpsertQuery < 'a > { UpsertQuery :: new (self . client , _where , _create . to_params () , _update) } pub fn delete (self , _where : UniqueWhereParam) -> DeleteQuery < 'a > { DeleteQuery :: new (self . client , _where , vec ! []) } pub fn delete_many (self , _where : Vec < WhereParam >) -> DeleteManyQuery < 'a > { DeleteManyQuery :: new (self . client , _where) } pub fn count (self , _where : Vec < WhereParam >) -> CountQuery < 'a > { CountQuery :: new (self . client , _where) } } pub mod created_at { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "createdAt" ; pub type Type = DateTime ; pub type RecursiveSafeType = Type ; pub struct Equals (pub DateTime) ; pub fn equals < T : From < Equals >> (value : impl Into < DateTime >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: CreatedAt (_prisma :: read_filters :: DateTimeFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , CreatedAt , { fn in_vec (_ : Vec < DateTime >) -> InVec ; fn not_in_vec (_ : Vec < DateTime >) -> NotInVec ; fn lt (_ : DateTime) -> Lt ; fn lte (_ : DateTime) -> Lte ; fn gt (_ : DateTime) -> Gt ; fn gte (_ : DateTime) -> Gte ; fn not (_ : DateTime) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: CreatedAt (v) } } pub struct Set (pub DateTime) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < DateTime >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: DateTimeParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: CreatedAt (_prisma :: write_params :: DateTimeParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: CreatedAt (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: CreatedAt (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "id" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for UniqueWhereParam { fn from (Equals (v) : Equals) -> Self { UniqueWhereParam :: IdEquals (v) } } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Id (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Id , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Id (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Id (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Id (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Id (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod item_id { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "itemId" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: ItemId (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , ItemId , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: ItemId (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: ItemId (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ItemId (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: ItemId (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: ItemId (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: ItemId (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: ItemId (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod note { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "note" ; pub type Type = Option < String > ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Option < String >) ; pub fn equals < T : From < Equals >> (value : impl Into < Option < String > >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Note (_prisma :: read_filters :: StringNullableFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringNullableFilter , Note , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : Option < String >) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Note (v) } } pub struct Set (pub Option < String >) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Note (_prisma :: write_params :: StringNullableParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Option < String > >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringNullableParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Note (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Note (_prisma :: write_params :: StringNullableParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Note (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Note (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Note (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod quantity { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "quantity" ; pub type Type = Int ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Int) ; pub fn equals < T : From < Equals >> (value : impl Into < Int >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Quantity (_prisma :: read_filters :: IntFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: IntFilter , Quantity , { fn in_vec (_ : Vec < Int >) -> InVec ; fn not_in_vec (_ : Vec < Int >) -> NotInVec ; fn lt (_ : Int) -> Lt ; fn lte (_ : Int) -> Lte ; fn gt (_ : Int) -> Gt ; fn gte (_ : Int) -> Gte ; fn not (_ : Int) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Quantity (v) } } pub struct Set (pub Int) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Quantity (_prisma :: write_params :: IntParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Int >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: IntParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Quantity (v) } } pub fn increment < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Increment (value)) . into () } pub fn decrement < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Decrement (value)) . into () } pub fn multiply < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Multiply (value)) . into () } pub fn divide < T : From < UpdateOperation >> (value : Int) -> T { UpdateOperation (_prisma :: write_params :: IntParam :: Divide (value)) . into () } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Quantity (_prisma :: write_params :: IntParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Quantity (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Quantity (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Quantity (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod status { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "status" ; pub type Type = String ; pub type RecursiveSafeType = Type ; pub struct Equals (pub String) ; pub fn equals < T : From < Equals >> (value : impl Into < String >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Status (_prisma :: read_filters :: StringFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Status , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Status (v) } } pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Status (_prisma :: write_params :: StringParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < String >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Status (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Status (_prisma :: write_params :: StringParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Status (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Status (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Status (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod supplier { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "supplier" ; pub type Type = Option < String > ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Option < String >) ; pub fn equals < T : From < Equals >> (value : impl Into < Option < String > >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: Supplier (_prisma :: read_filters :: StringNullableFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringNullableFilter , Supplier , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : Option < String >) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: Supplier (v) } } pub struct Set (pub Option < String >) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: Supplier (_prisma :: write_params :: StringNullableParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Option < String > >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringNullableParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Supplier (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Supplier (_prisma :: write_params :: StringNullableParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: Supplier (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Supplier (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Supplier (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod user { use super :: super :: { _prisma :: * , * } ; use super :: { WhereParam , UniqueWhereParam , WithParam , SetParam , UncheckedSetParam } ; pub const NAME : & str = "user" ; pub type Type = Option < String > ; pub type RecursiveSafeType = Type ; pub struct Equals (pub Option < String >) ; pub fn equals < T : From < Equals >> (value : impl Into < Option < String > >) -> T { Equals (value . into ()) . into () } impl From < Equals > for WhereParam { fn from (Equals (v) : Equals) -> Self { WhereParam :: User (_prisma :: read_filters :: StringNullableFilter :: Equals (v)) } } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringNullableFilter , User , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : Option < String >) -> Not ; }) ; pub struct Order (SortOrder) ; pub fn order < T : From < Order >> (v : SortOrder) -> T { Order (v) . into () } impl From < Order > for super :: OrderByWithRelationParam { fn from (Order (v) : Order) -> Self { Self :: User (v) } } pub struct Set (pub Option < String >) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: User (_prisma :: write_params :: StringNullableParam :: Set (v)) } } pub fn set < T : From < Set >> (value : impl Into < Option < String > >) -> T { Set (value . into ()) . into () } pub struct UpdateOperation (pub _prisma :: write_params :: StringNullableParam) ; impl From < UpdateOperation > for SetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: User (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: User (_prisma :: write_params :: StringNullableParam :: Set (v)) } } impl From < UpdateOperation > for UncheckedSetParam { fn from (UpdateOperation (v) : UpdateOperation) -> Self { Self :: User (v) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: User (self) } } impl Into < :: prisma_client_rust :: Selection > for Select { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: User (self) } } impl Into < :: prisma_client_rust :: Selection > for Include { fn into (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } }